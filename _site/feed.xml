<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-US"><generator uri="https://jekyllrb.com/" version="4.1.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="en-US" /><updated>2025-05-12T13:56:54+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">seacho’s blog</title><subtitle>分享砍柴细节。</subtitle><author><name>樵夫砍柴手札</name><email>p1ain0@outlook.com</email></author><entry><title type="html">fuzzingbook阅读笔记</title><link href="http://localhost:4000/fuzzingbook-study/" rel="alternate" type="text/html" title="fuzzingbook阅读笔记" /><published>2025-03-24T00:00:00+08:00</published><updated>2025-03-24T00:00:00+08:00</updated><id>http://localhost:4000/fuzzingbook-study</id><content type="html" xml:base="http://localhost:4000/fuzzingbook-study/"><![CDATA[<p>最近学习的fuzz技术，简单做下笔记。</p>

<h2 id="coverage">coverage</h2>

<p>cc –coverage -o cgi_decode cgi_decode.c</p>

<p>gcov cgi_decode cgi_decode-cgi_decode</p>

<p>cgi_decode.c.gcov</p>

<p>In the .gcov file, each line is prefixed with the number of times it was called (- stands for a non-executable line, ##### stands for zero) as well as the line number. We can take a look at cgi_decode(), for instance, and see that the only code not executed yet is the return -1 for an illegal input.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">def</span> <span class="nf">read_gcov_coverage</span><span class="p">(</span><span class="n">c_file</span><span class="p">):</span>
    <span class="n">gcov_file</span> <span class="o">=</span> <span class="n">c_file</span> <span class="o">+</span> <span class="s">".gcov"</span>
    <span class="n">coverage</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">gcov_file</span><span class="p">)</span> <span class="k">as</span> <span class="nb">file</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">file</span><span class="p">.</span><span class="n">readlines</span><span class="p">():</span>
            <span class="n">elems</span> <span class="o">=</span> <span class="n">line</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">':'</span><span class="p">)</span>
            <span class="n">covered</span> <span class="o">=</span> <span class="n">elems</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">strip</span><span class="p">()</span>
            <span class="n">line_number</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">elems</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">strip</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">covered</span><span class="p">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">'-'</span><span class="p">)</span> <span class="ow">or</span> <span class="n">covered</span><span class="p">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">'#'</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="n">coverage</span><span class="p">.</span><span class="n">add</span><span class="p">((</span><span class="n">c_file</span><span class="p">,</span> <span class="n">line_number</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">coverage</span>


<span class="n">coverage</span> <span class="o">=</span> <span class="n">read_gcov_coverage</span><span class="p">(</span><span class="s">'cgi_decode.c'</span><span class="p">)</span>    

</code></pre></div></div>

<h2 id="greybox-fuzzing">Greybox Fuzzing</h2>

<p>power schedule：我们的目标是最大限度地利用fuzz的seed所花费的时间，从而在更短的时间内实现更高的覆盖率。于是我们给seed的优先级排个序。我们定义seed的被选择的可能性叫做，seed’s energy 在整个模糊测试过程中，我们希望优先考虑更有希望的seed，我们将确定seed ‘s power的过程称为模糊器的power schedule。</p>

<h2 id="search-based-fuzzing">Search-Based Fuzzing</h2>

<p>启发式比彻底的搜索要高效。</p>

<p>基本思想：</p>

<h3 id="fitness-function">fitness function</h3>

<p>定义一个Fitness function，所有的启发式算法（meta-heuristics）都是基于启发式（heuristics）函数的使用，该函数用来估计给定候选方案的好坏。这种“goodness”被称为个体的“fitness”。适应度函数是将搜索空间中的任何点映射到数值（适应度值）的函数。搜索空间中的候选解相对于最优解越好，其适应度值就越好。</p>

<p>比如，下面这个例子</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">test_me</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>

<span class="k">def</span> <span class="nf">calculate_distance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
  <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>


</code></pre></div></div>

<p>我们可以使用这个距离值作为我们的适应度函数，因为我们可以很好地衡量我们离最优解有多近。然而，请注意，在这种情况下，距离越小越好。</p>

<p>适应度函数应计算具体测试执行的距离值。也就是说，我们想运行程序，然后学习这次执行的距离值。但是分支条件隐藏在目标函数的源代码中，其值可能是沿着到达它的执行路径进行的各种计算的结果。即使在我们的例子中，该条件是一个直接使用函数输入值的方程，但通常情况并非如此，它可能和衍生出来值一样。因此，我们需要在条件语句中直接观察到计算距离度量所需的值。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">def</span> <span class="nf">test_me_instrumented</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>  <span class="c1"># type: ignore
</span>    <span class="k">global</span> <span class="n">distance</span>
    <span class="n">distance</span> <span class="o">=</span> <span class="n">calculate_distance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>

<span class="k">def</span> <span class="nf">get_fitness</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
  <span class="k">global</span> <span class="n">distance</span>
  <span class="n">test_me_instrumented</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
  <span class="n">fitness</span> <span class="o">=</span> <span class="n">distance</span>
  <span class="k">return</span> <span class="n">fitness</span>

</code></pre></div></div>

<h3 id="hillclimbing-算法">Hillclimbing 算法</h3>

<p>让我们使用最简单的元启发式算法来探索这个搜索空间，Hillclimbing算法。（跟机器学习有点像）</p>

<p>在确定了表示（整数的两个元组）和适应度函数（到目标分支的距离）之后。我们来看这个算法，该算法试图在我们的表示定义的搜索空间中寻找最优解。但是在我们的搜索环境中，最好的值不是那些高的值，而是低的值。（下山更形象）。算法本身非常简单：
1.取一个随机起点
2.确定所有邻居的适应度值
3.移动到具有最佳健身值的邻居
4.如果未找到解决方案，请继续执行步骤2</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">LOG_VALUES</span> <span class="o">=</span> <span class="mi">20</span>  <span class="c1"># Number of values to log
</span><span class="k">def</span> <span class="nf">hillclimber</span><span class="p">():</span>
    <span class="c1"># Create and evaluate starting point
</span>    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="n">randint</span><span class="p">(</span><span class="n">MIN</span><span class="p">,</span> <span class="n">MAX</span><span class="p">),</span> <span class="n">random</span><span class="p">.</span><span class="n">randint</span><span class="p">(</span><span class="n">MIN</span><span class="p">,</span> <span class="n">MAX</span><span class="p">)</span>
    <span class="n">fitness</span> <span class="o">=</span> <span class="n">get_fitness</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"Initial value: %d, %d at fitness %.4f"</span> <span class="o">%</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">fitness</span><span class="p">))</span>
    <span class="n">iterations</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">logs</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># Stop once we have found an optimal solution
</span>    <span class="k">while</span> <span class="n">fitness</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">iterations</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># Move to first neighbor with a better fitness
</span>        <span class="k">for</span> <span class="p">(</span><span class="n">nextx</span><span class="p">,</span> <span class="n">nexty</span><span class="p">)</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
            <span class="n">new_fitness</span> <span class="o">=</span> <span class="n">get_fitness</span><span class="p">(</span><span class="n">nextx</span><span class="p">,</span> <span class="n">nexty</span><span class="p">)</span>

            <span class="c1"># Smaller fitness values are better
</span>            <span class="k">if</span> <span class="n">new_fitness</span> <span class="o">&lt;</span> <span class="n">fitness</span><span class="p">:</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">nextx</span><span class="p">,</span> <span class="n">nexty</span>
                <span class="n">fitness</span> <span class="o">=</span> <span class="n">new_fitness</span>
                <span class="k">if</span> <span class="n">logs</span> <span class="o">&lt;</span> <span class="n">LOG_VALUES</span><span class="p">:</span>
                    <span class="k">print</span><span class="p">(</span><span class="s">"New value: %d, %d at fitness %.4f"</span> <span class="o">%</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">fitness</span><span class="p">))</span>
                <span class="k">elif</span> <span class="n">logs</span> <span class="o">==</span> <span class="n">LOG_VALUES</span><span class="p">:</span>
                    <span class="k">print</span><span class="p">(</span><span class="s">"..."</span><span class="p">)</span>
                <span class="n">logs</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">break</span>

    <span class="k">print</span><span class="p">(</span><span class="s">"Found optimum after %d iterations at %d, %d"</span> <span class="o">%</span> <span class="p">(</span><span class="n">iterations</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>

</code></pre></div></div>

<p>首先为x和y选择随机值。我们使用-1000–1000范围内的低值来减少玩这个例子时的搜索时间。然后，我们通过调用get_fitness来确定这个起点的适应度值。我们正试图找到最小的适应度值，因此我们现在循环，直到找到适应度值0（即最佳值）。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">steepest_ascent_hillclimber</span><span class="p">():</span>
  <span class="c1"># Create and evaluate starting point
</span>  <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="n">randint</span><span class="p">(</span><span class="n">MIN</span><span class="p">,</span> <span class="n">MAX</span><span class="p">),</span> <span class="n">random</span><span class="p">.</span><span class="n">randint</span><span class="p">(</span><span class="n">MIN</span><span class="p">,</span> <span class="n">MAX</span><span class="p">)</span>
  <span class="n">fitness</span> <span class="o">=</span> <span class="n">get_fitness</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
  <span class="k">print</span><span class="p">(</span><span class="s">"Initial value: %d, %d at fitness %.4f"</span> <span class="o">%</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">fitness</span><span class="p">))</span>
  <span class="n">iterations</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="n">logs</span> <span class="o">=</span> <span class="mi">0</span>

  <span class="c1"># Stop once we have found an optimal solution
</span>  <span class="k">while</span> <span class="n">fitness</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
      <span class="n">iterations</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="c1"># Move to first neighbor with a better fitness
</span>      <span class="k">for</span> <span class="p">(</span><span class="n">nextx</span><span class="p">,</span> <span class="n">nexty</span><span class="p">)</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
          <span class="n">new_fitness</span> <span class="o">=</span> <span class="n">get_fitness</span><span class="p">(</span><span class="n">nextx</span><span class="p">,</span> <span class="n">nexty</span><span class="p">)</span>
          <span class="k">if</span> <span class="n">new_fitness</span> <span class="o">&lt;</span> <span class="n">fitness</span><span class="p">:</span>
              <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">nextx</span><span class="p">,</span> <span class="n">nexty</span>
              <span class="n">fitness</span> <span class="o">=</span> <span class="n">new_fitness</span>
              <span class="k">if</span> <span class="n">logs</span> <span class="o">&lt;</span> <span class="n">LOG_VALUES</span><span class="p">:</span>
                  <span class="k">print</span><span class="p">(</span><span class="s">"New value: %d, %d at fitness %.4f"</span> <span class="o">%</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">fitness</span><span class="p">))</span>
              <span class="k">elif</span> <span class="n">logs</span> <span class="o">==</span> <span class="n">LOG_VALUES</span><span class="p">:</span>
                  <span class="k">print</span><span class="p">(</span><span class="s">"..."</span><span class="p">)</span>
              <span class="n">logs</span> <span class="o">+=</span> <span class="mi">1</span>

  <span class="k">print</span><span class="p">(</span><span class="s">"Found optimum after %d iterations at %d, %d"</span> <span class="o">%</span> <span class="p">(</span><span class="n">iterations</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>


</code></pre></div></div>

<p>但有一个问题：用这个运行我们的登山者不是一个最优的方案，因为它可能永远不会终止。假设我们已经达到了一个点，所有邻居的适应度值都相同或更差。登山者无法移动，永远被困在那里！搜索环境中的这样一个点称为局部最优点。如果达到这样一个点，最简单的办法就是放弃，从一个新的随机点重新开始。这就是我们将在登山者身上随机重启的方法。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">restarting_hillclimber</span><span class="p">(</span><span class="n">fitness_function</span><span class="p">):</span>
    <span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Create and evaluate starting point
</span>    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="n">randint</span><span class="p">(</span><span class="n">MIN</span><span class="p">,</span> <span class="n">MAX</span><span class="p">),</span> <span class="n">random</span><span class="p">.</span><span class="n">randint</span><span class="p">(</span><span class="n">MIN</span><span class="p">,</span> <span class="n">MAX</span><span class="p">)</span>
    <span class="n">fitness</span> <span class="o">=</span> <span class="n">fitness_function</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">+=</span> <span class="p">[</span><span class="n">fitness</span><span class="p">]</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"Initial value: %d, %d at fitness %.4f"</span> <span class="o">%</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">fitness</span><span class="p">))</span>
    <span class="n">iterations</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># Stop once we have found an optimal solution
</span>    <span class="k">while</span> <span class="n">fitness</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">changed</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">iterations</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># Move to first neighbor with a better fitness
</span>        <span class="k">for</span> <span class="p">(</span><span class="n">nextx</span><span class="p">,</span> <span class="n">nexty</span><span class="p">)</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
            <span class="n">new_fitness</span> <span class="o">=</span> <span class="n">fitness_function</span><span class="p">(</span><span class="n">nextx</span><span class="p">,</span> <span class="n">nexty</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">new_fitness</span> <span class="o">&lt;</span> <span class="n">fitness</span><span class="p">:</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">nextx</span><span class="p">,</span> <span class="n">nexty</span>
                <span class="n">fitness</span> <span class="o">=</span> <span class="n">new_fitness</span>
                <span class="n">data</span> <span class="o">+=</span> <span class="p">[</span><span class="n">fitness</span><span class="p">]</span>
                <span class="n">changed</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">changed</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="n">randint</span><span class="p">(</span><span class="n">MIN</span><span class="p">,</span> <span class="n">MAX</span><span class="p">),</span> <span class="n">random</span><span class="p">.</span><span class="n">randint</span><span class="p">(</span><span class="n">MIN</span><span class="p">,</span> <span class="n">MAX</span><span class="p">)</span>
            <span class="n">fitness</span> <span class="o">=</span> <span class="n">fitness_function</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">+=</span> <span class="p">[</span><span class="n">fitness</span><span class="p">]</span>

    <span class="k">print</span><span class="p">(</span><span class="s">"Found optimum after %d iterations at %d, %d"</span> <span class="o">%</span> <span class="p">(</span><span class="n">iterations</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">data</span>

</code></pre></div></div>

<h3 id="fitness-function-to-create-valid-hexadecimal-inputs">Fitness Function to Create Valid Hexadecimal Inputs</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">get_fitness_cgi</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="c1"># Reset any distance values from previous executions
</span>    <span class="k">global</span> <span class="n">distances_true</span><span class="p">,</span> <span class="n">distances_false</span>
    <span class="n">distances_true</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">distances_false</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># Run the function under test
</span>    <span class="k">try</span><span class="p">:</span>
        <span class="n">cgi_decode_instrumented</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">except</span> <span class="nb">BaseException</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="c1"># Sum up branch distances
</span>    <span class="n">fitness</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">for</span> <span class="n">branch</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">branch</span> <span class="ow">in</span> <span class="n">distances_true</span><span class="p">:</span>
            <span class="n">fitness</span> <span class="o">+=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">distances_true</span><span class="p">[</span><span class="n">branch</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fitness</span> <span class="o">+=</span> <span class="mf">1.0</span>

    <span class="k">for</span> <span class="n">branch</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">branch</span> <span class="ow">in</span> <span class="n">distances_false</span><span class="p">:</span>
            <span class="n">fitness</span> <span class="o">+=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">distances_false</span><span class="p">[</span><span class="n">branch</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fitness</span> <span class="o">+=</span> <span class="mf">1.0</span>

    <span class="k">return</span> <span class="n">fitness</span>


</code></pre></div></div>

<h3 id="具体应用到现实程序中">具体应用到现实程序中</h3>

<p>假设我们现在有一个这样的程序</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">def</span> <span class="nf">cgi_decode</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="s">"""Decode the CGI-encoded string `s`:
       * replace "+" by " "
       * replace "%xx" by the character with hex number xx.
       Return the decoded string.  Raise `ValueError` for invalid inputs."""</span>

    <span class="c1"># Mapping of hex digits to their integer values
</span>    <span class="n">hex_values</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s">'0'</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s">'1'</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s">'2'</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s">'3'</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s">'4'</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
        <span class="s">'5'</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="s">'6'</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span> <span class="s">'7'</span><span class="p">:</span> <span class="mi">7</span><span class="p">,</span> <span class="s">'8'</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span> <span class="s">'9'</span><span class="p">:</span> <span class="mi">9</span><span class="p">,</span>
        <span class="s">'a'</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="s">'b'</span><span class="p">:</span> <span class="mi">11</span><span class="p">,</span> <span class="s">'c'</span><span class="p">:</span> <span class="mi">12</span><span class="p">,</span> <span class="s">'d'</span><span class="p">:</span> <span class="mi">13</span><span class="p">,</span> <span class="s">'e'</span><span class="p">:</span> <span class="mi">14</span><span class="p">,</span> <span class="s">'f'</span><span class="p">:</span> <span class="mi">15</span><span class="p">,</span>
        <span class="s">'A'</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="s">'B'</span><span class="p">:</span> <span class="mi">11</span><span class="p">,</span> <span class="s">'C'</span><span class="p">:</span> <span class="mi">12</span><span class="p">,</span> <span class="s">'D'</span><span class="p">:</span> <span class="mi">13</span><span class="p">,</span> <span class="s">'E'</span><span class="p">:</span> <span class="mi">14</span><span class="p">,</span> <span class="s">'F'</span><span class="p">:</span> <span class="mi">15</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="n">t</span> <span class="o">=</span> <span class="s">""</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="s">'+'</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">+=</span> <span class="s">' '</span>
        <span class="k">elif</span> <span class="n">c</span> <span class="o">==</span> <span class="s">'%'</span><span class="p">:</span>
            <span class="n">digit_high</span><span class="p">,</span> <span class="n">digit_low</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span>
            <span class="k">if</span> <span class="n">digit_high</span> <span class="ow">in</span> <span class="n">hex_values</span> <span class="ow">and</span> <span class="n">digit_low</span> <span class="ow">in</span> <span class="n">hex_values</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">hex_values</span><span class="p">[</span><span class="n">digit_high</span><span class="p">]</span> <span class="o">*</span> <span class="mi">16</span> <span class="o">+</span> <span class="n">hex_values</span><span class="p">[</span><span class="n">digit_low</span><span class="p">]</span>
                <span class="n">t</span> <span class="o">+=</span> <span class="nb">chr</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="nb">ValueError</span><span class="p">(</span><span class="s">"Invalid encoding"</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">+=</span> <span class="n">c</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">t</span>  
</code></pre></div></div>

<p>我们现在建模定义它的临点和评估每个点好坏的函数：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">def</span> <span class="nf">neighbor_strings</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="n">c</span> <span class="o">=</span> <span class="nb">ord</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="mi">126</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">+=</span> <span class="p">[</span><span class="n">x</span><span class="p">[:</span><span class="n">pos</span><span class="p">]</span> <span class="o">+</span> <span class="nb">chr</span><span class="p">(</span><span class="n">c</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]]</span>
        <span class="k">if</span> <span class="n">c</span> <span class="o">&gt;</span> <span class="mi">32</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">+=</span> <span class="p">[</span><span class="n">x</span><span class="p">[:</span><span class="n">pos</span><span class="p">]</span> <span class="o">+</span> <span class="nb">chr</span><span class="p">(</span><span class="n">c</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]]</span>
    <span class="k">return</span> <span class="n">n</span>

<span class="k">def</span> <span class="nf">distance_character</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>

  <span class="c1"># Initialize with very large value so that any comparison is better
</span>  <span class="n">minimum</span> <span class="o">=</span> <span class="n">sys</span><span class="p">.</span><span class="n">maxsize</span>

  <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
      <span class="n">distance</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">target</span> <span class="o">-</span> <span class="n">elem</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">distance</span> <span class="o">&lt;</span> <span class="n">minimum</span><span class="p">:</span>
          <span class="n">minimum</span> <span class="o">=</span> <span class="n">distance</span>
  <span class="k">return</span> <span class="n">minimum</span>
</code></pre></div></div>

<p>到目前为止，我们假设我们总是希望条件评估为true，实际情况我们也可能希望我们的条件评估为false。因此，每个if条件实际上都有两个距离估计，一个用于估计它离真有多近，一个是估计它离假有多近。如果条件为真，则true distance 为0；如果条件为假，则false distance为0。</p>

<p>更一般地说，可以有其他类型的比较，例如使用关系运算符。考虑cgi_decode（）中的循环条件：i&lt;len（s），即它使用小于比较运算符。将我们的分支距离概念扩展到涵盖不同类型的比较，并计算真距离和假距离，这是非常简单的。下表显示了如何计算不同类型比较的距离：</p>

<table>
  <thead>
    <tr>
      <th>Condition</th>
      <th>Distance True</th>
      <th>Distance False</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>a == b</td>
      <td>abs(a - b)</td>
      <td>1</td>
    </tr>
    <tr>
      <td>a != b</td>
      <td>1</td>
      <td>abs(a - b)</td>
    </tr>
    <tr>
      <td>a &lt; b</td>
      <td>b - a + 1</td>
      <td>a - b</td>
    </tr>
    <tr>
      <td>a &lt;= b</td>
      <td>b - a</td>
      <td>a - b + 1</td>
    </tr>
    <tr>
      <td>a &gt; b</td>
      <td>a - b + 1</td>
      <td>b - a</td>
    </tr>
  </tbody>
</table>

<p>请注意，其中一些计算添加了一个常数1。原因很简单：假设我们想让a&lt;b求值为真，让a=27和b=27。条件不成立，但简单地取差值会得到0的结果。为了避免这种情况，我们必须添加一个常量值。这个值是否为1并不重要——任何正常数都有效。</p>

<p>在cgi_decode（）函数中，我们还可以找到一个更复杂的谓词，它由两个条件组成，由逻辑和连接：</p>

<p><code class="language-plaintext highlighter-rouge">if digit_high in hex_values and digit_low in hex_values:</code></p>

<p>原则上，分支距离的定义是，使连接A和B为真的距离等于A和B的分支距离之和，因为这两个条件都需要为真。同样，使A或B为真的分支距离将是A和B的两个分支距离中的最小值，因为如果这两个条件之一为真，则足以使整个表达式为真。</p>

<p>但是，这在实践中并不像那么容易：谓词可以由嵌套条件和否定组成，在能够应用此计算之前，需要将表达式转换为规范形式。此外，大多数现代编程语言都使用短路求值：如果存在条件A或B，并且A为真，则B永远不会被求值。如果B是一个有函数调用的表达式，那么通过计算B的分支距离，即使短路评估会避免其执行，我们也可能会改变程序行为（通过调用在正常行为中不会执行的调用函数），这就有问题了。</p>

<p>使用全局变量和临时变量的另一种方法是用对辅助函数的调用替换实际比较，其中原始表达式被视为参数，运算符是一个额外的参数。假设我们有一个函数evaluate_condition（），它有四个参数：
num是标识条件的唯一id；
op是比较的运算符；
lhs和rhs是操作数。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">evaluate_condition</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
    <span class="n">distance_true</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">distance_false</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="s">"Eq"</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">lhs</span> <span class="o">==</span> <span class="n">rhs</span><span class="p">:</span>
            <span class="n">distance_false</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">distance_true</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">lhs</span> <span class="o">-</span> <span class="n">rhs</span><span class="p">)</span>

    <span class="c1"># ... code for other types of conditions
</span>
    <span class="k">if</span> <span class="n">distance_true</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>


</code></pre></div></div>

<p>evaluate_condition（）函数还没有存储观测到的距离。显然，我们需要将值存储在某个地方，以便我们可以从健身函数访问它。由于cgi_decode（）程序由几个条件组成，对于每个条件，我们可能对真距离和假距离感兴趣，因此我们只需使用两个全局字典distances_true和distances_false，并定义一个辅助函数来存储字典中观察到的距离值：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">update_maps</span><span class="p">(</span><span class="n">condition_num</span><span class="p">,</span> <span class="n">d_true</span><span class="p">,</span> <span class="n">d_false</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">distances_true</span><span class="p">,</span> <span class="n">distances_false</span>

    <span class="k">if</span> <span class="n">condition_num</span> <span class="ow">in</span> <span class="n">distances_true</span><span class="p">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">distances_true</span><span class="p">[</span><span class="n">condition_num</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
            <span class="n">distances_true</span><span class="p">[</span><span class="n">condition_num</span><span class="p">],</span> <span class="n">d_true</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">distances_true</span><span class="p">[</span><span class="n">condition_num</span><span class="p">]</span> <span class="o">=</span> <span class="n">d_true</span>

    <span class="k">if</span> <span class="n">condition_num</span> <span class="ow">in</span> <span class="n">distances_false</span><span class="p">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">distances_false</span><span class="p">[</span><span class="n">condition_num</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
            <span class="n">distances_false</span><span class="p">[</span><span class="n">condition_num</span><span class="p">],</span> <span class="n">d_false</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">distances_false</span><span class="p">[</span><span class="n">condition_num</span><span class="p">]</span> <span class="o">=</span> <span class="n">d_false</span>

</code></pre></div></div>

<p>但是如果条件复杂了如何，在Python中，使用程序的抽象语法树（AST）自动替换比较实际上非常容易。在AST中，比较通常是一个具有运算符属性的树节点，以及左侧和右侧运算符的两个子节点。要用evaluate_condition（）调用替换这样的比较，只需将AST中的比较节点替换为函数调用节点，BranchTransformer类就是这样使用Python AST模块中的NodeTransformer的：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kn">import</span> <span class="nn">ast</span>
  <span class="k">class</span> <span class="nc">BranchTransformer</span><span class="p">(</span><span class="n">ast</span><span class="p">.</span><span class="n">NodeTransformer</span><span class="p">):</span>

    <span class="n">branch_num</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">visit_FunctionDef</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="n">node</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">name</span> <span class="o">+</span> <span class="s">"_instrumented"</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">generic_visit</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_Compare</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">ops</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="n">ast</span><span class="p">.</span><span class="n">Is</span><span class="p">,</span> <span class="n">ast</span><span class="p">.</span><span class="n">IsNot</span><span class="p">,</span> <span class="n">ast</span><span class="p">.</span><span class="n">In</span><span class="p">,</span> <span class="n">ast</span><span class="p">.</span><span class="n">NotIn</span><span class="p">]:</span>
            <span class="k">return</span> <span class="n">node</span>

        <span class="bp">self</span><span class="p">.</span><span class="n">branch_num</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">ast</span><span class="p">.</span><span class="n">Call</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="n">ast</span><span class="p">.</span><span class="n">Name</span><span class="p">(</span><span class="s">"evaluate_condition"</span><span class="p">,</span> <span class="n">ast</span><span class="p">.</span><span class="n">Load</span><span class="p">()),</span>
                        <span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="n">ast</span><span class="p">.</span><span class="n">Num</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">branch_num</span><span class="p">),</span>
                              <span class="n">ast</span><span class="p">.</span><span class="n">Str</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">ops</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">__class__</span><span class="p">.</span><span class="n">__name__</span><span class="p">),</span>
                              <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">,</span>
                              <span class="n">node</span><span class="p">.</span><span class="n">comparators</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                        <span class="n">keywords</span><span class="o">=</span><span class="p">[],</span>
                        <span class="n">starargs</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                        <span class="n">kwargs</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>


<span class="n">source</span> <span class="o">=</span> <span class="n">inspect</span><span class="p">.</span><span class="n">getsource</span><span class="p">(</span><span class="n">cgi_decode</span><span class="p">)</span>
<span class="n">node</span> <span class="o">=</span> <span class="n">ast</span><span class="p">.</span><span class="n">parse</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
<span class="n">BranchTransformer</span><span class="p">().</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

<span class="c1"># Make sure the line numbers are ok before printing
</span><span class="n">node</span> <span class="o">=</span> <span class="n">ast</span><span class="p">.</span><span class="n">fix_missing_locations</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
<span class="n">print_content</span><span class="p">(</span><span class="n">ast</span><span class="p">.</span><span class="n">unparse</span><span class="p">(</span><span class="n">node</span><span class="p">),</span> <span class="s">'.py'</span><span class="p">)</span>


</code></pre></div></div>

<h3 id="evolutionary-search">Evolutionary Search</h3>

<p>如果搜索空间很小，hillclimbing自然挺好，但是如果是UNICODE呢，所以我们可以在hillclimb之前做点更改提高效率，比如让它迭代100次，而不是全部迭代完。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">terminal_repr</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">terminal_escape</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">hillclimb_cgi_limited</span><span class="p">(</span><span class="n">max_iterations</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">random_unicode_string</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">fitness</span> <span class="o">=</span> <span class="n">get_fitness_cgi</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"Initial input: %s at fitness %.4f"</span> <span class="o">%</span> <span class="p">(</span><span class="n">terminal_repr</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">fitness</span><span class="p">))</span>

    <span class="n">iteration</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">logs</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">fitness</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">iteration</span> <span class="o">&lt;</span> <span class="n">max_iterations</span><span class="p">:</span>
        <span class="n">changed</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">nextx</span><span class="p">)</span> <span class="ow">in</span> <span class="n">unicode_string_neighbors</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="n">new_fitness</span> <span class="o">=</span> <span class="n">get_fitness_cgi</span><span class="p">(</span><span class="n">nextx</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">new_fitness</span> <span class="o">&lt;</span> <span class="n">fitness</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">nextx</span>
                <span class="n">fitness</span> <span class="o">=</span> <span class="n">new_fitness</span>
                <span class="n">changed</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">if</span> <span class="n">logs</span> <span class="o">&lt;</span> <span class="n">LOG_VALUES</span><span class="p">:</span>
                    <span class="k">print</span><span class="p">(</span><span class="s">"New value: %s at fitness %.4f"</span> <span class="o">%</span>
                          <span class="p">(</span><span class="n">terminal_repr</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">fitness</span><span class="p">))</span>
                <span class="k">elif</span> <span class="n">logs</span> <span class="o">==</span> <span class="n">LOG_VALUES</span><span class="p">:</span>
                    <span class="k">print</span><span class="p">(</span><span class="s">"..."</span><span class="p">)</span>
                <span class="n">logs</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">break</span>

        <span class="c1"># Random restart if necessary
</span>        <span class="k">if</span> <span class="ow">not</span> <span class="n">changed</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">random_string</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
            <span class="n">fitness</span> <span class="o">=</span> <span class="n">get_fitness_cgi</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">iteration</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">print</span><span class="p">(</span><span class="s">"Optimum at %s, fitness %.4f"</span> <span class="o">%</span> <span class="p">(</span><span class="n">terminal_repr</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">fitness</span><span class="p">))</span>

</code></pre></div></div>

<h2 id="global-search">Global Search</h2>

<p>hillclimb算法在搜索的每一步都会探索一个点的neibor，如果搜索空间太大，那么这需要太长时间。另一种策略是不将搜索限制在局部邻域，而是全局搜索搜索空间。也就是说，允许搜索算法在搜索空间周围进行更大的步骤。hillclimb的一个简单修改将其从局部搜索算法转换为全局搜索算法：不是查看所有近邻，而是以允许更大修改的方式对个体进行突变。</p>

<p>突变是指在搜索空间中迈出更大一步的变化。实现突变时的一个重要决定是，理论上，只需连续应用突变，就可以到达搜索空间中的任何点。然而，突变通常不应该用随机的个体完全取代个体。为了使搜索有效，重要的是突变对仍然保持其大部分特征的个体构成合理的改变。对于我们的10个字符串的搜索问题，一个可能的突变是只替换10个字符中的1个，如下所示：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">randomized_hillclimb</span><span class="p">():</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">random_unicode_string</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">fitness</span> <span class="o">=</span> <span class="n">get_fitness_cgi</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"Initial value: %s at fitness %.4f"</span> <span class="o">%</span>
          <span class="p">(</span><span class="n">terminal_repr</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">fitness</span><span class="p">))</span>

    <span class="n">iterations</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">fitness</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">mutated</span> <span class="o">=</span> <span class="n">flip_random_character</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">new_fitness</span> <span class="o">=</span> <span class="n">get_fitness_cgi</span><span class="p">(</span><span class="n">mutated</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">new_fitness</span> <span class="o">&lt;=</span> <span class="n">fitness</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">mutated</span>
            <span class="n">fitness</span> <span class="o">=</span> <span class="n">new_fitness</span>
            <span class="c1">#print("New value: %s at fitness %.4f" %(terminal_repr(x), fitness))
</span>        <span class="n">iterations</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">print</span><span class="p">(</span><span class="s">"Optimum at %s after %d iterations"</span> <span class="o">%</span>
          <span class="p">(</span><span class="n">terminal_repr</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">iterations</span><span class="p">))</span>

</code></pre></div></div>

<h3 id="genetic-algorithms">Genetic Algorithms</h3>

<p>最著名的突变算法之一是遗传算法（GA）。遗传算法基于这样一种理念，即问题解决方案可以通过基因编码：染色体由一系列基因组成，其中每个基因编码一个个体的一个特征（例如眼睛颜色、头发颜色等）。适应度函数可以获取此描述中包含的信息，即所谓的基因型，并评估由此产生的表型的特性，即这种遗传编码所代表的实际解决方案。个体的适应度值是根据表型来衡量的。</p>

<p>在搜索中使用适应度值通常用“适者生存”来解释，但达尔文对进化的一个关键见解是，选择不仅由生存来定义——个体有性繁殖，选择描述了繁殖过程中的选择压力。这种选择通常受到两种战斗的影响：与雄性竞争的雌性会赢得胜利，而更强壮（更健康）的雄性会获胜；选择也受到显示的影响。达尔文的例子是孔雀：孔雀有长而美丽的尾羽，似乎没有任何作用，似乎也不支持自然选择的概念。然而，雌孔雀在选择性伴侣时会受到其外貌的影响。令人印象深刻的装饰表明，雄性在基因上特别健康，会产生健康的后代。这反映在遗传算法中：个体的健康值越高，与另一个个体交配的可能性就越大。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">selection</span><span class="p">(</span><span class="n">evaluated_population</span><span class="p">,</span> <span class="n">tournament_size</span><span class="p">):</span>
    <span class="n">competition</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="n">sample</span><span class="p">(</span><span class="n">evaluated_population</span><span class="p">,</span> <span class="n">tournament_size</span><span class="p">)</span>
    <span class="n">winner</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">competition</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">individual</span><span class="p">:</span> <span class="n">individual</span><span class="p">[</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Return a copy of the selected individual
</span>    <span class="k">return</span> <span class="n">winner</span><span class="p">[:]</span>


</code></pre></div></div>

<p>tournament_size参数指定从人群中随机选择的个人参与比较的数量。这是一个重要的选择，因为它决定了选择压力：比较规模越大，非常优秀的个人被纳入比赛的可能性就越大。这反过来又增加了这些非常优秀的个体支配下一代的可能性，从而降低了多样性并导致过早收敛。相比之下，如果比较规模太小，那么这会抑制进化。比较规模的最佳值取决于参加人数，但通常相当小（例如5个）。</p>

<p>就像在自然进化中一样，根据健康状况选择的个体会繁殖，形成新一代。在这种繁殖过程中，就像自然繁殖一样，被选中的父母的遗传物质被结合在一起。这通常是通过一种称为交叉的过程完成的，在这种过程中，后代染色体是由其父母的基因产生的。在我们的例子中，染色体是一个字符序列，通过选择一个截止随机点，并根据截止点组合父母染色体的一半来创建后代，就可以简单地跨越两个亲本字符序列。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">def</span> <span class="nf">crossover</span><span class="p">(</span><span class="n">parent1</span><span class="p">,</span> <span class="n">parent2</span><span class="p">):</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">parent1</span><span class="p">))</span>

    <span class="n">offspring1</span> <span class="o">=</span> <span class="n">parent1</span><span class="p">[:</span><span class="n">pos</span><span class="p">]</span> <span class="o">+</span> <span class="n">parent2</span><span class="p">[</span><span class="n">pos</span><span class="p">:]</span>
    <span class="n">offspring2</span> <span class="o">=</span> <span class="n">parent2</span><span class="p">[:</span><span class="n">pos</span><span class="p">]</span> <span class="o">+</span> <span class="n">parent1</span><span class="p">[</span><span class="n">pos</span><span class="p">:]</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">offspring1</span><span class="p">,</span> <span class="n">offspring2</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">mutate</span><span class="p">(</span><span class="n">chromosome</span><span class="p">):</span>
  <span class="n">mutated</span> <span class="o">=</span> <span class="n">chromosome</span><span class="p">[:]</span>
  <span class="n">P</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">mutated</span><span class="p">)</span>

  <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mutated</span><span class="p">)):</span>
      <span class="k">if</span> <span class="n">random</span><span class="p">.</span><span class="n">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">P</span><span class="p">:</span>
          <span class="n">new_c</span> <span class="o">=</span> <span class="nb">chr</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">random</span><span class="p">.</span><span class="n">gauss</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="n">mutated</span><span class="p">[</span><span class="n">pos</span><span class="p">]),</span> <span class="mi">100</span><span class="p">)</span> <span class="o">%</span> <span class="mi">65536</span><span class="p">))</span>
          <span class="n">mutated</span> <span class="o">=</span> <span class="n">mutated</span><span class="p">[:</span><span class="n">pos</span><span class="p">]</span> <span class="o">+</span> <span class="n">new_c</span> <span class="o">+</span> <span class="n">mutated</span><span class="p">[</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span>
  <span class="k">return</span> <span class="n">mutated</span>

<span class="k">def</span> <span class="nf">genetic_algorithm</span><span class="p">():</span>
  <span class="c1"># Generate and evaluate initial population
</span>  <span class="n">generation</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="n">population</span> <span class="o">=</span> <span class="n">create_population</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
  <span class="n">fitness</span> <span class="o">=</span> <span class="n">evaluate_population</span><span class="p">(</span><span class="n">population</span><span class="p">)</span>
  <span class="n">best</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">fitness</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">item</span><span class="p">:</span> <span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
  <span class="n">best_individual</span> <span class="o">=</span> <span class="n">best</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="n">best_fitness</span> <span class="o">=</span> <span class="n">best</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
  <span class="k">print</span><span class="p">(</span><span class="s">"Best fitness of initial population: %s - %.10f"</span> <span class="o">%</span>
      <span class="p">(</span><span class="n">terminal_repr</span><span class="p">(</span><span class="n">best_individual</span><span class="p">),</span> <span class="n">best_fitness</span><span class="p">))</span>
  <span class="n">logs</span> <span class="o">=</span> <span class="mi">0</span>

  <span class="c1"># Stop when optimum found, or we run out of patience
</span>  <span class="k">while</span> <span class="n">best_fitness</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">generation</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">:</span>

      <span class="c1"># The next generation will have the same size as the current one
</span>      <span class="n">new_population</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_population</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">population</span><span class="p">):</span>
          <span class="c1"># Selection
</span>          <span class="n">offspring1</span> <span class="o">=</span> <span class="n">selection</span><span class="p">(</span><span class="n">fitness</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
          <span class="n">offspring2</span> <span class="o">=</span> <span class="n">selection</span><span class="p">(</span><span class="n">fitness</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>

          <span class="c1"># Crossover
</span>          <span class="k">if</span> <span class="n">random</span><span class="p">.</span><span class="n">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.7</span><span class="p">:</span>
              <span class="p">(</span><span class="n">offspring1</span><span class="p">,</span> <span class="n">offspring2</span><span class="p">)</span> <span class="o">=</span> <span class="n">crossover</span><span class="p">(</span><span class="n">offspring1</span><span class="p">,</span> <span class="n">offspring2</span><span class="p">)</span>

          <span class="c1"># Mutation
</span>          <span class="n">offspring1</span> <span class="o">=</span> <span class="n">mutate</span><span class="p">(</span><span class="n">offspring1</span><span class="p">)</span>
          <span class="n">offspring2</span> <span class="o">=</span> <span class="n">mutate</span><span class="p">(</span><span class="n">offspring2</span><span class="p">)</span>

          <span class="n">new_population</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">offspring1</span><span class="p">)</span>
          <span class="n">new_population</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">offspring2</span><span class="p">)</span>

      <span class="c1"># Once full, the new population replaces the old one
</span>      <span class="n">generation</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="n">population</span> <span class="o">=</span> <span class="n">new_population</span>
      <span class="n">fitness</span> <span class="o">=</span> <span class="n">evaluate_population</span><span class="p">(</span><span class="n">population</span><span class="p">)</span>

      <span class="n">best</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">fitness</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">item</span><span class="p">:</span> <span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
      <span class="n">best_individual</span> <span class="o">=</span> <span class="n">best</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
      <span class="n">best_fitness</span> <span class="o">=</span> <span class="n">best</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
      <span class="k">if</span> <span class="n">logs</span> <span class="o">&lt;</span> <span class="n">LOG_VALUES</span><span class="p">:</span>
          <span class="k">print</span><span class="p">(</span>
              <span class="s">"Best fitness at generation %d: %s - %.8f"</span> <span class="o">%</span>
              <span class="p">(</span><span class="n">generation</span><span class="p">,</span> <span class="n">terminal_repr</span><span class="p">(</span><span class="n">best_individual</span><span class="p">),</span> <span class="n">best_fitness</span><span class="p">))</span>
      <span class="k">elif</span> <span class="n">logs</span> <span class="o">==</span> <span class="n">LOG_VALUES</span><span class="p">:</span>
          <span class="k">print</span><span class="p">(</span><span class="s">"..."</span><span class="p">)</span>
      <span class="n">logs</span> <span class="o">+=</span> <span class="mi">1</span>

  <span class="k">print</span><span class="p">(</span>
      <span class="s">"Best individual: %s, fitness %.10f"</span> <span class="o">%</span>
      <span class="p">(</span><span class="n">terminal_repr</span><span class="p">(</span><span class="n">best_individual</span><span class="p">),</span> <span class="n">best_fitness</span><span class="p">))</span>



</code></pre></div></div>

<h2 id="fuzzing-with-grammars">Fuzzing with Grammars</h2>

<p>本章介绍语法作为一种简单的方法来指定输入语言，并将其用于测试具有语法有效输入的程序。语法被定义为非终结符到替代扩展列表的映射，如下例所示：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">US_PHONE_GRAMMAR</span><span class="p">:</span> <span class="n">Grammar</span> <span class="o">=</span> <span class="p">{</span>
<span class="o">&gt;&gt;&gt;</span>     <span class="s">"&lt;start&gt;"</span><span class="p">:</span> <span class="p">[</span><span class="s">"&lt;phone-number&gt;"</span><span class="p">],</span>
<span class="o">&gt;&gt;&gt;</span>     <span class="s">"&lt;phone-number&gt;"</span><span class="p">:</span> <span class="p">[</span><span class="s">"(&lt;area&gt;)&lt;exchange&gt;-&lt;line&gt;"</span><span class="p">],</span>
<span class="o">&gt;&gt;&gt;</span>     <span class="s">"&lt;area&gt;"</span><span class="p">:</span> <span class="p">[</span><span class="s">"&lt;lead-digit&gt;&lt;digit&gt;&lt;digit&gt;"</span><span class="p">],</span>
<span class="o">&gt;&gt;&gt;</span>     <span class="s">"&lt;exchange&gt;"</span><span class="p">:</span> <span class="p">[</span><span class="s">"&lt;lead-digit&gt;&lt;digit&gt;&lt;digit&gt;"</span><span class="p">],</span>
<span class="o">&gt;&gt;&gt;</span>     <span class="s">"&lt;line&gt;"</span><span class="p">:</span> <span class="p">[</span><span class="s">"&lt;digit&gt;&lt;digit&gt;&lt;digit&gt;&lt;digit&gt;"</span><span class="p">],</span>
<span class="o">&gt;&gt;&gt;</span>     <span class="s">"&lt;lead-digit&gt;"</span><span class="p">:</span> <span class="p">[</span><span class="s">"2"</span><span class="p">,</span> <span class="s">"3"</span><span class="p">,</span> <span class="s">"4"</span><span class="p">,</span> <span class="s">"5"</span><span class="p">,</span> <span class="s">"6"</span><span class="p">,</span> <span class="s">"7"</span><span class="p">,</span> <span class="s">"8"</span><span class="p">,</span> <span class="s">"9"</span><span class="p">],</span>
<span class="o">&gt;&gt;&gt;</span>     <span class="s">"&lt;digit&gt;"</span><span class="p">:</span> <span class="p">[</span><span class="s">"0"</span><span class="p">,</span> <span class="s">"1"</span><span class="p">,</span> <span class="s">"2"</span><span class="p">,</span> <span class="s">"3"</span><span class="p">,</span> <span class="s">"4"</span><span class="p">,</span> <span class="s">"5"</span><span class="p">,</span> <span class="s">"6"</span><span class="p">,</span> <span class="s">"7"</span><span class="p">,</span> <span class="s">"8"</span><span class="p">,</span> <span class="s">"9"</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">}</span>
<span class="o">&gt;&gt;&gt;</span> 
<span class="o">&gt;&gt;&gt;</span> <span class="k">assert</span> <span class="n">is_valid_grammar</span><span class="p">(</span><span class="n">US_PHONE_GRAMMAR</span><span class="p">)</span>

</code></pre></div></div>

<p>非终端符号用尖括号括起来（比如<digital>）。为了从语法生成输入字符串，生产者从开始符号（<start>）开始，并随机选择该符号的随机展开。它会继续这个过程，直到所有非终结符都展开</start></digital></p>

<p>语法作为人类语言的基础之一，自人类语言存在以来就一直存在。生成语法的第一次形式化是由Dakṣiputra Pā̇ini在公元前350年提出的。作为表达数据和程序形式语言的一般手段，它们在计算机科学中的作用怎么强调都不为过。乔姆斯基的开创性工作介绍了规则语言、上下文无关语法、上下文敏感语法和通用语法的中心模型，因为它们在计算机科学中被使用（和教授）作为指定输入和编程语言的手段。</p>

<p>使用语法生成测试输入可以追溯到Burkhardt{Burkhardt1967}，后来被Hanford{Hanford1970}和Purdom{Purdom1972}重新发现和应用。从那时起，语法测试最重要的用途就是编译器测试。实际上，基于语法的测试是编译器和Web浏览器正常工作的一个重要原因：</p>

<p><a href="https://embed.cs.utah.edu/csmith/">CSmith</a>工具{Yang2011}专门针对C程序，从C语法开始，然后应用其他步骤，例如引用之前定义的变量和函数或确保整数和类型安全。他们的作者使用它“发现并报告了400多个以前未知的编译器错误”</p>

<p><a href="http://issta2016.cispa.saarland/interview-with-christian-holler/">LangFuzz</a>的著作《Holler2012》与本书共有两位作者，该著作使用通用语法生成输出，并日夜用于生成JavaScript程序和测试其解释器；截至今天，它在Mozilla Firefox、Google Chrome和Microsoft Edge等浏览器中发现了2600多个错误。</p>

<p><a href="https://web.cs.ucdavis.edu/~su/emi-project/">EMI</a>项目{Le2014}使用语法对C编译器进行压力测试，将已知的测试转换为在所有输入上语义等效的替代程序。这再次导致C编译器中的100多个错误得到修复。</p>

<p><a href="https://github.com/renatahodovan/grammarinator">Grammarinator</a> \cite{Hodovan2018}是一个开源语法模糊器（用Python编写！），使用流行的ANTLR格式作为语法规范。与LangFuzz一样，它使用语法进行解析和生成，并在JerryScript轻量级JavaScript引擎和相关平台中发现了100多个问题。</p>

<p><a href="https://github.com/googleprojectzero/domato">Domato</a>是一个通用的语法生成引擎，专门用于模糊DOM输入。它揭示了流行网络浏览器中的许多安全问题。</p>]]></content><author><name>樵夫砍柴手札</name><email>p1ain0@outlook.com</email></author><category term="PWN,linux" /><category term="PWN,linux" /><summary type="html"><![CDATA[最近学习的fuzz技术，简单做下笔记。]]></summary></entry><entry><title type="html">afl源码分析</title><link href="http://localhost:4000/afl-study/" rel="alternate" type="text/html" title="afl源码分析" /><published>2025-03-20T00:00:00+08:00</published><updated>2025-03-20T00:00:00+08:00</updated><id>http://localhost:4000/afl-study</id><content type="html" xml:base="http://localhost:4000/afl-study/"><![CDATA[<p>最近在阅读alf的源代码时做的一些笔记，有点乱不往论坛发了，自己回顾的时候看看的，有很多都引用的sakura师傅的分析笔记。</p>

<h2 id="afl的设计">afl的设计</h2>

<p>afl被设计用来对开源的代码进行模糊测试，通过编译和运行时两方面的机制配合一起工作。编译时插桩，插桩代码用于捕获每个代码块的执行情况，给每个block随机分配一个编号，通过当前运行的代码块编号和上一个代码块编号即可获取执行的路径信息，这就是我们要记录的信息。在运行时，afl-fuzz会分配一大块共享内存跟目标程序通信，插桩代码会计算边信息，并在共享内存中标记该边，从而可以让afl-fuzz感知到本次运行情况。afl-fuzz根据这些路径执行信息，再选择测试用例的变异方式。</p>

<h2 id="afl-gcc">afl-gcc</h2>

<p>我们通过环境变量设置可以将C/C++的编译器替换为afl-gcc 它的作用就是根据我们的环境参数配置给编译添加一些编译选项，并调用真正的编译器执行编译工作。</p>

<h3 id="find_as">find_as:</h3>

<p>寻找afl的路径。会先检查有没有设置AFL_PATH的环境变量，如果设置了，会先在这个路径中寻找as，如果没有会在afl-gcc同级目录中找。</p>

<h3 id="edit_params">edit_params:</h3>

<p>检查有没有通过AFL_CC之类的环境变量指定编译器，如果没设置就用默认的。然后后边就是检查传进来参数，特殊处理一些特别的参数：</p>

<p>-B：指定编译工具的路径（如 as、ld、ar 等），替换成新的as的路径；</p>

<p>-integrated-as -pipe 忽略掉；-fsanitize=address -fsanitize=memory：开启asan；</p>

<p>检查宏FORTIFY_SOURCE有没有被定义：开启fortify检查。</p>

<p>注意：后边两种安全编译选项也可以通过环境变量设置AFL_USE_ASAN AFL_USE_MSAN AFL_HARDEN这三个互斥，不能同时设置。</p>

<p>AFL_DONT_OPTIMIZE如果不设置，会自动开启-O3，-funroll-loops（-funroll-loops 是 -O3 优化级别的一部分，用于最大化性能优化）优化，并且添加-D__AFL_COMPILER=1</p>

<p>-DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=1这两个宏定义。第一个是AFL特有的宏，第二个libfuzzer也有。</p>

<p>AFL_NO_BUILTIN如果设置了，添加一些no-builtin的选项。</p>

<h2 id="afl-as">afl-as</h2>

<p><a href="https://afl-1.readthedocs.io/en/latest/about_afl.html">afl</a></p>

<p>由于在afl-gcc阶段通过-B指定了as的路径为afl-as，编译器就会先用我们指定的这个afl-as。</p>

<p>这个是编译阶段的关键，当源码别编译成汇编后，就会使用as工具将汇编转成机器码，这个阶段我们就可以通过修改汇编的方式将代码插桩，然后调用真正的as，再去执行汇编的操作。</p>

<p>AFL_INST_RATIO</p>

<h3 id="插桩的具体实现">插桩的具体实现</h3>

<p>关键函数：add_instrumentation</p>

<p>循环读取汇编文件（input_file），每次读取一行，检查代码的架构32位还是64位，后续会选择插入不同的代码。还得要分辨代码段和非代码段。如果汇编是intel语法格式的段也不能插入，只能插入AT&amp;T格式的。跳过 <code class="language-plaintext highlighter-rouge">__asm__</code> 这种内联汇编的形式。遇到jxx这种跳转的指令（jmp不处理）就认为后续为一个代码块的开始，如果有标签的也是一个block的开始，（jmp后边block的是不处理的原因是，它不会被执行。如果该block被执行说明有引用，那么一定会有一个标签在前边，那么在处理标签类型的时候处理，防止重复处理）。在每个block前添加桩代码的汇编指令。添加的汇编指令如下（以x64为例）：</p>

<pre><code class="language-C">
"\n"
"/* --- AFL TRAMPOLINE (64-BIT) --- */\n"
"\n"
".align 4\n"
"\n"
"leaq -(128+24)(%%rsp), %%rsp\n"
"movq %%rdx,  0(%%rsp)\n"
"movq %%rcx,  8(%%rsp)\n"
"movq %%rax, 16(%%rsp)\n" //保存寄存器信息
"movq $0x%08x, %%rcx\n"   //这个是块的编号，在afl-as中添加的时候，通过R(MAP_SIZE)随机生成的 #define R(x) (random() % (x))  #define MAP_SIZE            (1 &lt;&lt; MAP_SIZE_POW2) #define MAP_SIZE_POW2       16
"call __afl_maybe_log\n"   //把通过rcx传递的块编号记录下来。
"movq 16(%%rsp), %%rax\n"  //恢复寄存器信息
"movq  8(%%rsp), %%rcx\n"
"movq  0(%%rsp), %%rdx\n"
"leaq (128+24)(%%rsp), %%rsp\n"
"\n"
"/* --- END --- */\n"
"\n";

</code></pre>

<p>__afl_maybe_log代码会先检查 <code class="language-plaintext highlighter-rouge">__afl_area_ptr</code> 变量有没有初始化,如果没有的话，说明还未初始化会先去执行 <code class="language-plaintext highlighter-rouge">__afl_setup</code> 初始化，
<code class="language-plaintext highlighter-rouge">__afl_setup</code> 这个初始化过程就是通过环境变量SHM_ENV_VAR传递的值，去获取共享内存，并通过199管道通知afl-fuzz，然后通过fork的方式，创建子进程，子进程是真正的执行体，父进程会挂起等待子进程执行完。通过fork这种方式可以减少每次执行进程的启动加载时间。198，199管道是用来和afl-fuzz同步的。198管道是afl-fuzz通知forkserver去创建子进程的。子进程被fork出来后会先去执行 <code class="language-plaintext highlighter-rouge">__afl_fork_resume</code> 关闭198，199管道。并立即执行一次 =_afl_store=。</p>

<p>真正的执行体是不需要初始化的，因为已经从forkserver里继承了这些资源。只需要执行 <code class="language-plaintext highlighter-rouge">__afl_store</code> 即可， <code class="language-plaintext highlighter-rouge">__afl_store</code> 函数的功能如下</p>

<pre><code class="language-C">cur_location = &lt;COMPILE_TIME_RANDOM&gt;;
shared_mem[cur_location ^ prev_location]++;
prev_location = cur_location &gt;&gt; 1;
</code></pre>

<p>将当前块的编号和记录的上一个块的编号右移1位后的异或值做索引当做边的hash，记录在共享内存中。</p>

<p>有个问题，如果程序是多线程的会让记录edge的信息不准确。</p>

<h2 id="afl-fast-clang">afl-fast-clang</h2>

<p>因为AFL对于上述通过afl-gcc来插桩这种做法已经属于不建议，并提供了更好的工具afl-clang-fast，通过llvm pass来插桩。
afl-clang-fast.c这个文件其实是clang的一层wrapper，和之前的afl-gcc一样，只是定义了一些宏，和传递了一些参数给真正的clang。</p>

<h2 id="afl-fuzz">afl-fuzz</h2>

<h3 id="基本使用">基本使用：</h3>

<p>指定参数
-i 输入目录，目录中是测试用例
-o 输出目录
-m 指定内存最大限制
-t 超时时间
– 分割
后边是fuzz的程序
@@ 读文件，不加这个就是从标准输入来读</p>

<pre><code class="language-C">  -i dir        - input directory with test cases
  -o dir        - output directory for fuzzer findings

Execution control settings:

  -f file       - location read by the fuzzed program (stdin)
  -t msec       - timeout for each run (auto-scaled, 50-1000 ms)
  -m megs       - memory limit for child process (50 MB)
  -Q            - use binary-only instrumentation (QEMU mode)

Fuzzing behavior settings:

  -d            - quick &amp; dirty mode (skips deterministic steps)
  -n            - fuzz without instrumentation (dumb mode)
  -x dir        - optional fuzzer dictionary (see README)

Other stuff:

  -T text       - text banner to show on the screen
  -M / -S id    - distributed mode (see parallel_fuzzing.txt)
  -C            - crash exploration mode (the peruvian rabbit thing)
  -V            - show version number and exit

  -b cpu_id     - bind the fuzzing process to the specified CPU core

</code></pre>

<p>docs目录下有很多的文档可以看看。里边有关于界面显示的（status_screen.txt），界面上的各个字段都有详细的说明。</p>

<h2 id="源码分析">源码分析</h2>

<h3 id="初始化部分">初始化部分</h3>

<ol>
  <li>
    <p>参数解析</p>

    <p>首先就是参数解析，根据不同的参数设置不同的全局变量。这里只简单介绍下后续源码分析的时候会再和这几个参数联系起来：</p>

    <p><code class="language-plaintext highlighter-rouge">-M，-S</code> ：这两个都是跟并行有关，-M是指定这个任务为master <code class="language-plaintext highlighter-rouge">afl-fuzz -i testcase_dir -o sync_dir -M fuzzer01 [...other stuff...]</code> -S是指定这个任务为secondary <code class="language-plaintext highlighter-rouge">afl-fuzz -i testcase_dir -o sync_dir -S fuzzer02 [...other stuff...]</code></p>

    <p><code class="language-plaintext highlighter-rouge">-x</code> ：指定存放字典文件的目录  <code class="language-plaintext highlighter-rouge">t</code> ：超时检测 <code class="language-plaintext highlighter-rouge">-m</code> ：限制内存空间，格式为1T，1G，1K，1M这种。 <code class="language-plaintext highlighter-rouge">-b</code> ：绑定cpu， <code class="language-plaintext highlighter-rouge">-d</code> 跳过确定性变异， <code class="language-plaintext highlighter-rouge">-B</code> ：加载bitmap，如果您在正常模糊测试过程中发现一个有趣的测试用例，并且想要对其进行变异，而不重新发现在先前运行期间已经发现的任何测试用例，则此选项很有用。要使用此模式，您需要将 -B 指向先前运行为完全相同的二进制文件生成的 fuzz_bitmap。 <code class="language-plaintext highlighter-rouge">-C</code> ： 通过监控目标程序的执行状态自动识别崩溃 <code class="language-plaintext highlighter-rouge">-n</code> ：无插桩模式，这个就不会去探测覆盖率了。还跟一个AFL_DUMB_FORKSRV环境变量相关联  <code class="language-plaintext highlighter-rouge">-T</code> ：banner 允许用户为模糊测试会话设置一个自定义标题（Banner），用于在并行测试或多实例运行时区分不同会话。例如，在分布式测试中，不同实例可通过 Banner 快速识别归属  <code class="language-plaintext highlighter-rouge">-Q</code> ：联合QEMU做闭源的fuzz，</p>
  </li>
  <li>
    <p>检测环境变量</p>

    <p>ASAN_OPTIONS=”abort_on_error=1”<em>“symbolize=0”
MSAN_OPTIONS=”exit_code=MSAN_ERROR”</em>“symbolize=0”
AFL_NO_FORKSRV 禁用forkserver模式</p>

    <p>AFL_PRELOAD这个用来设置动态链接库的路径，启动程序的时候设置LD_PRELOAD用的</p>
  </li>
  <li>
    <p>保存命令行参数</p>

    <p>save_cmdline</p>
  </li>
  <li>
    <p>修复标题</p>

    <p>fix_up_banner</p>

    <p>设置use_banner</p>
  </li>
  <li>
    <p>检查是不是tty模式</p>

    <p>check_if_tty
检查AFL_NO_UI环境变量，设置了这个就设为notty模式，也会检查标准输出是否合法。</p>
  </li>
  <li>
    <p>get_core_count获取cpu个数</p>

    <p>可以看到UNIX不同平台的实现方式，把结果存在cpu_core_count变量中。</p>

    <p>如果开启了HAVE_AFFINITY宏的平台就会调用bind_to_free_cpu</p>
  </li>
  <li>
    <p>检查coredump有没有开启</p>

    <p>check_crash_handling</p>
  </li>
  <li>
    <p>检查cpu的调频信息（不重要）</p>

    <p>check_cpu_governor，检查cpu频率上下限，如果相同，会推出</p>

    <p>设置AFL_SKIP_CPUFREQ环境变量可以跳过检查</p>
  </li>
  <li>
    <p>setup_post</p>

    <p>检查环境变量有没有设置AFL_POST_LIBRARY，如果设置了就会加载动态链接库找afl_postprocess函数赋到post_handler函数指针变量上，相当于一种插件形式，自定义处理测试完成后对结果的分析与优化，包括崩溃样本处理、覆盖率统计和语料库优化。</p>
  </li>
  <li>
    <p>setup_shm</p>

    <p>设置共享内存，并设置SHM_ENV_VAR环境变量，用于与目标进程通信，接收测试结果。</p>
  </li>
  <li>
    <p>init_count_class16</p>

    <p><code class="language-plaintext highlighter-rouge">count_class_lookup8</code> <code class="language-plaintext highlighter-rouge">count_class_lookup16</code> ，这其实是因为trace_bits是用一个字节来记录是否到达这个路径，和这个路径被命中了多少次的，而这个次数在0-255之间，但比如一个循环，它循环5次和循环6次可能是完全一样的效果，为了避免被当成不同的路径，或者说尽可能减少因为命中次数导致的区别。在每次去计算是否发现了新路径之前，先把这个路径命中数进行规整，比如把命中5次和6次都统一认为是命中了8次。而为什么又需要用一个count_class_lookup16呢，是因为AFL在后面实际进行规整的时候，是一次读两个字节去处理的，为了提高效率，这只是出于效率的考量，实际效果还是上面这种效果。</p>
  </li>
  <li>
    <p>setup_dirs_fds准备输出目录</p>
  </li>
  <li>
    <p>read_testcases</p>

    <p>从输入目录读取测试用例，并加入到队列中：首先使用scandir+alphasort扫描目录，（不使用readdir的原因是防止返回的结果随机），然后遍历过滤体积过大的测试用例，体积用MAX_FILE这个宏来限制，并且检查输入目录的.state/deteministic_done下的文件，这个目录下代表着确定性的fuzz，如果已经完成了没有必要再重复，然后调用add_to_queue将测试用例添加到队列。队列使用一个list来维护。首先添加到queue_top中。q_prev100：跳表，使用next_100，每100个跳一次，加速迭代。</p>
  </li>
  <li>
    <p>load_auto 加载自动生成的附加内容</p>

    <p>读取.state/auto_extras/目录下的内容，这个目录的文件在save_auto函数中写入，作用后续再讲。</p>
  </li>
  <li>
    <p>pivot_inputs</p>

    <p>在输出目录中为输入测试用例创建硬链接，选择好的名称并相应地进行旋转。</p>
  </li>
  <li>
    <p>load_extras函数</p>

    <p>如果通过-x 设置了extras目录，加载里边的字典文件，作为变异参考。</p>
  </li>
  <li>
    <p>find_timeout</p>

    <p>如果没有设置-t，我们不希望一遍又一遍地自动调整超时时间，以防止超时值因随机波动而增长</p>
  </li>
  <li>
    <p>detect_file_args</p>

    <p>这个就是从命令行参数中获取程序的交互方式@@表示，直接传文件给目标程序，如果没有，那么将文件读取出来，然后通过标准输入与输出的方式传给目标程序。</p>
  </li>
  <li>
    <p>setup_stdio_file</p>

    <p>如果使用标准输入输出模式，那么便打开输出目录中的.cur_input文件，文件描述符保存在out_fd中</p>
  </li>
  <li>
    <p>check_binary</p>

    <p>检查文件是不是有效的，是不是有效的二进制文件且正常插桩了。如果设置环境变量AFL_SKIP_BIN_CHECK便可以跳过检查</p>
  </li>
  <li>
    <p>get_qemu_argv</p>

    <p>如果使用qemu模式，获取qemu的参数信息，并设置新的qemu启动参数，具体来说就是使用 <code class="language-plaintext highlighter-rouge">afl-qemu-trace -- target_path</code> ，</p>
  </li>
  <li>
    <p>perform_dry_run</p>

    <p>执行所有测试用例，以确认应用程序按预期运行。这仅针对初始输入执行，并且只执行一次。AFL_SKIP_CRASHES这个环境变量可以跳过测试用例崩溃的情况。</p>

    <p>会遍历队列，调用calibrate_case函数（用于验证目标程序的稳定性和初始化关键参数）去执行队列中的测试用例，如果forkserver没有初始化，先去初始化这个forkserver，其中会创建管道来与forkserver通信。然后将测试用例写入out_fd，并运行测试用例。 根据共享内存的edge的执行情况更新trace_bits，并通过 hash32(trace_bits) 计算覆盖率数据的哈希值，用于一致性校验，判断有没有新的bits，并根据状态结果更新分数。 <code class="language-plaintext highlighter-rouge">update_bitmap_score</code> ：当我们遇到一条新路径时，我们会调用此方法查看该路径是否比任何现有路径看起来更“有利”。 “有利”的目的是拥有一组最小的路径，这些路径会触发迄今为止在位图中看到的所有位，并专注于模糊化它们，而忽略其余部分。该过程的第一步是为位图中的每个字节维护一个 top_rated[] 条目列表。 如果没有先前的竞争者，或者竞争者的速度 x 大小因子更有利，我们将赢得该位置。</p>
  </li>
  <li>
    <p>update_bitemap_score</p>

    <p>每当我们发现一个新的路径，都会调用这个函数来判断其是不是更加地favorable，这个favorable的意思是说是否包含最小的路径集合来遍历到所有bitmap中的位，我们专注于这些集合而忽略其他的。</p>

    <p>首先计算出这个case的fav_factor，计算方法是q-&gt;exec_us * q-&gt;len即执行时间和样例大小的乘积，以这两个指标来衡量权重。</p>

    <p>遍历trace_bits数组，如果该字节的值不为0，则代表这是已经被覆盖到的path</p>

    <p>然后检查对应于这个path的top_rated是否存在</p>

    <p><code class="language-plaintext highlighter-rouge">static struct queue_entry *top_rated[MAP_SIZE];</code></p>

    <p>如果存在，就比较 <code class="language-plaintext highlighter-rouge">fav_factor &gt; top_rated[i]-&gt;exec_us * top_rated[i]-&gt;len</code> ，即比较执行时间和样例大小的乘积，哪个更小。</p>

    <p>如果top_rated[i]的更小，则代表top_rated[i]的更优，不做任何处理，继续遍历下一个path。</p>

    <p>如果q更小，就将top_rated[i]原先对应的queue entry的tc_ref字段减一，并将其trace_mini字段置为空。</p>

    <p>u8 *trace_mini;</p>

    <p>u32 tc_ref;</p>

    <p>然后设置top_rated[i]为q，即当前case，然后将其tc_ref的值加一</p>

    <p>如果q-&gt;trace_mini为空，则将trace_bits经过minimize_bits压缩，然后存到trace_mini字段里</p>

    <p>设置score_changed为1。</p>
  </li>
  <li>
    <p>cull_queue</p>

    <p>AFL在模糊测试过程中会维护一个队列(queue)，里面保存了所有能触发新代码路径的测试用例。随着测试进行，队列可能会变得很大，导致效率下降。这时候就需要裁剪队列，保留最重要的测试用例，去除冗余的部分，这就是cull_queue的作用。</p>

    <p>如果score_changed为0，即top_rated没有变化，或者dumb_mode,就直接返回</p>

    <p>设置score_changed的值为0</p>

    <p>创建u8 temp_v数组，大小为MAP_SIZE除8，并将其初始值设置为0xff，其每位如果为1就代表还没有被覆盖到，如果为0就代表以及被覆盖到了。</p>

    <p>设置queued_favored为0，pending_favored为0</p>

    <p>开始遍历queue队列，设置其favored的值都为0</p>

    <p>将i从0到MAP_SIZE迭代，这个迭代其实就是筛选出一组queue entry，它们就能够覆盖到所有现在已经覆盖到的路径，而且这个case集合里的case要更小更快，这并不是最优算法，只能算是贪婪算法。</p>

    <p>这又是个不好懂的位运算，temp_v[i » 3] &amp; (1 « (i &amp; 7))与上面的差不多，中间的或运算改成了与，是为了检查该位是不是0，即判断该path对应的bit有没有被置位。</p>
  </li>
  <li>
    <p>状态更新相关</p>

    <p>show_init_stats,</p>

    <p>find_start_positon,</p>

    <p>write_stats_file,</p>

    <p>save_auto。</p>
  </li>
</ol>

<h3 id="变异测试核心">变异测试（核心）</h3>

<p>主循环：</p>

<p>cull_queue：然后如果queue_cur为空，queue都被执行完一轮，这时候设置queue_cycle计数器加一，这个值带白哦queue被执行了多少轮。设置current_entry为0，和queue_cur为queue首元素，开始新一轮fuzz，</p>

<p>执行fuzz_one来对queue_cur进行一次测试</p>

<p>然后 <code class="language-plaintext highlighter-rouge">queue_cur = queue_cur-&gt;next;current_entry++;</code> 取出下一个元素。</p>

<p>fuzz_one：这个函数很长，大致就是从当前队列中取出一个测试用例，对其进行fuzz。</p>

<p>fuzz_one会负责变异测试用例，运行测试，获取反馈信息，然后向队列中添加变异的有价值的测试用例。</p>

<p>具体分以下几个过程介绍：</p>

<ol>
  <li>
    <p>calibrate：</p>

    <p>前面介绍过，对测试用例进行校准，假如当前项有校准错误，并且校准错误次数小于3次，那么就用calibrate_case再次校准。会对每个初始种子进行 ​校准测试，以确定其执行速度、稳定性及超时阈值。执行3次或8次取平均值。</p>

    <p><code class="language-plaintext highlighter-rouge">run_target</code> :清空trace_bit，执行程序，统计信息，包括运行时间，数据规整，进程结束原因。</p>
  </li>
  <li>
    <p>trimming：</p>

    <p>tram新的测试用例，如果该case没有trim过，调用函数trim_case(argv, queue_cur, in_buf)进行trim(修剪)，并设置queue_cur的trim_done为1。重新读取一次queue_cur-&gt;len到len中，并将in_buf拷贝len个字节到out_buf中</p>

    <p>函数 trim_case() 负责减小测试用例的大小，同时确保执行路径保持不变。通过从测试用例中删除不必要的字节，这有助于在确定性模糊测试期间节省 CPU 周期。</p>

    <p>如果输入太小（&lt;5 个字节），则跳过修剪。跟踪修剪前测试用例的总大小记录在 <code class="language-plaintext highlighter-rouge">bytes_trim_in</code> 中。</p>

    <p>trim从较大的块大小（2 的幂）开始。块大小会动态调整，以最大程度提高效率。</p>

    <p><code class="language-plaintext highlighter-rouge">while (remove_len &gt;= MAX(len_p2 / TRIM_END_STEPS, TRIM_MIN_BYTES)) {</code>
迭代直到删除的块足够小，</p>

    <pre><code class="language-C">u32 trim_avail = MIN(remove_len, q-&gt;len - remove_pos);
write_with_gap(in_buf, q-&gt;len, remove_pos, trim_avail);
fault = run_target(argv, exec_tmout);
    
</code></pre>

    <p>对这个块位置迭代，把这个选中的块移除再写进测试文件，然后运行程序。再去比较运行结果的trace_bit的hash，如果跟以前相同，那么删除这个块，继续迭代。最后用最小结果替换测试用例。</p>

    <p>该函数会迭代地从测试用例中删除数据块，同时确保程序的执行保持不变。如果可以在不影响覆盖率的情况下删除某个数据块，则将保存新的较小测试用例。</p>

    <pre><code class="language-C">    
static void update_bitmap_score(struct queue_entry* q){}
//这个函数会更新每个edge的最优的case，使用top_rated[edge的index]记录，判断准则就是执行时间和case的大小
    
    
//src中的数据是byte，现在换成bit
static void minimize_bits(u8* dst, u8* src) {
    
  u32 i = 0;
    
  while (i &lt; MAP_SIZE) {
    
    if (*(src++)) dst[i &gt;&gt; 3] |= 1 &lt;&lt; (i &amp; 7);
    i++;
    
  }
    
}
    
    
  //遍历 src（原始执行位图）src 包含字节级执行跟踪数据。
    
  //检查字节是否非零（if (*(src++)))，这意味着在此索引处发生了一些执行。
    
  //设置 dst 中的相应位dst[i &gt;&gt; 3] → 确定应修改 dst 中的哪个字节。1 &lt;&lt; (i &amp; 7) → 确定应设置该字节中的哪个位。按位或（|=）确保我们不会覆盖先前的位。
    
</code></pre>
  </li>
  <li>
    <p>performance score</p>

    <p><code class="language-plaintext highlighter-rouge">perf_score = calculate_score(queue_cur)</code></p>

    <p>如果skip_deterministic为1，或者queue_cur被fuzz过，或者queue_cur的passed_det为1，则跳转去havoc_stage阶段。</p>

    <p>没有就设置doing_det为1，继续deterministic的fuzz</p>

    <p>关于评分：数据都是在calibrate_case中记录的；执行时间约短评分越高，执行的edge越多评分越高。handicap越大，品格分越高。depth越深，评分越高。（有个上限1600）</p>
  </li>
  <li>
    <p>simple bitflip</p>

    <p>定义了一个宏 <code class="language-plaintext highlighter-rouge">#define FLIP_BIT(_ar, _b)</code> 用于bit位翻转。</p>

    <p>设置stage_name为bitflip 1/1,_ar的取值是out_buf,而_bf的取值在[0: len « 3)
所以用_bf &amp; 7能够得到0,1,2…7 0,1,2…7这样的取值一共len组，然后(_bf) » 3又将[0: len«3)映射回了[0: len)，对应到buf里的每个byte。所以在从0-len*8的遍历过程中会通过亦或运算，依次将每个位翻转，然后执行一次common_fuzz_stuff，然后再翻转回来。</p>

    <p>后续翻转2，4，8，16，32位，也是类似的操作。</p>

    <p><code class="language-plaintext highlighter-rouge">common_fuzz_stuff</code> : 把测试用例写进文件，然后 <code class="language-plaintext highlighter-rouge">run_target</code> ，调用 <code class="language-plaintext highlighter-rouge">save_if_interesting</code> 。</p>

    <p>这个save_if_interesting会看看样本有没有新的行为，比如新edge被发现或者target crash了等，如果有就把它加入到队列头中。然后调用calibrate。1. 函数首先会处理crash_mode，如果故障与崩溃有关：它会检查位图是否有新位（has_new_bits()），如果发现新位，它会将测试用例添加到队列并将其保存到队列目录中的文件中。它还会校准案例以收集有关其执行路径的更多信息。测试用例保存在具有特定命名模式的文件中（SIMPLE_FILES 或非 SIMPLE_FILES）。2. 处理FAULT_TMOUT超时错误，如果故障是超时：它会检查挂起特定位图中是否有新位，如果没有发现新位，则不会保存测试用例，如果测试用例是潜在挂起，程序会以更长的超时时间运行它，以确认它是否确实挂起。如果认为有趣，它会保存在挂起目录中。3. 处理crash错误FAULT_CRASH，如果故障是崩溃：测试用例仅在触发新行为（位图中的新位）时才被保存。它会检查崩溃是否唯一，如果是，则将其保存到崩溃目录中。如果这是第一次崩溃，它会编写包含崩溃详细信息的README（write_crash_readme）。其余错误，FAULT_ERROR会报错，其他情况直接返回。4. 最后一步：如果满足上述任何条件，将测试用例保存到文件中。根据崩溃或挂起情况，将文件保存到目录中，并将测试用例添加到队列中以供将来进行模糊测试。</p>
  </li>
  <li>
    <p>arithmetic inc/dec</p>

    <p>在bitflip变异全部进行完成后，便进入下一个阶段：arithmetic。与bitflip类似的是，arithmetic根据目标大小的不同，也分为了多个子阶段：</p>

    <p>arith 8/8，每次对8个bit进行加减运算，按照每8个bit的步长从头开始，即对文件的每个byte进行整数加减变异</p>

    <p>arith 16/8，每次对16个bit进行加减运算，按照每8个bit的步长从头开始，即对文件的每个word进行整数加减变异</p>

    <p>arith 32/8，每次对32个bit进行加减运算，按照每8个bit的步长从头开始，即对文件的每个dword进行整数加减变异</p>

    <p>加减变异的上限，在config.h中的宏ARITH_MAX定义，默认为35。所以，对目标整数会进行+1, +2, …, +35, -1, -2, …, -35的变异。特别地，由于整数存在大端序和小端序两种表示方式，AFL会贴心地对这两种整数表示方式都进行变异。</p>

    <p>此外，AFL还会智能地跳过某些arithmetic变异。第一种情况就是前面提到的effector map：如果一个整数的所有bytes都被判断为“无效”，那么就跳过对整数的变异。第二种情况是之前bitflip已经生成过的变异：如果加/减某个数后，其效果与之前的某种bitflip相同，那么这次变异肯定在上一个阶段已经执行过了，此次便不会再执行。</p>
  </li>
  <li>
    <p>interesting values</p>

    <p>下一个阶段是interest，具体可分为：</p>

    <p>interest 8/8，每次对8个bit进替换，按照每8个bit的步长从头开始，即对文件的每个byte进行替换</p>

    <p>interest 16/8，每次对16个bit进替换，按照每8个bit的步长从头开始，即对文件的每个word进行替换</p>

    <p>interest 32/8，每次对32个bit进替换，按照每8个bit的步长从头开始，即对文件的每个dword进行替换</p>

    <p>而用于替换的”interesting values”，是AFL预设的一些比较特殊的数,这些数的定义在config.h文件中</p>

    <p>与之前类似，effector map仍然会用于判断是否需要变异；此外，如果某个interesting value，是可以通过bitflip或者arithmetic变异达到，那么这样的重复性变异也是会跳过的。</p>
  </li>
  <li>
    <p>dictionary stuff</p>

    <p>进入到这个阶段，就接近deterministic fuzzing的尾声了。具体有以下子阶段：</p>

    <p>user extras(over),从头开始,将用户提供的tokens依次替换到原文件中,stage_max为extras_cnt * len</p>

    <p>user extras(insert),从头开始,将用户提供的tokens依次插入到原文件中,stage_max为extras_cnt * len</p>

    <p>auto extras(over),从头开始,将自动检测的tokens依次替换到原文件中,stage_max为MIN(a_extras_cnt, USE_AUTO_EXTRAS) * len</p>

    <p>其中，用户提供的tokens，是在词典文件中设置并通过-x选项指定的，如果没有则跳过相应的子阶段。</p>
  </li>
  <li>
    <p>random havoc</p>

    <p>对于非dumb mode的主fuzzer来说，完成了上述deterministic fuzzing后，便进入了充满随机性的这一阶段；对于dumb mode或者从fuzzer来说，则是直接从这一阶段开始。</p>

    <p>havoc，顾名思义，是充满了各种随机生成的变异，是对原文件的“大破坏”。具体来说，havoc包含了对原文件的多轮变异，每一轮都是将多种方式组合（stacked）而成：</p>

    <p>随机选取某个bit进行翻转</p>

    <p>随机选取某个byte，将其设置为随机的interesting value</p>

    <p>随机选取某个word，并随机选取大、小端序，将其设置为随机的interesting value</p>

    <p>随机选取某个dword，并随机选取大、小端序，将其设置为随机的interesting value</p>

    <p>随机选取某个byte，对其减去一个随机数</p>

    <p>随机选取某个byte，对其加上一个随机数</p>

    <p>随机选取某个word，并随机选取大、小端序，对其减去一个随机数</p>

    <p>随机选取某个word，并随机选取大、小端序，对其加上一个随机数</p>

    <p>随机选取某个dword，并随机选取大、小端序，对其减去一个随机数</p>

    <p>随机选取某个dword，并随机选取大、小端序，对其加上一个随机数</p>

    <p>随机选取某个byte，将其设置为随机数</p>

    <p>随机删除一段bytes</p>

    <p>随机选取一个位置，插入一段随机长度的内容，其中75%的概率是插入原文中随机位置的内容，25%的概率是插入一段随机选取的数</p>

    <p>随机选取一个位置，替换为一段随机长度的内容，其中75%的概率是替换成原文中随机位置的内容，25%的概率是替换成一段随机选取的数</p>

    <p>随机选取一个位置，用随机选取的token（用户提供的或自动生成的）替换</p>

    <p>随机选取一个位置，用随机选取的token（用户提供的或自动生成的）插入</p>
  </li>
  <li>
    <p>splicing</p>

    <p>设置ret_val的值为0</p>

    <p>如果queue_cur通过了评估，且was_fuzzed字段是0，就设置queue_cur-&gt;was_fuzzed为1，然后pending_not_fuzzed计数器减一</p>

    <p>如果queue_cur是favored, pending_favored计数器减一。</p>
  </li>
</ol>

<h2 id="注意">注意：</h2>

<p>在mac上不要使用gcc和afl-gcc，要用clang和afl-clang，-B参数不知为啥无法生效，mac下的gcc也是一层wrapper，实际调用的是clang估计里面有什么bug。</p>

<p>当目标文件很大的时候，编译目标文件开启以下宏定义
AFL_INST_RATIO=10</p>

<p>多线程不稳定：</p>

<ul>
  <li>
    <p>使用 llvm_mode/ 中的 afl-clang-fast - 它使用不易出现并发问题的线程本地跟踪</p>
  </li>
  <li>
    <p>查看目标是否可以在没有线程的情况下编译或运行。常见的 ./configure 选项包括 –without-threads、–disable-pthreads 或 –disable-openmp。</p>
  </li>
  <li>
    <p>将 pthreads 替换为 GNU Pth (<a href="https://www.gnu.org/software/pth/">https://www.gnu.org/software/pth/</a>)，这样可以使用确定性调度程序。</p>
  </li>
</ul>

<p>一些关键状态屏幕信息也可以以机器可读的格式在输出目录中的 fuzzer_stats 文件中找到</p>

<p>编译时尽量开启asan，asan的原理就是hook了malloc，free，还有load，set这样的函数然后把地址和大小记录下来，读写的时候会比对内存信息。</p>

<h2 id="无源码插桩">无源码插桩</h2>

<p>DynamoRIO，winafl运行时的覆盖率收集</p>

<h2 id="实践fuzzing101">实践Fuzzing101</h2>

<h3 id="exercise-1">Exercise 1</h3>

<pre><code class="language-C">
mkdir ~/fuzzing_xpdf

AFL_PATH=/root/AFL/ CC=/root/AFL/afl-gcc CXX=/root/AFL/afl-g++ ./configure --prefix="/root/fuzzing_xpdf/"


echo core &gt;/proc/sys/kernel/core_pattern


/root/AFL/afl-fuzz -i /root/fuzzing_xpdf/pdf_examples/ -o /root/fuzzing_xpdf/out/  -- /root/fuzzing_xpdf/bin/pdftotext @@ /root/fuzzing_xpdf/output

</code></pre>

<p>result: 跑了一晚上有7个crash。有栈溢出的崩溃。</p>

<h3 id="exercise-2">Exercise 2</h3>

<pre><code class="language-C">AFL_PATH=/root/AFL/ CC=/root/AFL/afl-gcc CXX=/root/AFL/afl-g++ ./configure --enable-shared=no --prefix="$HOME/fuzzing_libexif/install/" PKG_CONFIG_PATH=$HOME/fuzzing_libexif/install/lib/pkgconfig


/root/AFL/afl-fuzz -i $HOME/fuzzing_libexif/exif-samples-master/jpg/ -o $HOME/fuzzing_libexif/out/  -- $HOME/fuzzing_libexif/install/bin/exif @@

</code></pre>

<p>启动多个fuzzer：</p>

<pre><code class="language-C">/root/AFL/afl-fuzz -i $HOME/fuzzing_libexif/exif-samples-master/jpg/ -o $HOME/fuzzing_libexif/out/ -M fuzzer1 -- $HOME/fuzzing_libexif/install/bin/exif @@


/root/AFL/afl-fuzz -i $HOME/fuzzing_libexif/exif-samples-master/jpg/ -o $HOME/fuzzing_libexif/out/ -S fuzzer2 -- $HOME/fuzzing_libexif/install/bin/exif @@


/root/AFL/afl-fuzz -i $HOME/fuzzing_libexif/exif-samples-master/jpg/ -o $HOME/fuzzing_libexif/out/ -S fuzzer3 -- $HOME/fuzzing_libexif/install/bin/exif @@

/root/AFL/afl-whatsup $HOME/fuzzing_libexif/out/

</code></pre>

<h3 id="exercise-6">Exercise 6</h3>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">export </span><span class="nv">LD_LIBRARY_PATH</span><span class="o">=</span><span class="nv">$LD_LIBRARY_PATH</span>:/root/Fuzzing_gimp/install/lib

<span class="nb">export </span><span class="nv">LIBRARY_PATH</span><span class="o">=</span><span class="nv">$LIBRARY_PATH</span>:/root/Fuzzing_gimp/install/lib

<span class="nb">export </span><span class="nv">PATH</span><span class="o">=</span><span class="nv">$PATH</span>:/root/Fuzzing_gimp/install/bin

<span class="nb">export </span><span class="nv">C_INCLUDE_PATH</span><span class="o">=</span><span class="nv">$C_INCLUDE_PATH</span>:/root/Fuzzing_gimp/install/include/

<span class="nb">export </span><span class="nv">CPLUS_INCLUDE_PATH</span><span class="o">=</span><span class="nv">$CPLUS_INCLUDE_PATH</span>:/root/Fuzzing_gimp/install/include/



<span class="nv">CC</span><span class="o">=</span>/root/AFL/afl-gcc <span class="nv">CXX</span><span class="o">=</span>/root/AFL/afl-g++ <span class="nv">PKG_CONFIG_PATH</span><span class="o">=</span><span class="nv">$PKG_CONFIG_PATH</span>:<span class="nv">$HOME</span>/Fuzzing_gimp/gegl-0.2.0/  ./configure <span class="nt">--disable-gtktest</span> <span class="nt">--disable-glibtest</span> <span class="nt">--disable-alsatest</span> <span class="nt">--disable-nls</span> <span class="nt">--without-libtiff</span> <span class="nt">--without-libjpeg</span> <span class="nt">--without-bzip2</span> <span class="nt">--without-gs</span> <span class="nt">--without-libpng</span> <span class="nt">--without-libmng</span> <span class="nt">--without-libexif</span> <span class="nt">--without-aa</span> <span class="nt">--without-libxpm</span> <span class="nt">--without-webkit</span> <span class="nt">--without-librsvg</span> <span class="nt">--without-print</span> <span class="nt">--without-poppler</span> <span class="nt">--without-cairo-pdf</span> <span class="nt">--without-gvfs</span> <span class="nt">--without-libcurl</span> <span class="nt">--without-wmf</span> <span class="nt">--without-libjasper</span> <span class="nt">--without-alsa</span> <span class="nt">--without-gudev</span> <span class="nt">--disable-python</span> <span class="nt">--enable-gimp-console</span> <span class="nt">--without-mac-twain</span> <span class="nt">--without-script-fu</span> <span class="nt">--without-gudev</span> <span class="nt">--without-dbus</span> <span class="nt">--disable-mp</span> <span class="nt">--without-linux-input</span> <span class="nt">--without-xvfb-run</span> <span class="nt">--with-gif-compression</span><span class="o">=</span>none <span class="nt">--without-xmc</span> <span class="nt">--with-shm</span><span class="o">=</span>none <span class="nt">--enable-debug</span>  <span class="nt">--prefix</span><span class="o">=</span><span class="s2">"</span><span class="nv">$HOME</span><span class="s2">/Fuzzing_gimp/gimp-2.8.16/install"</span>
make <span class="nt">-j</span><span class="si">$(</span><span class="nb">nproc</span><span class="si">)</span>
make <span class="nb">install



</span><span class="nv">ASAN_OPTIONS</span><span class="o">=</span><span class="nv">detect_leaks</span><span class="o">=</span>0,abort_on_error<span class="o">=</span>1,symbolize<span class="o">=</span>0 /root/AFL/afl-fuzz <span class="nt">-i</span> <span class="s1">'./afl_in'</span> <span class="nt">-o</span> <span class="s1">'./afl_out'</span>  <span class="nt">-t</span> 100 <span class="nt">--</span> ./install/bin/gimp-console-2.8 <span class="nt">--verbose</span> <span class="nt">-d</span> <span class="nt">-f</span> @@

</code></pre></div></div>

<h2 id="参考链接">参考链接</h2>

<p><a href="https://eternalsakura13.com/2020/08/23/afl/">sakura的afl源码分析</a></p>]]></content><author><name>樵夫砍柴手札</name><email>p1ain0@outlook.com</email></author><category term="AFL" /><category term="AFL" /><summary type="html"><![CDATA[最近在阅读alf的源代码时做的一些笔记，有点乱不往论坛发了，自己回顾的时候看看的，有很多都引用的sakura师傅的分析笔记。]]></summary></entry><entry><title type="html">Linux内存管理</title><link href="http://localhost:4000/linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" rel="alternate" type="text/html" title="Linux内存管理" /><published>2025-03-15T00:00:00+08:00</published><updated>2025-03-15T00:00:00+08:00</updated><id>http://localhost:4000/linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86</id><content type="html" xml:base="http://localhost:4000/linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"><![CDATA[<p>本篇文章详细介绍linux内核的内存管理，主要分为两部分，介绍伙伴算法和slab分配器-SLUB的工作机制，重点放在后面部分。</p>

<p>我们说的内存管理器是指 <code class="language-plaintext highlighter-rouge">page allocator</code> 与 <code class="language-plaintext highlighter-rouge">slab allocator</code> ：</p>

<p>page allocator: 负责管理整个系统的物理内存的分配，linux的page分配器基于伙伴系统buddy system</p>

<p>slab allocator: 负责堆内存分配，有很多种，我们主要谈论SLUB的实现。</p>

<p>我们可以通过 <code class="language-plaintext highlighter-rouge">cat /proc/buddyinfo</code> 与 <code class="language-plaintext highlighter-rouge">cat /proc/pagetypeinfo</code> 查看页面相关信息：</p>

<h2 id="cpu的分页机制">CPU的分页机制</h2>

<p>一切的一切从CPU的分页机制谈起…</p>

<p>由于物理内存管理使用页表结构会根据芯片架构的不同而有所不同，这里以x86-64架构为例来介绍：</p>

<h3 id="virtual-memory-layout">Virtual memory layout</h3>

<p>[Kernel address space]<a href="https://www.kernel.org/doc/Documentation/x86/x86_64/mm.txt">https://www.kernel.org/doc/Documentation/x86/x86_64/mm.txt</a></p>

<p>cpu有一个CR3寄存器存放第一级页表（PGD）的物理地址。页表中的每一个表项(后面简称entry)必须要4KB大小对齐。
每一个page table entry 都是一个 <code class="language-plaintext highlighter-rouge">unsigned long(uint64_t)(declared as pxxval_t)</code> 类型的值，通过将这些类型中的每一个封装在一个结构体中，可以强制执行一些makeshift类型安全比如 <code class="language-plaintext highlighter-rouge">typedef struct { pgdval_t pgd; } pgd_t</code> 。PageTable的结构依赖于Intel 5-level paging是否开启，检查方式在<a href="https://elixir.bootlin.com/linux/v6.6/source/arch/x86/kernel/head64.c#L105">check_la57_support()</a>。</p>

<p>虚拟地址空间是由 <a href="https://elixir.bootlin.com/linux/v6.6/source/arch/x86/include/asm/page_types.h#L14">__VIRTUAL_MASK</a>和<a href="https://elixir.bootlin.com/linux/v6.6/source/arch/x86/include/asm/page_64_types.h#L57">__VIRTUAL_MASK_SHIFT</a>决定的。</p>

<p><code class="language-plaintext highlighter-rouge">#define __VIRTUAL_MASK		((1UL &lt;&lt; __VIRTUAL_MASK_SHIFT) - 1)</code></p>

<p><code class="language-plaintext highlighter-rouge">#define __VIRTUAL_MASK_SHIFT	(pgtable_l5_enabled() ? 56 : 47)</code></p>

<table>
  <thead>
    <tr>
      <th>Level</th>
      <th>Count</th>
      <th>Shift</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>PGD</td>
      <td>[PTRS_PER_PGD][6] (512)</td>
      <td>[PGDIR_SHIFT][13] (48 or 39)</td>
      <td>Page Global Directory</td>
    </tr>
    <tr>
      <td>P4D</td>
      <td>[PTRS_PER_P4D][7] (512 or 1)</td>
      <td>[P4D_SHIFT][14] (39)</td>
      <td>Page 4 Directory()</td>
    </tr>
    <tr>
      <td>PUD</td>
      <td>[PTRS_PER_PUD][10] (512)</td>
      <td>[PUD_SHIFT][14] (30)</td>
      <td>Page Upper Directory</td>
    </tr>
    <tr>
      <td>PMD</td>
      <td>[PTRS_PER_PMD][11] (512)</td>
      <td>[PMD_SHIFT][15] (21)</td>
      <td>Page Middle Directory</td>
    </tr>
    <tr>
      <td>PTE</td>
      <td>[PTRS_PER_PTE][12] (512)</td>
      <td>[PAGE_SHIFT][16] (12)</td>
      <td>Page Table Entry directory</td>
    </tr>
  </tbody>
</table>

<p>以下是分别在4级5级页表结构中虚拟地址的各个位在寻址时代表在各级目录表项的索引。</p>

<p>在 4 级页表的 x86-64 架构中，虚拟地址空间为 48 位。</p>

<pre><code class="language-C">

                                    48 bits
&lt;--------------&gt;&lt;----------------------------------------------&gt;
   6         5         4         3         2         1
---|---------|---------|---------|---------|---------|----------
3210987654321098765432109876543210987654321098765432109876543210
                [  PGD  ][  PUD  ][  PMD  ][  PTE  ][  OFFSET  ]
111111111111111111111111111111111111111111100000000|000000000000  PMD_MASK
111111111111111111111111111111111100000000|00000000|000000000000  PUD_MASK
111111111111111111111111100000000|00000000|00000000|000000000000  PGDIR_MASK
                        |        |        |        |
                        |        |        |        |
                        |        |        |        |------------- PAGE_SHIFT  (12)
                        |        |        |---------------------- PMD_SHIFT   (21)
                        |        |------------------------------- PUD_SHIFT   (30)
                        |---------------------------------------- PGDIR_SHIFT (39)
</code></pre>

<p><code class="language-plaintext highlighter-rouge">512 * 1 * 512 * 512 * 512 = 68.7bn 4KiB pages = 256 TiB</code> ，四级页表模式可以寻址空间在256TB</p>

<p>地址空间排布</p>

<pre><code class="language-C">Userland (128 TiB)
                        0000000000000000 -&gt; |---------------| ^
                                            |    Process    | |
                                            |    address    | | 128 TiB
                                            |     space     | |
                        0000800000000000 -&gt; |---------------| v
                     .        ` .     -                 `-       ./   _
                              _    .`   -   The netherworld of  `/   `
                    -     `  _        |  /      unavailable sign-extended -/ .
                     ` -        .   `  48-bit address space  -     \  /    -
                   \-                - . . . .             \      /       -
Kernel (128 TiB)
                        ffff800000000000 -&gt; |----------------| ^
                                            |   Hypervisor   | |
                                            |    reserved    | | 8 TiB
                                            |      space     | |
                        ffff880000000000 -&gt; |----------------| x
                                            | LDT remap for  | | 0.5 TiB
                                            |       PTI      | |
[kaslr]   PAGE_OFFSET = ffff888000000000 -&gt; |----------------| x
                                            | Direct mapping | |
                                            |  of all phys.  | | 64 TiB
                                            |     memory     | |
                        ffffc88000000000 -&gt; |----------------| v
                                            /                /
                                            \     unused     \
                                            /      hole      /
                                            \                \
[kaslr] VMALLOC_START = ffffc90000000000 -&gt; |----------------| ^
                                            |    vmalloc/    | |
                                            |    ioremap     | | 32 TiB
                                            |     space      | |
      VMALLOC_END + 1 = ffffe90000000000 -&gt; |----------------| v
                                            /                /
                                            \     unused     \
                                            /      hole      /
                                            \                \
[kaslr] VMEMMAP_START = ffffea0000000000 -&gt; |----------------| ^
                                            |     Virtual    | |
                                            |   memory map   | | 1 TiB
                                            |  (struct page  | |
                                            |     array)     | |
                        ffffeb0000000000 -&gt; |----------------| v
                                            /                /
                                            \     unused     \
                                            /      hole      /
                                            \                \
                        ffffec0000000000 -&gt; |----------------| ^
                                            |  KASAN shadow  | | 16 TiB
                                            |     memory     | |
                        fffffc0000000000 -&gt; |----------------| v
                                            /                /
                                            \     unused     \
                                            /      hole      /
                                            \                \
                        fffffe0000000000 -&gt; |----------------| ^
                                            | cpu_entry_area | | 0.5 TiB
                                            |     mapping    | |
                        fffffe8000000000 -&gt; |----------------| v
                                            /                /
                                            \     unused     \
                                            /      hole      /
                                            \                \
     ESPFIX_BASE_ADDR = ffffff0000000000 -&gt; |----------------| ^
                                            |   %esp fixup   | | 0.5 TiB
                                            |     stacks     | |
                        ffffff8000000000 -&gt; |----------------| v
                                            /                /
                                            \     unused     \
                                            /      hole      /
                                            \                \
           EFI_VA_END = ffffffef00000000 -&gt; |----------------| ^
                                            |   EFI region   | | 64 GiB
                                            | mapping space  | |
         EFI_VA_START = ffffffff00000000 -&gt; |----------------| v
                                            /                /
                                            \     unused     \
                                            /      hole      /
                                            \                \
   __START_KERNEL_map = ffffffff80000000 -&gt; |----------------| ^
                                            |     Kernel     | |
                                            |      text      | | KERNEL_IMAGE_SIZE = 1 GiB *
                                            |     mapping    | |
        MODULES_VADDR = ffffffffc0000000 -&gt; |----------------| x *
                                            |     Module     | |
                                            |    mapping     | | 1 GiB *
                                            |     space      | |
                        ffffffffff600000 -&gt; |----------------| x
                                            |   vsyscalls    | | 8 MiB
                        ffffffffffe00000 -&gt; |----------------| v
                                            /                /
                                            \     unused     \
                                            /      hole      /
                                            \                \
                                            ------------------


</code></pre>

<p>在 5 级页表的 x86-64 架构中，虚拟地址空间扩展到了 57 位。</p>

<pre><code class="language-C">

                               57 bits
&lt;-----&gt;&lt;-------------------------------------------------------&gt;
   6         5         4         3         2         1
---|---------|---------|---------|---------|---------|----------
3210987654321098765432109876543210987654321098765432109876543210
       [  PGD  ][  P4D  ][  PUD  ][  PMD  ][  PTE  ][  OFFSET  ]
111111111111111111111111111111111111111111100000000|000000000000  PMD_MASK
111111111111111111111111111111111100000000|00000000|000000000000  PUD_MASK
111111111111111111111111100000000|00000000|00000000|000000000000  P4D_MASK
111111111111111100000000|00000000|00000000|00000000|000000000000  PGDIR_MASK
               |        |        |        |        |
               |        |        |        |        |------------- PAGE_SHIFT  (12)
               |        |        |        |---------------------- PMD_SHIFT   (21)
               |        |        |------------------------------- PUD_SHIFT   (30)
               |        |---------------------------------------- P4D_SHIFT   (39)
               |------------------------------------------------- PGDIR_SHIFT (48)

</code></pre>

<p><code class="language-plaintext highlighter-rouge">512 * 512 * 512 * 512 * 512` = 35.2tn 4KiB pages = 128 PiB</code> ，五级页表模式可以寻址空间在128PB</p>

<pre><code class="language-C">Userland (64 PiB)
                        0000000000000000 -&gt; |---------------| ^
                                            |    Process    | |
                                            |    address    | | 64 PiB
                                            |     space     | |
                        0100000000000000 -&gt; |---------------| v
                     .        ` .     -                 `-       ./   _
                              _    .`   -   The netherworld of  `/   `
                    -     `  _        |  /      unavailable sign-extended -/ .
                     ` -        .   `  57-bit address space  -     \  /    -
                   \-                - . . . .             \      /       -
Kernel (64 PiB)
                        ff00000000000000 -&gt; |----------------| ^
                                            |   Hypervisor   | |
                                            |    reserved    | | 4 PiB
                                            |      space     | |
                        ff10000000000000 -&gt; |----------------| x
                                            | LDT remap for  | | 0.25 PiB
                                            |       PTI      | |
[kaslr]   PAGE_OFFSET = ff11000000000000 -&gt; |----------------| x
                                            | Direct mapping | |
                                            |  of all phys.  | | 32 PiB
                                            |     memory     | |
                        ff91000000000000 -&gt; |----------------| v
                                            /                /
                                            \     unused     \
                                            /      hole      /
                                            \                \
[kaslr] VMALLOC_START = ffa0000000000000 -&gt; |----------------| ^
                                            |    vmalloc/    | |
                                            |    ioremap     | | 12.5 PiB
                                            |     space      | |
      VMALLOC_END + 1 = ffd2000000000000 -&gt; |----------------| v
                                            /                /
                                            \     unused     \
                                            /      hole      /
                                            \                \
[kaslr] VMEMMAP_START = ffd4000000000000 -&gt; |----------------| ^
                                            |     Virtual    | |
                                            |   memory map   | | 0.5 PiB
                                            |  (struct page  | |
                                            |     array)     | |
                        ffd6000000000000 -&gt; |----------------| v
                                            /                /
                                            \     unused     \
                                            /      hole      /
                                            \                \
                        ffdf000000000000 -&gt; |----------------| ^
                                            |  KASAN shadow  | | 8 PiB
                                            |     memory     | |
                        fffffc0000000000 -&gt; |----------------| v
                                            /                /
                                            \     unused     \
                                            /      hole      /
                                            \                \
                        fffffe0000000000 -&gt; |----------------| ^
                                            | cpu_entry_area | | 0.5 TiB
                                            |     mapping    | |
                        fffffe8000000000 -&gt; |----------------| v
                                            /                /
                                            \     unused     \
                                            /      hole      /
                                            \                \
     ESPFIX_BASE_ADDR = ffffff0000000000 -&gt; |----------------| ^
                                            |   %esp fixup   | | 0.5 TiB
                                            |     stacks     | |
                        ffffff8000000000 -&gt; |----------------| v
                                            /                /
                                            \     unused     \
                                            /      hole      /
                                            \                \
           EFI_VA_END = ffffffef00000000 -&gt; |----------------| ^
                                            |   EFI region   | | 64 GiB
                                            | mapping space  | |
         EFI_VA_START = ffffffff00000000 -&gt; |----------------| v
                                            /                /
                                            \     unused     \
                                            /      hole      /
                                            \                \
   __START_KERNEL_map = ffffffff80000000 -&gt; |----------------| ^
                                            |     Kernel     | |
                                            |      text      | | KERNEL_IMAGE_SIZE = 1 GiB *
                                            |     mapping    | |
        MODULES_VADDR = ffffffffc0000000 -&gt; |----------------| x *
                                            |     Module     | |
                                            |    mapping     | | 1 GiB *
                                            |     space      | |
                        ffffffffff600000 -&gt; |----------------| x
                                            |   vsyscalls    | | 8 MiB
                        ffffffffffe00000 -&gt; |----------------| v
                                            /                /
                                            \     unused     \
                                            /      hole      /
                                            \                \
                                            ------------------

</code></pre>

<p>这几个图引自《linux-mm-notes》系列文章（链接忘了，在github上，搜一搜应该能找到）</p>

<p>注：如果PUD被标记为huge（1 GiB页面大小），则跳过PMD和PTE目录条目，直接通过PUD表项完成地址转换（并且将PUD视为PTE）；如果PMD被标记为huge（2 MiB页面大小），则跳过PTE目录条目，直接通过PMD表项完成地址转换。</p>

<p>至于每个页目录表项中的条目的每个flag位就更复杂了，此处略。</p>

<h3 id="linux中物理地址pa与虚拟地址va的转换">linux中物理地址PA与虚拟地址VA的转换</h3>

<ol>
  <li>
    <p>PA to VA:<a href="https://elixir.bootlin.com/linux/v6.6/source/arch/x86/include/asm/page.h#L58">__va()</a></p>
  </li>
  <li>
    <p>VA to PA:<a href="https://elixir.bootlin.com/linux/v6.6/source/arch/x86/include/asm/page.h#L41">__pa()</a></p>

    <p>我们只能转换部分直接映射的虚拟地址（ZONE_DMA和ZONE_NORMAL），即通过kmalloc()或__get_free_pages()分配的内存，其余的（比如用户空间的地址；内核高端内存（ZONE_HIGHMEM）、vmalloc区域或设备映射地址（需使用kmap()或ioremap()））都要通过页表去寻址。</p>

    <p>内核解压的关键步骤：</p>

    <pre><code class="language-C">    
extract_kernel()
├── choose_random_location()  // 随机选择phys_base
├── handle_relocations()       // 调整虚拟地址偏移
└── __startup_64()            // 验证物理/虚拟偏移一致性，__startup_64()中，通过比较physaddr参数与_text的实际物理地址计算load_delta
    
</code></pre>

    <pre><code class="language-C">    
#define __pa(x)     __phys_addr((unsigned long)(x))
    
#define __phys_addr(x)      __phys_addr_nodebug(x)
    
static __always_inline unsigned long __phys_addr_nodebug(unsigned long x)
{
        unsigned long y = x - __START_KERNEL_map;
    
        /* use the carry flag to determine if x was &lt; __START_KERNEL_map */
        x = y + ((x &gt; y) ? phys_base : (__START_KERNEL_map - PAGE_OFFSET));
    
        return x;
}
    
</code></pre>

    <p>__START_KERNEL_map是Linux内核中定义的一个关键宏，表示内核镜像的起始虚拟地址。（如x86_64中通常为0xffffffff80000000），从虚拟地址中减去__START_KERNEL_map，得到相对偏移量y。</p>

    <p>通过比较x与y的关系（即x &gt; y是否成立）（即进位标志判断），确定虚拟地址是否位于内核直接映射区域（__START_KERNEL_map以上的地址）。</p>

    <p>若虚拟地址在直接映射区（x &gt; y），则加上phys_base（物理内存的基址）。若在非直接映射区（如内核镜像区），则使用__START_KERNEL_map - PAGE_OFFSET作为修正偏移量</p>

    <p><a href="https://elixir.bootlin.com/linux/v6.6/source/arch/x86/kernel/head64.c#L317">phys_base</a>表示从<a href="https://elixir.bootlin.com/linux/v6.6/source/arch/x86/Kconfig#L2065">CONFIG_PHYSICAL_START</a>开始的物理偏移，如果内核已被重新定位，则内核text段映射进物理内存将从该偏移开始（在x86-64架构中默认值为0，但在启用KASLR时会被动态调整）。</p>

    <p>CONFIG_PHYSICAL_START是内核编译时预设的物理基地址，默认值为0x1000000（16MB）。这是内核镜像在链接阶段期望加载text段的物理起始地址。</p>

    <p><a href="https://elixir.bootlin.com/linux/v6.6/source/arch/x86/kernel/head64.c#L203">load_delta</a>CONFIG_PHYSICAL_START与实际加载text段的地址（phys_base）之间的差值，计算公式为：</p>

    <pre><code class="language-C"> /*
  * Compute the delta between the address I am compiled to run at
  * and the address I am actually running at.
  */
load_delta = physaddr - (unsigned long)(_text - __START_KERNEL_map);
</code></pre>
  </li>
</ol>

<h3 id="直接物理内存映射">直接物理内存映射</h3>

<p>物理内存是直接整个被映射进内核虚拟内存空间的，可以看上面讨论四级五级页表的内存空间排布的图。因此任何内核代码都可以访问物理内存的任何部分。</p>

<p>在初始化的时候就完成的。
<code class="language-plaintext highlighter-rouge">start_kernel() -&gt; setup_arch() -&gt;
init_mem_mapping()</code></p>

<h2 id="物理内存管理伙伴系统">物理内存管理（伙伴系统）</h2>

<p>TODO…</p>

<h2 id="slub-internals">SLUB Internals</h2>

<p>本篇文章这部分是学习内核堆利用时的视频笔记，视频源链接在最后。</p>

<h3 id="基本概念">基本概念：</h3>

<p>Slab分配器：是用来管理内核堆内存的基础设施
目前linux内核提供三种主流的实现：SLOB，SLAB，SLUB，这三种提供相同的接口供外部使用。其中SLUB是linux默认启用的，也可以在编译前通过修改编译配置文件，换成其他两种。</p>

<p>objects：slab可以分配出去小内存区域。</p>

<p>slabs：是保存objects的大内存区域，其上区域被切分成大小相同的内存区域称为object slots。这片内存是通过page_alloc分配的。</p>

<p>slot：是Slab分配器中预定义的 ​固定大小的内存块区间。</p>

<p>（slot和objects其实指代的东西相同，因为它们在内存上是重叠的，但是只是在不同场合他们的称呼不一样。区分不开问题也不大，理解工作流程即可。）</p>

<h3 id="slab-bugs">Slab bugs</h3>

<p>典型的动态内存bugs：</p>

<ul>
  <li>
    <p>Out-of-bounds(OOB)越界读写</p>
  </li>
  <li>
    <p>Use-after-free(UAF)</p>
  </li>
  <li>
    <p>Double-free，invalid-free</p>
  </li>
</ul>

<p>攻击方式：</p>

<p>利用上述bug，可以达到overwrite和泄漏的目的。
因为free的object slot中存在元数据，我们可以通过覆盖链表的next指针，控制下一次的分配对象，获得任意地址读写，可以提权或者泄漏内核地址。堆上的内容也可能包含函数指针，我们可以控制它达成任意代码执行或者泄漏内核地址。具体的攻击措施还要看特定的漏洞详情。</p>

<h3 id="内核堆上的防护措施">内核堆上的防护措施：</h3>

<p>下一个free slot的指针被保存在free slot的中间附近，这样可以防止小范围的溢出破坏指针</p>

<pre><code class="language-C">
cache-&gt;offset = ALIGN_DOWN(cache-&gt;object_size / 2, sizeof(void *));
freeptr_addr = (unsigned long)object + cache-&gt;offset;

</code></pre>

<p>通过一个 <code class="language-plaintext highlighter-rouge">CONFIG_SLAB_FREELIST_HARDENED=y</code> 的编译配置选项，freelist指针会被加密保存。</p>

<pre><code class="language-C">
cache-&gt;random = get_random_long();

freelist_ptr = (void *)((unsigned long)ptr ^  cache-&gt;random ^ swab(ptr_addr));
// ptr — actual value of freelist pointer
// ptr_addr — location where freelist pointer is stored
// swab() — exchanges adjacent even and odd bytes

</code></pre>

<p>ptr是freelist pointer的值，ptr_addr是freelist pointer被保存的地址，swab交换奇偶byte字节序。</p>

<p>所以要利用只能先泄漏 <code class="language-plaintext highlighter-rouge">cache-&gt;random</code> 和 =ptr_addr=，让利用更加困难。大多数现代 Slab 漏洞利用的是覆盖对象或者通过跨分配器攻击覆盖其他类型的内存。</p>

<p>通过 <code class="language-plaintext highlighter-rouge">CONFIG_SLAB_FREELIST_RANDOM=y</code> 配置，当分配新的 slab 时，SLUB 会打乱空闲列表中对象的顺序，这样让分配的地址更难预测。</p>

<h3 id="slab关键数据结构">slab关键数据结构</h3>

<ol>
  <li>
    <p>struct kmem_cache</p>

    <pre><code class="language-C">    
struct kmem_cache {
    // Per-CPU cache data:
    struct kmem_cache_cpu __percpu *cpu_slab;
    // Per-node cache data:
    struct kmem_cache_node *node[MAX_NUMNODES];
    ...
    const char *name; // Cache name
    slab_flags_t flags; // Cache flags
    unsigned int object_size; // Size of objects
    unsigned int offset; // Freelist pointer offset
    unsigned long min_partial;
    unsigned int cpu_partial_slabs;
};
    
</code></pre>

    <p>比较关键的几个成员变量：</p>

    <p>name: 内核有许多不同的caches，可以通过 <code class="language-plaintext highlighter-rouge">cat /proc/slabinfo</code> 查看其中name就是第一列的名字，该name通过kmem_cache_create的参数指定</p>

    <p>object_size: 也是通过kmem_cache_create的参数指定，每一个cache只可以分配固定大小的内存。</p>

    <p>cpu_slab:
SLUB分配器为每个CPU核心分配独立的kmem_cache_cpu结构，保存系统内特定cpu绑定的slab信息，目的是避免多核并发访问时的锁竞争。每个核心通过自己的kmem_cache_cpu直接从本地缓存分配内存对象。其内的slabs是绑定到特定CPU上的slab。在6.8版本以前也被称为froze  slabs，当CPU分配内存的时候，首先会从这些slabs中分配。</p>

    <p>node：是为每个NUMA节点保存slab信息。NUMA的核心思想是把CPU分组，来简化资源的分配的复杂性。相当于拥有一个全局的slabs列表，尚未绑定到任何CPU，但是也仍然属于cache，也会包含已经分配的objects。</p>

    <p>结构体详情：</p>

    <pre><code class="language-C">    
struct kmem_cache_cpu {
    struct slab *slab;    // Active slab
    struct slab *partial; // Partial slabs
    ...
};
struct kmem_cache_node {
    struct list_head partial; // Slabs
    ...
};
    
</code></pre>
  </li>
  <li>
    <p>per-CPU</p>

    <p>对于 <code class="language-plaintext highlighter-rouge">struct slab</code> 的简化信息：</p>

    <pre><code class="language-C">  struct slab {  // Aliased with struct page
      struct kmem_cache *slab_cache; // Cache this slab belongs to
      struct slab *next; // Next slab in per-cpu list
      int slabs; // Slabs left in per-cpu list
      struct list_head slab_list; // List links in per-node list
      void *freelist; // Per-slab freelist
      ...
};
    
</code></pre>

    <p>slab是一个 struct slab 的结构体，上述是简化的版本，struct slab 别名为struct page，提到这就不得不提一下历史了，在Linux内核5.17版本中，struct slab被引入，目的是将slab相关的字段从struct page中分离出来。struct page（每一个物理页面都有一个相应的page对应）之前包含了很多不同用途的字段，使用union来适应不同场景，导致结构复杂。现在struct slab作为struct page的一个overlay，共享同一块内存，但隐藏了struct page的细节，这样slab分配器只需要处理自己的结构。</p>

    <p>slab_cache指向自己属于的cache。</p>

    <p>每一个slab都有后备内存，后备内存是通过page_alloc想buddy system分配。不需要指针指向它，struct slab本身就是一个struct page</p>

    <p>包含object slots，<a href="https://elixir.bootlin.com/linux/v6.6/source/mm/slub.c#L4137">size</a>是基于objects大小计算出来的。</p>

    <p>freelist指针指向第一个slab中free的slot，下一个free slot的指针被保存在free slot中。freelist最后一个指针是NULL，objects都是从链表头分配，free也是插入链表头。</p>

    <p>full slabs是指没有free slot的slab，此时它的freelist 指针是NULL。</p>

    <p>多个slab可以用链表结构串联在一起。per-CPU的是单链表， <code class="language-plaintext highlighter-rouge">struct slab</code> 中的 <code class="language-plaintext highlighter-rouge">next</code> 指针，per-node的是双链表， <code class="language-plaintext highlighter-rouge">struct slab</code> 中的 <code class="language-plaintext highlighter-rouge">list_head slab_list</code> 。</p>
  </li>
  <li>
    <p>active slab</p>

    <p>先来看下kmem_cache_cpu的active slab，per-CPU的slabs的其中之一被设计成激活的，并把slab成员指针赋值为该slab。分配object的时候会首先从这个slab中分配。</p>

    <p>active slab有两个freelists。 <code class="language-plaintext highlighter-rouge">kmem_cache_cpu-&gt;freelist</code> 和 <code class="language-plaintext highlighter-rouge">kmem_cache_cpu-&gt;slab-&gt;freelist</code> 都指向它的slots。但是两个链表并不相交，
<code class="language-plaintext highlighter-rouge">kmem_cache_cpu-&gt;freelist</code> 用来给绑定的CPU分配释放内存的。</p>

    <p><code class="language-plaintext highlighter-rouge">kmem_cache_cpu-&gt;slab-&gt;freelist</code> 被用来给其他CPUs分配释放内存的（这个模块的代码有可能不只在一个cpu上运行，可能会在任务切换过程中跑到其他cpu上执行了）。</p>
  </li>
  <li>
    <p>partial slabs</p>

    <p>partial意思是这些slab有空闲slot（至少有一个，也有可能是fully free）。</p>

    <p>每个partial slabs都有后备内存。</p>

    <p>只有一个freelist，</p>

    <p>只在active slab变为full后被使用。</p>

    <p>per-CPU partial slabs的列表最大数量是有限的，这个大小是由kmem_cache-&gt;cpu_partial_slabs字段指定，这个值是根据object和slab的大小计算出来的<a href="https://elixir.bootlin.com/linux/v6.6/source/mm/slub.c#L4364">link</a> 用户空间是无法查看这个字段值的，只能查看 <code class="language-plaintext highlighter-rouge">/sys/kernel/slab/$CACHE/cpu_partial</code> ，然后自己计算出cpu_partial_slabs。</p>
  </li>
  <li>
    <p>per-node</p>

    <p>kmem_cache_node 有一个per-node partial slabs的列表。这就意味这每一个都至少有一个free slots。</p>

    <p>每一个都有后备内存和一个freelist。</p>

    <p>一旦per-CPU中的slabs都用完都变成full后他们就会被使用。</p>

    <p>per-node slabs 的最小数量也是有限制的。由kmem_cache-&gt;min_partial指定， 计算也是基于object的大小<a href="https://elixir.bootlin.com/linux/v6.6/source/mm/slub.c#L4543">link</a></p>

    <p>可以在用户空间中查看 <code class="language-plaintext highlighter-rouge">/sys/kernel/slab/$CACHE/min_partial</code></p>
  </li>
  <li>
    <p>full slabs</p>

    <p>full slabs 不会被tracked。没有指针指向full slabs（除非开启slub_debug），一旦任意一个object被释放到full slab中，分配器会获得指向该slab的指针。我们只需使用<a href="https://elixir.bootlin.com/linux/v6.6/source/mm/slab.h#L211">virt_to_slab</a>计算。</p>
  </li>
</ol>

<h3 id="分配过程">分配过程</h3>

<p>为了方便介绍，这里分为五个不同层次的分配过程</p>

<ol>
  <li>
    <ol>
      <li>allocating from lockless per-CPU freelist kmem_cache_cpu-&gt;freelist</li>
    </ol>

    <p>当无锁的该cpu slab的freelist是不为空，那么就会分配该freelist的第一个object</p>

    <p>如果为空，goto 2。</p>
  </li>
  <li>
    <ol>
      <li>allocating from active slab (kmem_cache_cpu-&gt;slab-&gt;freelist)</li>
    </ol>

    <p>如果active slab freelist不是空的，</p>

    <p>首先move active slab freelist到 lockless per-CPU freelist；<a href="https://elixir.bootlin.com/linux/v6.6/source/mm/slub.c#L3151">link</a></p>

    <p>然后从这个lockless的per-CPU freelist分配第一个object。<a href="https://elixir.bootlin.com/linux/v6.6/source/mm/slub.c#L3176">link</a>并更新这个freelist<a href="https://elixir.bootlin.com/linux/v6.6/source/mm/slub.c#L3173">link</a></p>

    <p>如果这个active slab freelist为空。 goto 3<a href="https://elixir.bootlin.com/linux/v6.6/source/mm/slub.c#L3158">link</a></p>
  </li>
  <li>
    <ol>
      <li>allocating from per-CPU partial slabs (kmem_cache_cpu-&gt;partial)</li>
    </ol>

    <p>如果有per-CPU的partial slabs：</p>

    <p>首先将链表中的第一个脱链，并指定为active slabs <a href="https://elixir.bootlin.com/linux/v6.6/source/mm/slub.c#L3206">link</a></p>

    <p>goto 2<a href="https://elixir.bootlin.com/linux/v6.6/source/mm/slub.c#L3210">link</a></p>

    <p>如果per-CPU的partial slabs是空的</p>

    <p>goto 4<a href="https://elixir.bootlin.com/linux/v6.6/source/mm/slub.c#L3213">link</a></p>
  </li>
  <li>
    <ol>
      <li>allocating from per-node partial slabs (kmem_cache_node-&gt;partial)</li>
    </ol>

    <p>如果有per-node的partial slabs：
首先将链表中的第一个脱链，并指定为active slabs<a href="https://elixir.bootlin.com/linux/v6.6/source/mm/slub.c#L2309">link</a>；然后移动一些(最多cpu_partial_slabs / 2<a href="https://elixir.bootlin.com/linux/v6.6/source/mm/slub.c#L2319">link</a>)per-node的slabs到per-CPU的partial list<a href="https://elixir.bootlin.com/linux/v6.6/source/mm/slub.c#L2313">link</a>；再去active slab重新分配。<a href="https://elixir.bootlin.com/linux/v6.6/source/mm/slub.c#L3220">link</a></p>

    <p>如果per-node partial list 为空，goto 5</p>
  </li>
  <li>
    <ol>
      <li>Create new slab</li>
    </ol>

    <p><a href="https://elixir.bootlin.com/linux/v6.6/source/mm/slub.c#L3223">allocate</a> from new slab的过程：</p>

    <p>首先从page_alloc中分配新的slab，并放进freelist中，并指定为active slab，然后从该slab中分配对象。</p>
  </li>
</ol>

<h3 id="explotion-case">explotion case</h3>

<ol>
  <li>
    <p>Out-of-bounds, case #1 (Shaping Slab memory)</p>

    <p>攻击所需条件：</p>

    <ol>
      <li>需要一个内核bug能导致OOB；</li>
      <li>有两个不同的系统调用，一个可以分配object(IOCTL_ALLOC)，一个可以OOB(IOCTL_OOB)；</li>
      <li>能够leak或者overwrite的目标object；</li>
      <li>能将可利用的object和targetobject挨着放在一起。</li>
    </ol>

    <p>攻击过程：</p>

    <ol>
      <li>
        <p>allocate 足够的targt objects 来获取新的active slab；需要填充所有的holes达到分配过程的第五步。</p>

        <p>所以我们就需要找到有多少个holes。
但是在非特权的目标系统上，没有方法能够找到确切的数目。 <code class="language-plaintext highlighter-rouge">/proc/slabinfo</code> 和相关文件对于普通用户不可读。</p>

        <p>而且我们可能拥有的空闲插槽数量没有上限，原因是atcive slab上的holes数量最多有每一个slab上的objects的数目。
per-CPU partials的holes数量上限是每一个slab上的objects的数目 x cpu_partial_slabs。
per-node partials的没有限制slabs的数量。</p>
      </li>
    </ol>
  </li>
</ol>

<p>所以一种方式是估计，首先重现目标环境，运行相同的版本内核，运行相同的软件，然后我们通过 <code class="language-plaintext highlighter-rouge">cat /proc/slabinfo</code> 看有多少个holes。</p>

<p>还有一种<a href="https://stefangast.eu/papers/slubstick.pdf">基于时间信道</a>的方式。</p>

<table>
  <thead>
    <tr>
      <th>name</th>
      <th>&lt;active_objs&gt;</th>
      <th>&lt;num_objs&gt;</th>
      <th><objsize></objsize></th>
      <th><objperslab></objperslab></th>
      <th><pagesperslab></pagesperslab></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>cred_jar</td>
      <td>7644</td>
      <td>7644</td>
      <td>192</td>
      <td>21</td>
      <td>1</td>
    </tr>
    <tr>
      <td>kmalloc-8k</td>
      <td>456</td>
      <td>460</td>
      <td>8192</td>
      <td>4</td>
      <td>8</td>
    </tr>
    <tr>
      <td>kmalloc-4k</td>
      <td>3118</td>
      <td>3160</td>
      <td>4096</td>
      <td>8</td>
      <td>8</td>
    </tr>
    <tr>
      <td>kmalloc-2k</td>
      <td>3621</td>
      <td>3696</td>
      <td>2048</td>
      <td>16</td>
      <td>8</td>
    </tr>
    <tr>
      <td>kmalloc-32</td>
      <td>54789</td>
      <td>55808</td>
      <td>32</td>
      <td>128</td>
      <td>1</td>
    </tr>
  </tbody>
</table>

<p>active_objs: 已经分配的objects的数量，
num_objs: 现存slab中的slots的总数。
这个值不是实时更新的，只有在一个slab被分配，释放或者移动到per-node partial list时才会更新。</p>

<p>Shrink cache 可以获得更准确的值，</p>

<p><code class="language-plaintext highlighter-rouge">echo 1 | sudo tee /sys/kernel/slab/kmalloc-32/shrink</code></p>

<p>但是这样会导致这个cache释放fully free slabs。</p>

<table>
  <thead>
    <tr>
      <th># name</th>
      <th>&lt;active_objs&gt;</th>
      <th>&lt;num_objs&gt;</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>kmalloc-32</td>
      <td>25216</td>
      <td>25216     // Before shrinking.</td>
    </tr>
    <tr>
      <td>kmalloc-32</td>
      <td>23132</td>
      <td>24320     // After shrinking.</td>
    </tr>
  </tbody>
</table>

<p>比如这个就少了1000多个，这个就是不准确的，即是我们复制来环境也不准确。</p>

<ol>
  <li>
    <p>现在假设我们分配了足够的target objects并获得了一个新的active slab。并且新的active slab被target objects填充一部分；</p>
  </li>
  <li>
    <p>现在通过IOCTL_ALLOC操作分配一个vulnerable object；
现在分配足够的target objects填满active slab。现在slab变成full，尽管可能会变成非active，但是没关系。</p>

    <p>现在内存看起来是这样：</p>

    <pre><code class="language-C">+-------+-------+-------+-------+-------+-------+-------+-------+
| Target| Target| Target| Vuln  | Target| Target| Target| Target|
+-------+-------+-------+-------+-------+-------+-------+-------+
    
</code></pre>
  </li>
  <li>
    <p>现在通过IOCTL_OOB触发越界访问。</p>
  </li>
</ol>

<pre><code class="language-C">+-------+-------+-------+-------+-------+-------+-------+-------+
| Target| Target| Target| Vuln  | Target| Target| Target| Target|
+-------+-------+-------+-------+-------+-------+-------+-------+
                            |_______| OOB
</code></pre>

<p>（注：如果没有第一步，我们就无法破坏target，并且可能会破坏内核其他数据，后果不可控。所以第一步是为了explition的稳定。
除此之外这个exp也有一些问题，比如:
如果vuln被allocated到最后一个object，这就有概率会失败。解决的办法就是在其后多分配一个slab，然后填充target。
Migration: 进程被移动到另一个CPU上执行了。解决办法：绑定CPU的亲和性
Preempting: 另一个进程或者中断处理来抢占此CPU，解决方法：减少slab shaping的时间；使用less noisy（不那么频繁） 的cache。）</p>

<ol>
  <li>
    <p>Out-of-bounds, case #2 （Shaping Slab memory）</p>

    <p>需要条件：分配vulnerable objects并且立即写数据触发OOB（IOCTL_ALLOC_AND_OOB），</p>

    <p>攻击过程：</p>

    <ol>
      <li>
        <p>分配足够多的target objects以获得新的 active slab；</p>
      </li>
      <li>
        <p>分配一个vulnerable object并且触发OOB通过IOCTL_ALLOC_AND_OOB，</p>

        <p>这有两种情况，
case #1: OOB访问的区域在free slot中，如果OOB的范围很小，没有覆盖元数据，则不会发生任何事情。可以重复进行OOB操作。</p>

        <pre><code class="language-C">+-------+-------+-------+-------+-------+-------+-------+-------+
| Target|       | Target| Vuln  |       | Target| Target| Target|
+-------+-------+-------+-------+-------+-------+-------+-------+
                            |_______| OOB
</code></pre>
      </li>
    </ol>
  </li>
</ol>

<p>case #2: OOB访问的区域在target object中</p>

<p>Success！！！ 但是也许需要很多次重试才能成功</p>

<pre><code class="language-C">+-------+-------+-------+-------+-------+-------+-------+-------+
| Target|       | Target| Vuln  | Target| Target| Target| Target|
+-------+-------+-------+-------+-------+-------+-------+-------+
                            |_______| OOB
</code></pre>

<h3 id="freeing-process-and-explition">Freeing process and explition</h3>

<ol>
  <li>
    <p>case #1: object 属于active slab，</p>

    <p>object加入无锁的per-CPU的freelist的头部。<a href="https://elixir.bootlin.com/linux/v6.6/source/mm/slub.c#L3766">link</a></p>

    <p>想象一种场景:</p>

    <pre><code class="language-C">void *ptr1 = kmalloc(128, GFP_KERNEL);
free(ptr1);
void *ptr2 = kmalloc(128, GFP_KERNEL);
free(ptr2);
void *ptr3 = kmalloc(128, GFP_KERNEL);
    
</code></pre>

    <p>ptr1，ptr2，ptr3都指向同一个object。</p>

    <p>所以这就引出第一种利用场景(UAF)</p>

    <p>所需条件：假设我们有UAF的漏洞：</p>

    <ol>
      <li>
        <p>分配vulnerable object （IOCTL_ALLOC）</p>
      </li>
      <li>
        <p>free vulnerable object （IOCTL_FREE）</p>
      </li>
      <li>
        <p>在IOCTL_FREE后，读写vulnerable object的数据，（IOCTL_UAF）</p>
      </li>
    </ol>

    <p>攻击过程：</p>

    <ol>
      <li>
        <p>通过IOCTL_ALLOC分配一个vulnerable object，</p>
      </li>
      <li>
        <p>通过IOCTL_FREE free vulnerable object，悬空引用仍然存在；</p>
      </li>
      <li>
        <p>分配一个target object，现在那个悬空指针指向它；</p>
      </li>
      <li>
        <p>现在能够使用IOCTL_UAF触发UAF访问。</p>
      </li>
    </ol>
  </li>
  <li>
    <p>case #2: object属于一个non-full slab</p>

    <p>free object到所属的freelist之中。<a href="https://elixir.bootlin.com/linux/v6.6/source/mm/slub.c#L3661">link</a></p>

    <p>如果slab是per-node的，并且变成了fully free，并且node有足够的per-node slabs。该slab会被从per-node中移除并<a href="https://elixir.bootlin.com/linux/v6.6/source/mm/slub.c#L3687">free</a>回page allocator中。</p>

    <p>如果object属于non-full non-current-active slab：<a href="https://elixir.bootlin.com/linux/v6.6/source/mm/slub.c#L3661">free</a>object 到slab freelist中可能会[free] (<a href="https://elixir.bootlin.com/linux/v6.6/source/mm/slub.c#L3687">https://elixir.bootlin.com/linux/v6.6/source/mm/slub.c#L3687</a>)per-node的full slab，但是<a href="https://elixir.bootlin.com/linux/v6.6/source/mm/slub.c#L3666">不适用于</a>per-CPU partial或者active slabs（即使变成full free也不会free回page_alloca，仍然待在相应列表中）</p>

    <p>如果object属于另一个CPU的active slab，将会把它放到active slab的freelist（不是per-CPU的freelist）中<a href="https://elixir.bootlin.com/linux/v6.6/source/mm/slub.c#L3661">link</a>。</p>
  </li>
  <li>
    <p>case #3: object 属于full slab</p>

    <p><a href="https://elixir.bootlin.com/linux/v6.6/source/mm/slub.c#L3661">free</a> object 到slab fresslist</p>

    <p><a href="https://elixir.bootlin.com/linux/v6.6/source/mm/slub.c#L3679">move</a> slab到per-CPU的partial list：</p>

    <p>如果per-CPU的partial list<a href="https://elixir.bootlin.com/linux/v6.6/source/mm/slub.c#L2716">没满</a>（&lt;cpu_partial_slabs），就把它放到链表头中。</p>

    <p>如果per-CPU的partial list已经<a href="https://elixir.bootlin.com/linux/v6.6/source/mm/slub.c#L2708">满了</a>（&gt;=cpu_partial_slabs），free_up per-CPU partial list遍历链表并执行执行以下操作</p>

    <p><a href="https://elixir.bootlin.com/linux/v6.6/source/mm/slub.c#L2642">Move</a> per-CPU slabs 到per-node list的尾部，</p>

    <p><a href="https://elixir.bootlin.com/linux/v6.6/source/mm/slub.c#L2655">free</a> full freed per-CPU slabs 到page_alloc中（可用于cross-cache的攻击）</p>

    <p>直到per-node 的slabs的数量达到min_partial</p>

    <p>现在per-CPU的partial list有空间了，将该slab<a href="https://elixir.bootlin.com/linux/v6.6/source/mm/slub.c#L2726">放进</a>链表头中</p>
  </li>
</ol>

<h3 id="explition-case">explition case</h3>

<ol>
  <li>
    <p>OOB变UAF</p>

    <p>所需条件：1)分配vulnerable object（IOCTL_ALLOC）</p>

    <p>2)可以越界向vulnerable object写数据。</p>
  </li>
</ol>

<p>攻击流程：slab已经经过我们的shaping成full slab，并且有一个OOB的vuln object。如果我们现在有一个Vuln的object可以OOB，我们把它在内存上挨着的下一个object视为target object，target object有引用计数之类的东西，通过溢出后就可以控制引用计数，原来的程序会在错误的时机free target object然后我们就可以将target object变成一个UAF。并且该slab会被添加到per-CPU的partial list的头部</p>

<p>（注：在shaping slab的时候，我们可以用slab spraying的方式：分配很多的objects，所以问题就是我们需要spray多少个object，这个数量需要根据实际情况来看。）</p>

<ol>
  <li>
    <p>allocation和OOB组合在一起</p>

    <p>所需条件：1) allocate vulnerable object并且立即写入OOB数据（IOCTL_ALLOC_AND_OOB）</p>

    <p>攻击流程：</p>

    <ol>
      <li>
        <p>分配足够的target objects能获取新的active slab，</p>
      </li>
      <li>
        <p>分配更多的target objects去填充这个slab，直到slab变成full，</p>
      </li>
      <li>
        <p>从这个slab中free一个target object，</p>
      </li>
      <li>
        <p>现在我们重新使用这个free slot，并且使用IOCTL_ALLOC_AND_OOB去溢出内存中挨着的下一个targe object。</p>
      </li>
    </ol>
  </li>
  <li>
    <p>double-free</p>

    <p><code class="language-plaintext highlighter-rouge">CONFIG_SLAB_FREELIST_HARDENED=y</code> 开启这个编译选项后，double-free会被<a href="https://elixir.bootlin.com/linux/v6.6/source/mm/slub.c#L448">检测</a>到</p>
  </li>
</ol>

<h3 id="总结">总结</h3>

<p>slub机制是十分复杂的，并且其中还有很多的情况和优化需要考虑，本文只是浅浅涉猎一下。</p>

<p><a href="https://elixir.bootlin.com/linux/v6.6/source/mm/slub.c">SLUB source</a></p>

<p><a href="https://elixir.bootlin.com/linux/v6.6/source/mm/slub.c#L3329">__slab_alloc_node</a>allocation 过程开始的地方</p>

<p><a href="https://elixir.bootlin.com/linux/v6.6/source/mm/slub.c#L3734">do_slab_free</a>free 过程开始的地方</p>

<h3 id="拓展阅读">拓展阅读</h3>

<p><a href="https://arxiv.org/pdf/2406.02624">Freeing free slot via double-free can be used for cross-cache attacks</a></p>

<p>More details about how SLUB works:<a href="https://blogs.oracle.com/linux/post/linux-slub-allocator-internals-and-debugging-1">Linux SLUB Allocator Internals and Debugging</a><a href="https://lore.kernel.org/linux-mm/c71a884d-714f-4741-906f-4df162bde303@suse.cz/">note</a></p>

<p>About cache merging, accounting, and hardened usercopy:<a href="https://duasynt.com/blog/linux-kernel-heap-feng-shui-2022">Linux kernel heap feng shui in 2022</a></p>

<p>Introduction to cross-cache use-after-free attacks:<a href="https://ruia-ruia.github.io/2022/08/05/CVE-2022-29582-io-uring/">CVE-2022-29582, An io_uring vulnerability</a></p>

<p>Improving reliability of Slab shaping:</p>

<p><a href="https://haehyun.github.io/papers/playing-for-keaps-22-sec.pdf">Playing for K(H)eaps: Understanding and Improving Linux Kernel Exploit Reliability</a></p>

<p><a href="https://www.usenix.org/system/files/sec23summer_79-lee-prepub.pdf">PSPRAY: Timing Side-Channel based
Linux Kernel Heap Exploitation Technique</a></p>

<p><a href="https://stefangast.eu/papers/slubstick.pdf">SLUBStick: Arbitrary Memory Writes through
Practical Software Cross-Cache Attacks within the Linux Kernel</a></p>

<h3 id="参考链接">参考链接</h3>

<p><a href="https://www.youtube.com/watch?v=XulsBDV4n3w">SLUB演讲视频连接</a></p>

<p><a href="https://static.sched.com/hosted_files/lsseu2024/37/2024,%20LSS%20EU_%20SLUB%20Internals%20for%20Exploit%20Developers.pdf">PPT</a></p>]]></content><author><name>樵夫砍柴手札</name><email>p1ain0@outlook.com</email></author><category term="PWN,linux" /><category term="PWN,linux" /><summary type="html"><![CDATA[本篇文章详细介绍linux内核的内存管理，主要分为两部分，介绍伙伴算法和slab分配器-SLUB的工作机制，重点放在后面部分。]]></summary></entry><entry><title type="html">aliyunctf2025</title><link href="http://localhost:4000/aliyunctf2025/" rel="alternate" type="text/html" title="aliyunctf2025" /><published>2025-02-27T00:00:00+08:00</published><updated>2025-02-27T00:00:00+08:00</updated><id>http://localhost:4000/aliyunctf2025</id><content type="html" xml:base="http://localhost:4000/aliyunctf2025/"><![CDATA[<p>记录下从2025 aliyunctf中学到的新东西：</p>

<h2 id="pwn1---beebee学习ebpf的exploit">pwn1 - beebee：学习eBPF的exploit</h2>

<p>通过这个题目学习下eBPF安全方面内容。</p>

<p>eBPF(extended Berkeley Packet Filter)，是一个基于寄存器的虚拟机，使用自定义的64位RISC指令集，能够在linux内核中运行JIT原生编译的BPF程序，并访问内核功能和内存的子集。它是主线内核的一部分，不需要像其他框架那样( LTTng or SystemTap)的第三方模块，并且在所有的linux发行版中都默认启用。
在内核内运行完整虚拟机的目的主要是为了便利和安全，虽然eBPF可以完成的操作都可以通过普通内核模块处理，但是直接内核编程是很危险的，可能会造成整个系统的崩溃。因此通过虚拟机运行字节码对安全监控，沙盒，网络过滤，程序跟踪，分析，调试等很有价值。<a href="https://www.brendangregg.com/ebpf.html">ex</a></p>

<p>eBPF VM的设计不允许循环，因此可以保证每个eBPF程序都能执行完，不会有死循环的情况，而且所有的内存访问都是有边界检查和属性检查的。eBPF刚开始只用于过滤网络数据包。从linux-3.18开始，虚拟机就可以通过bpf()系统调用与用户层交互，当时存在的指令集成为公共ABI，后面仍然可以添加新指令。</p>

<p>eBPF的运行原理：</p>

<ol>
  <li>用户空间的程序发送bytecode（eBPF VM字节码）到内核中。</li>
  <li>内核会对eBPF程序进行一次检查（kernel/bpf/verifier.c）。</li>
  <li>内核将字节码使用JIT机制 编译为机器码，并将附加到指定的位置。</li>
  <li>插入的代码将数据写入ringbuffers或key-value maps。</li>
  <li>用户空间从共享maps或ringbuffers中读取结果。
（ringbuffers和maps由内核管理，独立于程序。需要通过文件描述符异步访问。）</li>
</ol>

<p>事件可以从kprobes/uprobes、tracepoints、dtrace probes、sockets等中生成。当事件发生时，eBPF程序由内核运行，可以理解为一种函数挂钩或者事件驱动编程。这允许在内核和用户进程中的任何指令上连接和检查任何功能中的内存，拦截文件操作，检查特定的网络数据包等。</p>

<p>用户层编写程序可以通过libbpf库，其中包含bpf_load_program等syscall函数的包装器和一些数据结构的定义。linux源码的samples/bpf/目录下有很多使用示例。</p>

<p>eBPF架构设计：</p>

<p>cBPF是32位架构，但eBPF是 64 位架构，</p>

<table>
  <thead>
    <tr>
      <th>BPF寄存器</th>
      <th>对应的x64寄存器</th>
      <th>作用</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>R0</td>
      <td>rax</td>
      <td>函数调用结束储存返回值，当前程序推退出码</td>
    </tr>
    <tr>
      <td>R1</td>
      <td>rdi</td>
      <td>作为函数调用参数使用，</td>
    </tr>
    <tr>
      <td>R2</td>
      <td>rsi</td>
      <td> </td>
    </tr>
    <tr>
      <td>R3</td>
      <td>rdx</td>
      <td> </td>
    </tr>
    <tr>
      <td>R4</td>
      <td>rcx</td>
      <td> </td>
    </tr>
    <tr>
      <td>R5</td>
      <td>r8</td>
      <td> </td>
    </tr>
    <tr>
      <td>R6</td>
      <td>rbx</td>
      <td>被保留函数内部使用</td>
    </tr>
    <tr>
      <td>R7</td>
      <td>r13</td>
      <td> </td>
    </tr>
    <tr>
      <td>R8</td>
      <td>r14</td>
      <td> </td>
    </tr>
    <tr>
      <td>R9</td>
      <td>r15</td>
      <td> </td>
    </tr>
    <tr>
      <td>R10</td>
      <td>rbp</td>
      <td>只读寄存器，指向512byte大小的栈空间</td>
    </tr>
  </tbody>
</table>

<p>每个函数调用在寄存器r1-r5中最多可以有5个参数；寄存器r1-r5只能存储堆栈的数字或指针（作为参数传递给函数），永远不会将指针指向任意内存。所有内存访问必须先将数据加载到eBPF堆栈，然后再在eBPF程序中使用。此限制有助于eBPF验证器，简化内存模型。</p>

<p>指令集：</p>

<p>普通用户的BPF程序，最多可以使用4096个指令。root用户的话，最多可以加载100万个指令。因为BPF是RISC架构，所以指令是定长的64位</p>

<table>
  <thead>
    <tr>
      <th>比特</th>
      <th>名字</th>
      <th>意义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0-7</td>
      <td>op</td>
      <td>操作码</td>
    </tr>
    <tr>
      <td>8-11</td>
      <td>dst_reg</td>
      <td>目的寄存器</td>
    </tr>
    <tr>
      <td>12-15</td>
      <td>src_reg</td>
      <td>源寄存器</td>
    </tr>
    <tr>
      <td>16-31</td>
      <td>off</td>
      <td>偏移</td>
    </tr>
    <tr>
      <td>32-63</td>
      <td>imm</td>
      <td>立即数</td>
    </tr>
  </tbody>
</table>

<p>程序类型：</p>

<p>在加载时需要指定BPF程序的用途。cBPF中只有2种类型：套接字过滤器和系统调用过滤器，但eBPF提供了20多种类型。
例如 <code class="language-plaintext highlighter-rouge">BPF_PROG_TYPE_SOCKET_FILTER</code> 是套接字过滤器，根据BPF程序的返回值，可以进行丢弃数据包等操作。这种类型的BPF程序，通过SO_ATTACH_BPF选项调用setsockopt系统调用，可以附加到套接字上。</p>

<p>辅助函数：
eBPF设计的一套安全的扩展功能的模式。字节码程序能做的事情毕竟有限，这时我们可以通过添加辅助函数来扩展其功能，然后在VM中调用。当然其内部也有很多已经写好的辅助函数，我们可以直接调用。</p>

<p>辅助函数可以通过 <code class="language-plaintext highlighter-rouge">struct bpf_func_proto</code> 结构体描述了自身的定义、入参类型、返回值类型等。验证器可以通过这个结构体描述的信息来检查，传入的参数是否合法。比较复杂的就是指针类型的参数了。指针有类型信息，范围信息，访问权限信息，对齐信息……</p>

<p>普通用户是否可以使用bpf有个开关。可以通过/proc/sys/kernel/unprivileged_bpf_disabled控制。</p>

<p>关于开发的学习资源：</p>

<p>(<a href="https://www.collabora.com/news-and-blog/blog/2019/04/05/an-ebpf-overview-part-1-introduction/">https://www.collabora.com/news-and-blog/blog/2019/04/05/an-ebpf-overview-part-1-introduction/</a>)</p>

<p>(<a href="https://mem2019.github.io/jekyll/update/2021/07/19/GCTF2021-eBPF.html">https://mem2019.github.io/jekyll/update/2021/07/19/GCTF2021-eBPF.html</a>)</p>

<p>(<a href="https://stdnoerr.github.io/writeup/2022/08/21/eBPF-exploitation-(ft.-D-3CTF-d3bpf).html">https://stdnoerr.github.io/writeup/2022/08/21/eBPF-exploitation-(ft.-D-3CTF-d3bpf).html</a>)</p>

<p>(<a href="https://www.brendangregg.com/ebpf.html">https://www.brendangregg.com/ebpf.html</a>)</p>

<p>(<a href="https://www.brendangregg.com/blog/2018-10-08/dtrace-for-linux-2018.html">https://www.brendangregg.com/blog/2018-10-08/dtrace-for-linux-2018.html</a>)</p>

<p>(<a href="https://guide.996station.com/#/ebpf-guide/eBPF基础/计算机领域最有前途基础软件技术eBPF">https://guide.996station.com/#/ebpf-guide/eBPF基础/计算机领域最有前途基础软件技术eBPF</a>)</p>

<p>介绍了这么多，来看看这个题目：</p>

<p>先看patch文件:</p>

<pre><code class="language-C">
diff --color -ruN origin/include/linux/bpf.h aliyunctf/include/linux/bpf.h
--- origin/include/linux/bpf.h	2025-01-23 10:21:19.000000000 -0600
+++ aliyunctf/include/linux/bpf.h	2025-01-24 03:44:01.494468038 -0600
@@ -3058,6 +3058,7 @@
 extern const struct bpf_func_proto bpf_user_ringbuf_drain_proto;
 extern const struct bpf_func_proto bpf_cgrp_storage_get_proto;
 extern const struct bpf_func_proto bpf_cgrp_storage_delete_proto;
+extern const struct bpf_func_proto bpf_aliyunctf_xor_proto;

 const struct bpf_func_proto *tracing_prog_func_proto(
   enum bpf_func_id func_id, const struct bpf_prog *prog);
diff --color -ruN origin/include/uapi/linux/bpf.h aliyunctf/include/uapi/linux/bpf.h
--- origin/include/uapi/linux/bpf.h	2025-01-23 10:21:19.000000000 -0600
+++ aliyunctf/include/uapi/linux/bpf.h	2025-01-24 03:44:11.814636836 -0600
@@ -5881,6 +5881,7 @@
        FN(user_ringbuf_drain, 209, ##ctx)		\
        FN(cgrp_storage_get, 210, ##ctx)		\
        FN(cgrp_storage_delete, 211, ##ctx)		\
+	FN(aliyunctf_xor, 212, ##ctx)		\
        /* */

 /* backwards-compatibility macros for users of __BPF_FUNC_MAPPER that don't
diff --color -ruN origin/kernel/bpf/helpers.c aliyunctf/kernel/bpf/helpers.c
--- origin/kernel/bpf/helpers.c	2025-01-23 10:21:19.000000000 -0600
+++ aliyunctf/kernel/bpf/helpers.c	2025-01-24 03:44:06.683490095 -0600
@@ -1745,6 +1745,28 @@
        .arg3_type	= ARG_CONST_ALLOC_SIZE_OR_ZERO,
 };

+BPF_CALL_3(bpf_aliyunctf_xor, const char *, buf, size_t, buf_len, s64 *, res) {
+	s64 _res = 2025;
+
+	if (buf_len != sizeof(s64))
+		return -EINVAL;
+
+	_res ^= *(s64 *)buf;
+	*res = _res;
+
+	return 0;
+}
+
+const struct bpf_func_proto bpf_aliyunctf_xor_proto = {
+	.func		= bpf_aliyunctf_xor,
+	.gpl_only	= false,
+	.ret_type	= RET_INTEGER,
+	.arg1_type	= ARG_PTR_TO_MEM | MEM_RDONLY,
+	.arg2_type	= ARG_CONST_SIZE,
+	.arg3_type	= ARG_PTR_TO_FIXED_SIZE_MEM | MEM_UNINIT | MEM_ALIGNED | MEM_RDONLY,
+	.arg3_size	= sizeof(s64),
+};
+
 const struct bpf_func_proto bpf_get_current_task_proto __weak;
 const struct bpf_func_proto bpf_get_current_task_btf_proto __weak;
 const struct bpf_func_proto bpf_probe_read_user_proto __weak;
@@ -1801,6 +1823,8 @@
                return &amp;bpf_strtol_proto;
        case BPF_FUNC_strtoul:
                return &amp;bpf_strtoul_proto;
+	case BPF_FUNC_aliyunctf_xor:
+		return &amp;bpf_aliyunctf_xor_proto;
        default:
                break;
        }


</code></pre>

<p>这种题目需要知道eBPF的机制，并且熟悉它的基础设施，才能完成对它的攻击，以前没有遇到过，现在正好根据官方的writeup来学习下这方面的内容。使用的是内核6.6.74版本的源码，新增辅助函数 <code class="language-plaintext highlighter-rouge">bpf_aliyunctf_xor</code> 函数编号212，然后 <code class="language-plaintext highlighter-rouge">bpf_aliyunctf_xor_proto</code> 定义了参数的类型，属性的一些信息，第三个参数是一个指针类型。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c">#0  check_mem_access (env=0xffff888004b58000, insn_idx=0x1, regno=0xa, off=0x6, bpf_size=0x18, t=BPF_WRITE, </span>
    <span class="nv">value_regno</span><span class="o">=</span>&lt;error reading variable: Cannot access memory at address 0x0&gt;, 
    <span class="nv">strict_alignment_once</span><span class="o">=</span>&lt;error reading variable: Cannot access memory at address 0x8&gt;, 
    <span class="nv">is_ldsx</span><span class="o">=</span>&lt;error reading variable: Cannot access memory at address 0x10&gt;<span class="o">)</span> at kernel/bpf/verifier.c:6698
<span class="c">#1  0xffffffff812012a9 in do_check (env=&lt;optimized out&gt;) at kernel/bpf/verifier.c:17179</span>
<span class="c">#2  do_check_common (env=0xffff888004b58000, subprog=0x0) at kernel/bpf/verifier.c:19643</span>
<span class="c">#3  0xffffffff812064ba in do_check_main (env=&lt;optimized out&gt;) at kernel/bpf/verifier.c:19706</span>
<span class="c">#4  bpf_check (prog=0xffff888004b58000, attr=0x1 &lt;fixed_percpu_data+1&gt;, uattr=..., uattr_size=0x18) at kernel/bpf/verifier.c:20333</span>
<span class="c">#5  0xffffffff811df0c2 in bpf_prog_load (attr=0xffffc9000023fe58, uattr=..., uattr_size=0xfffffff0) at kernel/bpf/syscall.c:2743</span>
<span class="c">#6  0xffffffff811e196a in __sys_bpf (cmd=0x5, uattr=..., size=0x0) at kernel/bpf/syscall.c:5465</span>
<span class="c">#7  0xffffffff811e4059 in __do_sys_bpf (size=&lt;optimized out&gt;, uattr=&lt;optimized out&gt;, cmd=&lt;optimized out&gt;) at kernel/bpf/syscall.c:5569</span>
<span class="c">#8  __se_sys_bpf (size=&lt;optimized out&gt;, uattr=&lt;optimized out&gt;, cmd=&lt;optimized out&gt;) at kernel/bpf/syscall.c:5567</span>
<span class="c">#9  __x64_sys_bpf (regs=0xffff888004b58000) at kernel/bpf/syscall.c:5567</span>
<span class="c">#10 0xffffffff81f38d39 in do_syscall_x64 (nr=&lt;optimized out&gt;, regs=&lt;optimized out&gt;) at arch/x86/entry/common.c:51</span>
<span class="c">#11 do_syscall_64 (regs=0xffffc9000023ff58, nr=0x1) at arch/x86/entry/common.c:81</span>
<span class="c">#12 0xffffffff82000134 in entry_SYSCALL_64 () at arch/x86/entry/entry_64.S:121</span>
<span class="c">#13 0x0000000000000000 in ?? ()</span>

</code></pre></div></div>

<p>这里利用了eBPF只在load的时候，对有内存操作的指令进行检查，这里有一个eBPF设计上的细节，就是它的只读权限不是真的只读不可写，而是对于eBPF字节码程序不可写，它是由自己的虚拟机进行内存检查，不是依靠操作系统，但是eBPF设计了辅助函数这个机制，可以在虚拟机中调用c代码，因此如果辅助函数的设计有缺陷，可以去写某些只读区域，而虚拟机字节码如果再次使用了这部分被修改的内存，虚拟机并不会对这个引用这个数据的寄存器进行检查，这是非常危险的。</p>

<p>由于 <code class="language-plaintext highlighter-rouge">bpf_aliyunctf_xor_proto</code> 辅助函数第三个参数有个标识位为 <code class="language-plaintext highlighter-rouge">MEM_RDONLY</code> 表示参数地址可以是只读的。但是在函数实现中，这个内存地址是会被写入一个64位数据的。（刚开始我本来打算直接通过这个函数来修改内核的全局变量，发现不行诶，后来才知道，这些指针传递给辅助函数的时候是有限制的，只能是eBPF内部的某些内存。）因此这里有一种利用方式是： 我们可以利用这个设置来修改只读的maps，只读权限区域可以帮助我们找到一种控制寄存器绕过内存边界检查的方式，我们可以使用 <code class="language-plaintext highlighter-rouge">bpf_skb_load_bytes()</code> 函数来破坏堆栈，覆盖函数ret地址，然后利用rop完成攻击。</p>

<p>官方有<a href="https://xz.aliyun.com/news/17029?time__1311=n4%2BxBDcD0Du7KGKG%3DKDsf3xCqWoxRDmqmK4R5WID&amp;u_atoken=27649aed9882a7bda204f993c159b1a6&amp;u_asig=54d85">writeup</a></p>

<p>官方writeup的攻击流程就是通过向eBPF申请一个只读的map，然后通过新添加的漏洞函数将原来的值改掉，然后把这个值取出来 当 <code class="language-plaintext highlighter-rouge">bpf_skb_load_bytes()</code> 的第四个参数，因为数据是只读的，所以eBPF不会再去检查它的大小，这样就可以造成栈拷贝溢出，控制ret地址。这里还有一个细节就是刚刚进入虚拟机的时候寄存器R1被初始化为指向  <code class="language-plaintext highlighter-rouge">struct __sk_buff</code> 的指针。</p>

<p>但是用 <code class="language-plaintext highlighter-rouge">gcc exploit.c -o exp -static</code> 这种方式编出来的文件很大，当我写了个脚本把数据提取出来后，通过 <code class="language-plaintext highlighter-rouge">echo -e "" &gt; exp</code> 的方式粘贴进虚拟机的时候，不知道为啥我整个测试系统崩了。后来我自己写了一套syscall 调用，来精简exp。使用 <code class="language-plaintext highlighter-rouge">gcc exploit.c -o exp -nostdlib -static</code> 命令来编译，编出来的文件大小不足1M。</p>]]></content><author><name>樵夫砍柴手札</name><email>p1ain0@outlook.com</email></author><category term="PWN" /><category term="PWN" /><summary type="html"><![CDATA[记录下从2025 aliyunctf中学到的新东西：]]></summary></entry><entry><title type="html">Linux kernel exploitation</title><link href="http://localhost:4000/Linux-kernel-exploitation/" rel="alternate" type="text/html" title="Linux kernel exploitation" /><published>2025-02-06T00:00:00+08:00</published><updated>2025-02-06T00:00:00+08:00</updated><id>http://localhost:4000/Linux-kernel-exploitation</id><content type="html" xml:base="http://localhost:4000/Linux-kernel-exploitation/"><![CDATA[<p>关于linux的内核攻防的一些基础知识记录</p>

<h2 id="linux-kernel-exploitation">Linux kernel exploitation</h2>

<p>漏洞模式与用户态相似主要记录下内核的一些关键基础设施和漏洞利用的手法。</p>

<h2 id="攻击面介绍">攻击面介绍</h2>

<p>内核攻击来源于以下几个方面：</p>

<ol>
  <li>network: remotely-trigged exploits (packets of death, etc). Rare!</li>
  <li>userpace: vulnerabilities in syscall and ioctl handlers (i.e., launched from inside a sandbox!), privilege escalation, rootkits, get more access to attack other parts of the system (i.e., trusted execution environments)</li>
  <li>From devices: launch kernel exploits from attached devices such as USB hardware<a href="https://www.pjrc.com/teensy/">LINK</a></li>
</ol>

<h2 id="内核调试环境">内核调试环境</h2>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  qemu-system-x86_64 <span class="se">\</span>
    <span class="nt">-kernel</span> ./bzImage <span class="se">\</span>
    <span class="nt">-initrd</span> ./rootfs.img <span class="se">\</span>
    <span class="nt">-serial</span> stdio <span class="se">\</span>
    <span class="nt">-append</span> <span class="s2">"console=ttyS0 root=/dev/ram rdinit=/sbin/init apic=debug nokaslr"</span> <span class="nt">-s</span> <span class="nt">-S</span>

or
  qemu-system-x86_64 <span class="se">\</span>
  <span class="nt">-kernel</span> ./bzImage <span class="se">\</span>
  <span class="nt">-initrd</span> ./rootfs.img <span class="se">\</span>
  <span class="nt">-append</span> <span class="s2">"root=/dev/ram rdinit=/sbin/init apic=debug nokaslr"</span> <span class="nt">-s</span>

</code></pre></div></div>

<p>使用qemu来模拟内核运行，使用gdb或者lldb来调试。</p>

<p><a href="https://www.kernel.org/doc/Documentation/dev-tools/gdb-kernel-debugging.rst">Debugging:</a></p>

<p><a href="https://github.com/cirosantilli/linux-kernel-module-cheat">Feature-rich kernel experimentation environment:</a></p>

<p>还有一些好用的gdb插件 gef,pt-dump fizmap</p>

<h2 id="利用方式">利用方式</h2>

<h3 id="权限逃逸">权限逃逸</h3>

<p>最经典的利用方式
kernel为每一个process维护着一个 <code class="language-plaintext highlighter-rouge">struct task_struct</code> 结构体，结构体中关于权限相关的成员变量，</p>

<pre><code class="language-C">  /* Process credentials: */
  /* Objective and real subjective task credentials (COW): */
  const struct cred __rcu *real_cred;
  /* Effective (overridable) subjective task credentials (COW): */
  const struct cred __rcu *cred;


  struct cred {
        atomic_long_t	usage;
        kuid_t		uid;		/* real UID of the task */
        kgid_t		gid;		/* real GID of the task */
        kuid_t		suid;		/* saved UID of the task */
        kgid_t		sgid;		/* saved GID of the task */
        kuid_t		euid;		/* effective UID of the task */
        kgid_t		egid;		/* effective GID of the task */
        kuid_t		fsuid;		/* UID for VFS ops */
        kgid_t		fsgid;		/* GID for VFS ops */
        unsigned	securebits;	/* SUID-less security management */
        kernel_cap_t	cap_inheritable; /* caps our children can inherit */
        kernel_cap_t	cap_permitted;	/* caps we're permitted */
        kernel_cap_t	cap_effective;	/* caps we can actually use */
        kernel_cap_t	cap_bset;	/* capability bounding set */
        kernel_cap_t	cap_ambient;	/* Ambient capability set */
#ifdef CONFIG_KEYS
        unsigned char	jit_keyring;	/* default keyring to attach requested
                                         * keys to */
        struct key	*session_keyring; /* keyring inherited over fork */
        struct key	*process_keyring; /* keyring private to this process */
        struct key	*thread_keyring; /* keyring private to this thread */
        struct key	*request_key_auth; /* assumed request_key authority */
#endif
#ifdef CONFIG_SECURITY
        void		*security;	/* LSM security */
#endif
        struct user_struct *user;	/* real user ID subscription */
        struct user_namespace *user_ns; /* user_ns the caps and keyrings are relative to. */
        struct ucounts *ucounts;
        struct group_info *group_info;	/* supplementary groups for euid/fsgid */
        /* RCU deletion */
        union {
                int non_rcu;			/* Can we skip RCU deletion? */
                struct rcu_head	rcu;		/* RCU deletion hook */
        };
} __randomize_layout;
</code></pre>

<p>权限逃逸的方式就是更改这个cred,内核中有 <code class="language-plaintext highlighter-rouge">commit_creds(struct cred *)</code> 现成的函数可以利用，cred结构体很复杂，但是可以通过 <code class="language-plaintext highlighter-rouge">struct cred * prepare_kernel_cred(struct task_struct *reference_task_struct)</code> 来构造
如果我们给他传递一个NULL的参数，这个函数会返回给我们一个root权限的cred。即 <code class="language-plaintext highlighter-rouge">commit_creds(prepare_kernel_cred(0))</code> ;</p>

<h3 id="沙箱逃逸">沙箱逃逸</h3>

<p>正常来讲，如果seccomp沙箱被正确配置了，即使通过漏洞被攻击了，可能做不了任何有用的事。但是它如果可以与内核模块交互，如果内核模块存在可被利用的漏洞，便可以达成逃逸效果。
例如：Powerful! Over 30 Chrome sandbox escapes in 2019 alone: <a href="https://github.com/allpaca/chrome-sbx-db">link</a></p>

<p>还是这个经典的 <code class="language-plaintext highlighter-rouge">struct task_struct</code> 结构体，有一个成员变量 <code class="language-plaintext highlighter-rouge">thread_info</code> ;</p>

<pre><code class="language-C">struct thread_info {
  unsigned long flags; /* low level flags */
  u32 status; /* thread synchronous flags */
};
</code></pre>

<p>flags是一个bit field, 其中有一个bit， <code class="language-plaintext highlighter-rouge">TIF_SECCOMP</code> (新版本改成 <code class="language-plaintext highlighter-rouge">SYSCALL_WORK_BIT_SECCOMP</code> )。
<a href="https://elixir.bootlin.com/linux/v6.13.1/source/arch/x86/entry/vsyscall/vsyscall_64.c#L207">在linux的syscall的入口处</a></p>

<pre><code class="language-C">/*
 * Handle seccomp.  regs-&gt;ip must be the original value.
 * See seccomp_send_sigsys and Documentation/userspace-api/seccomp_filter.rst.
 *
 * We could optimize the seccomp disabled case, but performance
 * here doesn't matter.
 */
regs-&gt;orig_ax = syscall_nr;
regs-&gt;ax = -ENOSYS;
tmp = secure_computing();
if ((!tmp &amp;&amp; regs-&gt;orig_ax != syscall_nr) || regs-&gt;ip != address) {
        warn_bad_vsyscall(KERN_DEBUG, regs,
                          "seccomp tried to change syscall nr or ip");
        force_exit_sig(SIGSYS);
        return true;
}
</code></pre>

<p><a href="https://elixir.bootlin.com/linux/v6.13.1/source/include/linux/seccomp.h#L27">seccomp</a></p>

<p><a href="https://elixir.bootlin.com/linux/v6.13.1/source/include/linux/thread_info.h#L159">thread_info</a></p>

<pre><code class="language-C">static inline int secure_computing(void)
{
        if (unlikely(test_syscall_work(SECCOMP)))
                return  __secure_computing(NULL);
        return 0;
}

#define test_syscall_work(fl) \
      test_bit(SYSCALL_WORK_BIT_##fl, &amp;current_thread_info()-&gt;syscall_work)

</code></pre>

<p>所以为了达到逃逸效果，我们只需要做 current_task_struct-&gt;thread_info.flags &amp;= ~(1 « TIF_SECCOMP) 把这位清空就好了。</p>

<p>现在的问题是，如何寻找current_task。地址保存在gs寄存器中。</p>

<h3 id="缓解机制">缓解机制</h3>

<p>与用户空间相似的缓解措施：</p>

<p>Stack canaries
bypass: leak the canary</p>

<p>kASLR bases the kernel at a random location at boot.
bypass: leak the kernel base address!
更疯狂的想法：函数粒度的ASLR。<a href="https://lwn.net/Articles/824307">More info</a></p>

<p>Heap/stack regions are not executable by default.
bypass: ROP</p>

<p>SMEP(Supervisor mode execution protection): 当进程处于内核模式时，此功能将页表中的所有用户空间页面标记为不可执行。在内核中，通过设置CR4寄存器中的第20 bit 来启用此功能。在启动时，可以通过在 <code class="language-plaintext highlighter-rouge">-cpu</code> 参数后面添加 <code class="language-plaintext highlighter-rouge">+smep</code> 来启用它，禁用它就通过 <code class="language-plaintext highlighter-rouge">-append</code> 参数后添加 <code class="language-plaintext highlighter-rouge">nosmep</code> 。</p>

<p>SMAP(Supervisor Mode Access Prevention): 此功能将页表中的所有用户空间页面标记为不可访问。通过设置CR4寄存器中的第21 bit 来启用此功能。在启动时可以功过在 <code class="language-plaintext highlighter-rouge">-cpu</code> 参数后面添加 <code class="language-plaintext highlighter-rouge">+smap</code> 来启用它，禁用它就通过在 <code class="language-plaintext highlighter-rouge">-append</code> 参数后添加 <code class="language-plaintext highlighter-rouge">nosmap</code> 。
但是在某些情况下，内核需要访问用户空间的数据怎么办？ <code class="language-plaintext highlighter-rouge">copy_from_user</code>  会帮助访问内存空间数据。
<a href="https://wiki.osdev.org/Supervisor_Memory_Protection">MORE INFO</a></p>

<p>KPTI(Kernel page-table isolation): 内核会完全分离用户空间和内核空间PageTable，而不是仅使用一组包含用户空间和内核空间地址的页表。一组页表与以前一样同时包含内核空间和用户空间地址，但它仅在系统以内核模式运行时使用。用于用户模式的PageTable包含用户空间的和一组最小的内核空间地址。启用： <code class="language-plaintext highlighter-rouge">kpti=1</code> 。禁用： <code class="language-plaintext highlighter-rouge">-append</code> 后边添加 <code class="language-plaintext highlighter-rouge">nopti</code></p>

<p>内核中有 <code class="language-plaintext highlighter-rouge">run_cmd(char *cmd)</code> 函数: 只需以 root 身份像system()一样在用户空间中运行命令。</p>

<h3 id="kernel-heap">kernel heap</h3>

<p>堆机制与用户空间不同，</p>

<ol>
  <li>glib中有太多的metadata，占用空间太多；</li>
  <li>随着时间的推移，内存碎片化会越来越严重。</li>
</ol>

<p>内核使用<a href="https://people.eecs.berkeley.edu/~kubitron/courses/cs194-24-S13/hand-outs/bonwick_slab.pdf">slab allocators</a>。slab在很多OS中都被广泛采用。
Linux有三种不同的slab特定实现：</p>

<ul>
  <li><del>SLOB - Simple List of Blocks (deprecated)</del> （实现简单，通常用于嵌入式等场景）</li>
  <li><del>SLAB - (deprecated)</del></li>
  <li>SLUB - Unqueued slab allocator (默认使用的版本)</li>
</ul>

<p>Linux默认采用SLUB，SLUB是一种改进版的SLAB。体现在：</p>

<ol>
  <li>
    <p>在设计上更加简化，减少了锁争用和复杂性。SLUB 使用了一种称为“per-cpu”缓存的技术，减少了全局锁的使用，从而降低了锁争用。</p>
  </li>
  <li>
    <p>SLUB 会在适当的时候合并相邻的空闲块，以减少碎片。</p>
  </li>
  <li>
    <p>SLUB 减少了元数据的复杂性，使得分配和释放操作更加高效。</p>
  </li>
  <li>
    <p>并且SLUB 提供了一些有用的调试和诊断工具，如 slabinfo 和 kmemleak，帮助开发者检测内存泄漏和其他问题。</p>
  </li>
  <li>
    <p>slab分配器简介：</p>

    <p>cache: 首先根据类型和大小，创建一个 <strong>cache</strong>  ，caches 包含 *slabs*，比如使用 <code class="language-plaintext highlighter-rouge">kmem_cache_create</code> 函数来创建一个新的cache（即 <code class="language-plaintext highlighter-rouge">struct kmem_cache</code> 类型）时，我们会指定类型和大小。使用 <code class="language-plaintext highlighter-rouge">kmem_cache_destroy</code> 函数销毁cache。</p>

    <p>slab: slab allocator 每次向 buddy system 请求得来的单张 / 多张内存页，称为slab，在内核中对应 slab 结构体，但是本质上是复用 page 结构体，</p>

    <p>slob: slabs由一系列的slob组成，其中slot是，是slabs中的内存区域，大小由cache管理，所以如果有一个256字节的缓存，那么slab上的slot的大小将是256字节</p>

    <p>object: slots包含object，如果slot是256大小的内存区域，那么当kmalloc的时候返回指针就是这些可用的slot之一的指针，一旦该slot被使用，我们就会说那个slot包含一个object。</p>

    <p>基本概念就已经讲清楚了。</p>

    <p>内核中有着大量的数据结构都是通过slub分配器分配，它们申请（create）并维护自己的kmem_cache，所有的kmem_cache又都被串在一个名为slab_caches的双向链表上。kmem_cache包含许多slab，每个 slab 是&gt;=1个连续的page， 内部包含若干个相同大小的object（大小在kmem_cache_create的时候就指定，这样就不需要额外的内存来保存像glibc中的metadata）。这些object可以被alloc 或free。slab可以处于部分满、完全满或空闲状态。使用 <code class="language-plaintext highlighter-rouge">kmem_cache_alloc</code> 函数从缓存中分配一个object，使用 <code class="language-plaintext highlighter-rouge">kmem_cache_free</code> 函数将对象释放回slab。</p>

    <p><a href="https://elixir.bootlin.com/linux/v6.7.9/source/include/linux/slub_def.h#L98">相关数据结构</a></p>

    <pre><code class="language-C">struct kmem_cache {
#ifndef CONFIG_SLUB_TINY
        struct kmem_cache_cpu __percpu *cpu_slab;
#endif
  //...
    
        struct kmem_cache_node *node[MAX_NUMNODES];
};
</code></pre>

    <p>我们讲的cache与kmem_cache相同，它的slab都是使用 <code class="language-plaintext highlighter-rouge">kmem_cache_cpu</code> 和 <code class="language-plaintext highlighter-rouge">kmem_cache_node</code> 两个结构组织和维护的。</p>

    <pre><code class="language-nil">         +---------------------+
          |     kmem_cache     |
         +---------------------+
                 /       \
                /         \
+---------------------+     +----------------------+
|   kmem_cache_cpu    |     |   kmem_cache_node    |
|   +--------------+  |     |  +-----------------+ |
|   |   freelist   |  |     |  |   nr_partial    | |
|   +--------------+  |     |  +-----------------+ |
+---------------------+     +----------------------+
            |                         |
            |                         |
            v                         v
       +----------+             +----------+
       |   slab   |             |   slab   |
       +----------+             +----------+
            |                         |
            |                         |
            v                         v
  +-------------------------------------------+
  |               Backing Memory              |
  |              [allocated slot ]            |
  |              [open slot ]                 |
  +-------------------------------------------+
    
    
</code></pre>

    <p>kmem_cache_cpu结构体用于存储每个 CPU 的本地缓存信息，即正在使用的slab信息。它的主要目的是通过减少对全局锁的竞争来提高分配和释放操作的性能。每个 CPU 都有自己的 kmem_cache_cpu 实例，这样可以在本地快速分配和释放对象，减少锁争用。</p>

    <pre><code class="language-C">struct kmem_cache_cpu {
    void **freelist;        /* Pointer to next available object */ //指向当前 CPU 上空闲对象的链表头。
    struct page *page;      /* The slab from which we are allocating */ //指向当前使用的 slab 页面。
    struct page *partial;   /* Partially allocated slab */ //指向部分满的 slab 链表，这些 slab 还有未分配的对象。
    // ...
};
    
struct kmem_cache_node {
    spinlock_t list_lock;   /* Protects the partial and full lists */ //保护 partial 和 full 列表的自旋锁。
    struct list_head partial; /* List of partially allocated slabs */ //指向部分满的 slab 链表，这些 slab 还有未分配的对象。
    struct list_head full;  /* List of fully allocated slabs */  //指向完全满的 slab 链表，这些 slab 已经没有可用的对象。
    unsigned long nr_partial; /* Number of partial slabs */  //部分满 slab 的数量。
    // ...
};
    
    
</code></pre>

    <p>kmem_cache_node包含当前CPU未使用的slab信息。kmem_cache_cpu有点类似glibc中的tcache，保存了该 CPU 私有的空闲对象（freelist），让分配/释放可以在本地 CPU 上快速完成。每个CPU的每一个cache都有一个激活的”working slab</p>

    <p>当 CPU 上的 freelist 不足或过多时，会与所属 NUMA 节点的 kmem_cache_node 进行交互（例如当需要一个新的slab时，partial slabs可以被交换进CPU的cache中，partials slabs会被追踪在kmem_cache_node中的nr_partial链表里）</p>

    <p>full slabs 是不会被tracked的（除非在特定编译的内核中）
full allocated的是不会被tracked的，内核甚至不关心它在哪，但是一旦被free，他就变成partial allocated的slab</p>

    <p>object如何在这些slot的slab上分配，这些slot是如何相互关联的？</p>

    <p>Slab Memory - Slots:
slab Memory 可以被视为固定大小的slots组成的连续内存区域，这些插槽要么是空闲的，可用于allocation，要么包含该大小的某个objection，没有元数据的浪费，当我们free一个objection时，会被加入到kmem_cache_cpu的freelist的链表头部。这个freelist是一个单链表</p>

    <pre><code class="language-C">+---------------------+          +-------------------+       +-------------------+                     
|   kmem_cache_cpu    |          |                   |       |                   |
|   +--------------+  |          |                   |       |                   |
|   |   freelist   |--+---------&gt;|   +-----------+   |       |   +-----------+   |
|   +--------------+  |          |   |   next    |---+------&gt;|   |   null    |   |
+---------------------+          +---+-----------+---+       +---+-----------+---+
    
</code></pre>

    <p>free slots的next porter在slot的中间，比如：0x100byte的object将会存放next指针在偏移0x80的位置。</p>

    <p>私有cache：</p>

    <p>自己使用kmem_cache_create单独创建的一块cache。</p>

    <p>通用内核cache：</p>

    <p>使用kmalloc分配内存， <code class="language-plaintext highlighter-rouge">void *kmalloc(size_t size, gfp_t flags)</code> 会根据大小，选择一个合适的通用cache。cache会有一个命名约定，ex: kmalloc-8k, 8k是slot的大小。</p>

    <p>不受信任的allocation（比如包含用户空间数据的）可以使用一个GFP_KERMEL_ACCOUNT flag创建，那就不会转到kmalloc-8k，而是会使用kmalloc-cg-8k的cache。</p>

    <p><code class="language-plaintext highlighter-rouge">cat /proc/slabinfo</code> 可以查看内核的slab情况</p>
  </li>
  <li>
    <p>内核的堆保护措施：</p>

    <ol>
      <li>
        <p>Freelist Randomization 
默认情况下，新的slabs是按固定的顺序返回的slots。攻击者就很容易知道内存中已分配的objects的彼此之间的关系。</p>

        <p>通过一个宏控制这项功能的开关（编译前设置）<a href="https://elixir.bootlin.com/linux/v6.7.9/source/mm/slub.c#L1889"> <code class="language-plaintext highlighter-rouge">CONFIG_SLAB_FREELIST_RANDOMIZATION</code> </a> 首先生成随机索引序列来实现的，保存在 [ <code class="language-plaintext highlighter-rouge">kmem_cache.random_seq</code> ] (<a href="https://elixir.bootlin.com/linux/v6.7.9/source/include/linux/slub_def.h#L142">https://elixir.bootlin.com/linux/v6.7.9/source/include/linux/slub_def.h#L142</a>)这个决定freelist的初始化序列。对于新的slab的freelist（本质是一个单链表）中的slots是随机打乱顺序的，这样就大大增加了攻击的难度，必须通过其他的漏洞获取一些信息。这样返回的objects就不再是按内存顺序可以预测的。后续free后的slots会被push到这个链表的头部。</p>
      </li>
      <li>
        <p>Hardened Freelist
与safe-linking的概念相似，把保存在slots中的下一个slot的指针xor加密。
也是通过<a href="https://elixir.bootlin.com/linux/v6.7.9/source/mm/slub.c#L374"> <code class="language-plaintext highlighter-rouge">CONFIG_SLAB_FREELIST_HARDENED</code> </a>宏控制开关。
细节是将下一个指针的值与一个随机值和当前地址的倒序值xor <code class="language-plaintext highlighter-rouge">decoded = (void *)(ptr.v ^ s-&gt;random ^ swab(ptr_addr));</code> 。</p>

        <p>特殊的情况，如果这个slot再列表中的最末端，它的next_point会是NULL，这个时候它保存的值就是 <code class="language-plaintext highlighter-rouge">swab(&amp;ptr) ^ NULL ^ rand</code></p>

        <ol>
          <li>
            <p>Hardened Usercopy
<a href="https://elixir.bootlin.com/linux/v6.7.9/source/include/linux/slub_def.h#L149">CONFIG_HARDENED_USERCOPY</a>这个开关打开后cache会多维护两个变量:</p>

            <pre><code class="language-C">#ifdef CONFIG_HARDENED_USERCOPY
        unsigned int useroffset;	/* Usercopy region offset */
        unsigned int usersize;		/* Usercopy region size */
#endif
            
</code></pre>
          </li>
        </ol>
      </li>
    </ol>

    <p>当使用 <code class="language-plaintext highlighter-rouge">copy_to_user</code> 和 <code class="language-plaintext highlighter-rouge">copy_from_user</code> 两个函数的时候，会调用 <code class="language-plaintext highlighter-rouge">kmem_cache_create_usercopy</code> 和 <code class="language-plaintext highlighter-rouge">__check_heap_object</code> 检查传输的内存字节是不是在合法范围内。</p>

    <ol>
      <li>
        <p>KASLR</p>

        <p>与用户空间的ASLR相似，每次boot的时候随机化，要利用的话，只能先leak。</p>
      </li>
      <li>
        <p>Kernel oops</p>

        <p>如果内核发生非致命的错误，会导致oops。</p>
      </li>
    </ol>

    <p>错误细节包含寄存器信息，通过dmesg可以看到这会导致泄漏内核地址。</p>

    <p>内核也可以被配置成panic on oops：
这种情况泄漏就比较困难，一些panic检查是针对特定进程的，也许可以使用多进程绕过。</p>
  </li>
  <li>
    <p>explition</p>

    <p>一些gdb调试内核的插件：gef，pt-dump
<code class="language-plaintext highlighter-rouge">pt</code> 命令可以查看内存信息，
<code class="language-plaintext highlighter-rouge">pt -has address</code> 可以查看指定的地址的内存信息</p>

    <p>通用 Heap Vulnerabilities:</p>

    <p>越界访问
UAF: 泄漏/破坏freelist的元数据，创建任意读写，重叠分配</p>

    <p>利用方式：
Heap Spraying
内核Heap不太可预测，因为heap在所有内核操作之间共享。这使得将objects放在一起变得困难。解决方案是Heap Spray，能提高攻击的成功几率。</p>

    <p>对于kmalloc的通用cache，还有两个比较值的一提的利用方式：</p>

    <p>主要参考这篇文章<a href="&lt;https://google.github.io/security-research/pocs/linux/cve-2021-22555/writeup.html&gt;">here</a>
主要介绍了两个有价值的结构体：</p>

    <ul>
      <li>msg_msg</li>
      <li>pipe_buffer</li>
    </ul>

    <p>通过在用户空间使用这两个结构体在内核中灵活的申请特定大小的堆内存。</p>

    <p>有个有意思的全局变量：<a href="https://elixir.bootlin.com/linux/v6.7.9/source/kernel/module/kmod.c#L64">modprobe_path</a> 把这个全局变量覆盖后，使用命令行执行一个奇怪的文件就可以自动用sudo权限执行这个命令。</p>

    <p>还有一些函数比如：prepare_kernel_cred()、 commit_creds()、run_cmd()、swapgs_restore_regs_and_return_to_usermode()</p>

    <p>其他的一些资源：
<a href="https://lkmidas.github.io/posts/20210123-linux-kernel-pwn-part-1/">Beginning Kernel Exploitation:</a>
<a href="https://lkmidas.github.io/posts/20210128-linux-kernel-pwn-part-2/">Kernel ROP (necessary):</a>
<a href="https://adamdoupe.com/publications/retspill-ccs2023.pdf">RetSpill Exploitation Technique Paper:</a>
<a href="https://github.com/sefcom/RetSpill">RetSpill Exploitation Technique Demo:</a>
<a href="https://google.github.io/security-research/pocs/linux/cve-2021-22555/writeup.html">CVE-2021-22555 (important):</a></p>
  </li>
  <li>
    <p>简单记录下pwn.college的challenge解题思路</p>

    <p>这里有8个题目，由易到难，由浅入深理解关于内核堆内存的分配过程。</p>

    <p>(1) 原程序在模块加载时就把flag读进bss段中，然后调用 <code class="language-plaintext highlighter-rouge">kmem_cache_create</code> 创建块缓存，并且在proc目录下创建交互的文件。</p>

    <p><code class="language-plaintext highlighter-rouge">kheap_open</code> 当文件打开的时候会调用该函数，函数内部使用 <code class="language-plaintext highlighter-rouge">kmem_cache_alloc</code> 从cache中分配一块内存，并将内存清0后，开头8bytes放置 <code class="language-plaintext highlighter-rouge">do_print</code> 函数的地址。</p>

    <p><code class="language-plaintext highlighter-rouge">kheap_ioctl</code> 当调用ioctl的时候内核会调用该函数，用户可控的有两个参数，cmd和arg，其中cmd代表执行的操作，arg是一个16字节的结构体指针，ubuf代表数据指针，size代表数据大小。</p>

    <pre><code class="language-C">typedef struct _kheap_req_t // sizeof=0x10
{                                       // XREF: kheap_ioctl/r
    void *ubuf;                         // XREF: kheap_ioctl+78/r
                                        // kheap_ioctl+FA/r
    size_t size;                        // XREF: kheap_ioctl+73/r
                                        // kheap_ioctl:loc_135/r
}kheap_req_t;
</code></pre>

    <p>cmd      对应着不同的操作，根据反编译代码，0x5704对应的操作是malloc一块新内存，然后把flag的内容copy进去。0x5700对应操作是把open时分配的内存复制到用户空间中，但这里复制的大小是用户空间传递进去的，所以这里存在越界读，可以把flag的内容读取到用户空间。</p>

    <p>(2) 这个程序大致跟challenge-1一样，但是从用户空间中拷贝到内核空间中的数据是没有检查大小的，所以存在缓冲区溢出的漏洞，每一块的开头8字节是函数地址可以被覆盖。调用修改权限的 <code class="language-plaintext highlighter-rouge">commit_creds</code> 函数，由于块分配是随机的(Freelist Randomization)，因此可以多分配几个提高覆盖成功的几率。</p>

    <p>(3) 第三个challenge开启了KASLR，所以这就需要先泄漏内核地址。然后计算偏移填入缓冲区，使用缓冲区溢出覆盖堆上的指针。</p>

    <p>(4) challenge-4，这个题目就没有堆上的函数指针可以利用了，但是存在UAF，因此我们可以通过覆盖一个free的堆块的元数据，控制链表结构，然后我们可以获得任意地址写的漏洞。这里我们可以通过覆盖全局变量modpath来执行任意命令，这题也是开启了kaslr，首先也要泄漏内核地址。
   攻击流程：先通过open打开两个文件描述符，这样我们就有两个分配的堆块，然后释放一个，再读取该块。就可以获取堆上的地址。然后构造数据将计算后的modpath的地址加入链表。然后通过两次open获取分配的内存块即是modpath的内存，然后覆盖起其中的内容。</p>

    <p>(5) 与challenge-4相同，唯一不同的是内核开启了 <code class="language-plaintext highlighter-rouge">HARDENED</code> free堆块上的内容被加密存放，但这个通过泄漏的值，可以被计算。大致与glibc的利用方式相似。</p>

    <p>(6) 从这个challenge就开始转到通用的cache中了，不再使用单独的私有cache。这就意味着不可控的因素又变多了。这个题目比较简单用来熟悉msg_msg的简单使用，由于题目中的是把flag读取进堆内存的，通过控制msg的大小来控制内核堆内存的分配，让它落在跟kheap相同的cache，然后利用UAF改写消息结构体中的内容越界读取flag内容。</p>

    <p>(7) 通过上一个题目的利用方式我们可以泄漏内核中的堆地址，然后通过控制msg_msg结构体的msgseg的值来泄漏内核中任意地址的内容。然后结合UAF控制free堆链表的指针，达到任意写的目的，覆盖modprobe_path的地址。</p>

    <p>(8) 这个利用过程与challenge-7差不多。</p>
  </li>
</ol>]]></content><author><name>樵夫砍柴手札</name><email>p1ain0@outlook.com</email></author><category term="PWN" /><category term="PWN" /><summary type="html"><![CDATA[关于linux的内核攻防的一些基础知识记录]]></summary></entry><entry><title type="html">pwncollege蓝带笔记</title><link href="http://localhost:4000/pwncollege%E8%93%9D%E5%B8%A6%E7%AC%94%E8%AE%B0/" rel="alternate" type="text/html" title="pwncollege蓝带笔记" /><published>2024-08-17T23:48:14+08:00</published><updated>2024-08-17T23:48:14+08:00</updated><id>http://localhost:4000/pwncollege%E8%93%9D%E5%B8%A6%E7%AC%94%E8%AE%B0</id><content type="html" xml:base="http://localhost:4000/pwncollege%E8%93%9D%E5%B8%A6%E7%AC%94%E8%AE%B0/"><![CDATA[<p>最近刚刚在pwn.college上已经获得了蓝带，现在总结下：</p>

<h2 id="x86基础">x86基础</h2>

<p>x86体系架构以及汇编：网上一堆教程自己找着看吧。</p>

<p>linux上的函数调用约定；然后就自己手写汇编反弹shell会各种的syscall传参。如何压缩shellcode，如何绕过一些特殊字符的限制</p>

<h3 id="汇编示例">汇编示例</h3>

<p>execve(“/bin/sh”, NULL, NULL)</p>

<pre><code class="language-assembly">.global _start
_start:
.intel_syntax noprefix
mov rax, 59
lea rdi, [rip+binsh]
mov rsi, 0
mov rdx,0
syscall
binsh:
.string "/bin/sh"

</code></pre>

<p>提取shellcode</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#assmbly it!</span>
gcc <span class="nt">-nostdlib</span> <span class="nt">-static</span> shellcode.s <span class="nt">-o</span> shellcode-elf

objcopy <span class="nt">--dump-section</span> .text<span class="o">=</span>shellcode-raw shellcode-elf

Assemble Code
as <span class="nt">-o</span> shellcode.o shellcode.s

Link Object File
ld <span class="nt">-o</span> shellcode shellcode.o

Link Object File
objcopy -–dump-section .text<span class="o">=</span>shellcode-raw shellcode-elf

</code></pre></div></div>

<p>再比如<code class="language-plaintext highlighter-rouge">sendfile(1, open("flag", NULL), 0, 1000); exit()</code></p>

<pre><code class="language-assembly">mov rbx, 0x00000067616c662f
push rbx
mov rax, 2
mov rdi, rsp
mov rsi, 0
syscall

mov rdi, 1
mov rsi, rax
mov rdx, 0
mov r10, 1000
mov rax, 40
syscall

mov rax, 60
syscall
</code></pre>

<p>也可以使用python的pwntools生成</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>
<span class="n">context</span><span class="p">.</span><span class="n">arch</span> <span class="o">=</span> <span class="s">"amd64"</span>
<span class="n">my_sc_bytes</span> <span class="o">=</span> <span class="n">asm</span><span class="p">(</span><span class="s">'''mov rax, 0x1337'''</span><span class="p">)</span>
<span class="c1"># display the bytes
</span><span class="k">print</span><span class="p">(</span><span class="n">disasm</span><span class="p">(</span><span class="n">my_sc_bytes</span><span class="p">))</span>


<span class="c1">#shellcraft 自动化生成
</span><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>
<span class="n">context</span><span class="p">.</span><span class="n">arch</span> <span class="o">=</span> <span class="s">"amd64"</span>
<span class="n">my_sc</span> <span class="o">=</span> <span class="n">asm</span><span class="p">(</span><span class="n">shellcraft</span><span class="p">.</span><span class="n">cat</span><span class="p">(</span><span class="s">"/flag"</span><span class="p">)</span>
<span class="c1"># display the bytes
</span><span class="k">print</span><span class="p">(</span><span class="n">disasm</span><span class="p">(</span><span class="n">my_sc_bytes</span><span class="p">))</span>
</code></pre></div></div>

<h3 id="调试shellcode的方法">调试shellcode的方法</h3>

<h4 id="debug-shellcode-with-strace">Debug shellcode with strace</h4>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$cat</span> my_shellcode | strace ./target_binary 
</code></pre></div></div>

<h4 id="debug-shellcode-with-pwntools">Debug shellcode with pwntools</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#Debug shellcode with pwntools
</span><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>
<span class="n">Context</span><span class="p">.</span><span class="n">arch</span> <span class="o">=</span> <span class="err">“</span><span class="n">amd64</span><span class="err">”</span>
<span class="n">sc_bytes</span> <span class="o">=</span> <span class="n">asm</span><span class="p">(</span><span class="err">‘’’</span>
  <span class="n">int3</span>
  <span class="n">mov</span> <span class="n">rax</span><span class="p">,</span> <span class="mh">0x1337</span>
  <span class="err">‘’’</span><span class="p">)</span>
<span class="c1">#p = process(“challenge/whatever”)
</span><span class="n">p</span> <span class="o">=</span> <span class="n">gdb</span><span class="p">.</span><span class="n">debug</span><span class="p">(</span><span class="err">“</span><span class="o">/</span><span class="n">challenge</span><span class="o">/</span><span class="n">whatever</span><span class="err">”</span><span class="p">)</span>
<span class="n">p</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">sc_bytes</span><span class="p">)</span>
<span class="n">p</span><span class="p">.</span><span class="n">interactive</span><span class="p">()</span>


<span class="c1">#Debug shellcode inside the challenge itself
</span><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>
<span class="n">context</span><span class="p">.</span><span class="n">arch</span> <span class="o">=</span> <span class="err">“</span><span class="n">amd64</span><span class="err">”</span>
<span class="n">sc_bytes</span> <span class="o">=</span> <span class="n">asm</span><span class="p">(</span><span class="s">'''
  int3
  mov rax, 0x1337
  '''</span><span class="p">)</span>
<span class="c1">#p = process(“challenge/whatever”)
</span><span class="n">p</span> <span class="o">=</span> <span class="n">gdb</span><span class="p">.</span><span class="n">debug</span><span class="p">(</span><span class="err">“</span><span class="o">/</span><span class="n">challenge</span><span class="o">/</span><span class="n">whatever</span><span class="err">”</span><span class="p">)</span>
<span class="n">p</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">sc_bytes</span><span class="p">)</span>
<span class="n">p</span><span class="p">.</span><span class="n">interactive</span><span class="p">()</span>


<span class="c1">#Testing your shellcode for “bad bytes”
</span><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>
<span class="n">Context</span><span class="p">.</span><span class="n">arch</span> <span class="o">=</span> <span class="err">“</span><span class="n">amd64</span><span class="err">”</span>
<span class="n">sc_bytes</span> <span class="o">=</span> <span class="n">asm</span><span class="p">(</span><span class="s">'''mov rax, 0x1337'''</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">disasm</span><span class="p">(</span><span class="n">sc_bytes</span><span class="p">))</span>
<span class="k">if</span> <span class="n">b</span><span class="err">’</span><span class="n">X</span><span class="err">’</span> <span class="ow">in</span> <span class="n">sc_bytes</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="err">“</span><span class="n">X</span> <span class="n">was</span> <span class="n">found</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">shellcode</span><span class="err">!”</span>

</code></pre></div></div>

<h3 id="跨平台的shellcode">跨平台的shellcode</h3>

<h4 id="shellcode-for-otherarchitectures">shellcode for otherarchitectures</h4>

<p>Our way of building shellcode translates well to other architectures:</p>

<ul>
  <li>
    <p>amd64: gcc -nostdlib -static shellcode.s -o shellcode-elf</p>
  </li>
  <li>
    <p>mips: <strong>mips-linux-gnu-</strong>gcc -nostdlib shellcode-mips.s -o shellcode-mips-elf</p>
  </li>
</ul>

<p>Similarly, we can run cross-architecture shellcode with an emulator:</p>

<ul>
  <li>
    <p>amd64: ./shellcode</p>
  </li>
  <li>
    <p>mips: <strong>qemu-mips-static</strong> ./shellcode-mips</p>
  </li>
</ul>

<p>Useful qemu options:</p>

<ul>
  <li>
    <p>-strace		print out a log of the system calls (like strace)</p>
  </li>
  <li>
    <p>-g 1234		wait for a gdb connection on port 1234. Connect with
	target remote localhost:1234 in gdb-multiarch</p>
  </li>
</ul>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mips: mips-linux-gun-gcc <span class="nt">-nostdlib</span> xxx.s <span class="nt">-o</span> xxx
qemu-mips-static ./xxx
qemu useful option:
<span class="nt">-strace</span>
<span class="nt">-g</span> 1234
</code></pre></div></div>

<h4 id="跨架构的shellcode制作方法">跨架构的shellcode制作方法：</h4>

<p>以x86的32 位和 64 位为例，制作跨平台运行的shellcode：典型策略：以“多语言”方式启动，对实际架构进行指纹识别，然后跳转到特定于架构的shellcode。</p>

<ol>
  <li>将 eax 推送到堆栈（x86 和 amd64 上的操作码相同）</li>
  <li>检查 esp 是否移位 32 位或 64 位（x86 和 amd64 上的操作码相同）</li>
  <li>如果是 32 位，则跳转到 32 位 shellcode，如果是 64 位，则跳转到 64 位</li>
</ol>

<h3 id="汇编的操作数的宽度">汇编的操作数的宽度：</h3>

<pre><code class="language-assembly">1-byte : mov [rax], bl
2-byte : mov [rax], bx
4-byte : mov [rax], ebx
8-byte : mov [rax], rbx

1-byte : mov BYTE PTR[rax], 5
2-byte : mov WORD PTR [rax], 5
4-byte : mov DWORD PTR [rax], 5
8-byte : mov QWORD PTR [rax], 5
</code></pre>

<h3 id="输入的一些限制">输入的一些限制</h3>

<p>我们在制作shellcode的时候要考虑输入的函数在遇到特殊的字符的时候会自动截断等问题。</p>

<table>
  <thead>
    <tr>
      <th>Byte(hex value)</th>
      <th>Problematic Methods</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Null byte \0 (0x00)</td>
      <td>strcpy</td>
    </tr>
    <tr>
      <td>Newline \n (0x0a)</td>
      <td>scanf gets getline fgets</td>
    </tr>
    <tr>
      <td>Carriage return \r (0x0d)Space (0x20) Tab \t (0x09)</td>
      <td>scanf</td>
    </tr>
    <tr>
      <td>DEL (0x7f)</td>
      <td>protocol-specific(telnet VT100, etc)</td>
    </tr>
  </tbody>
</table>

<p>当然实际情况更复杂，比如input format只允许可打印的字符…</p>

<p>shellcode变形demo：</p>

<table>
  <thead>
    <tr>
      <th>Filter</th>
      <th>Bad</th>
      <th>Good</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>no NULLs</td>
      <td>mov rax, 0 (48c7c0<strong>00000000</strong>)</td>
      <td>xor rax, rax (4831C0)</td>
    </tr>
    <tr>
      <td>no NULLs</td>
      <td>mov rax, 5 (48c7c005<strong>000000)</strong></td>
      <td>xor rax, rax; mov al, 5 (4831C0B005)</td>
    </tr>
    <tr>
      <td>no newlines</td>
      <td>mov rax, 10 (48c7c0<strong>0a</strong>000000<strong>)</strong></td>
      <td>mov rax, 9; inc rax (48C7C00900000048FFC0)</td>
    </tr>
    <tr>
      <td>no NULLs</td>
      <td>mov rbx, 0x67616c662f “/flag” (48BB2F666C6167<strong>000000</strong>)</td>
      <td>mov ebx, 0x67616c66; shl rbx, 8; mov bl, 0x2f (BB666C616748C1E308B32F)</td>
    </tr>
    <tr>
      <td>printables</td>
      <td>mov rax, rbx (48<strong>89d8</strong>)</td>
      <td>push rbx; pop rax (5358, “SX”)</td>
    </tr>
  </tbody>
</table>

<p>如果shellcode的约束太难用巧妙的变形来解决，但是你的 shellcode 所映射的页面是可写的……</p>

<p>记住：code == data</p>

<p>Bypassing a restriction on <code class="language-plaintext highlighter-rouge">int 3</code>:</p>

<pre><code class="language-assembly">inc BYTE PTR [rip]
.byte 0xcb
</code></pre>

<p>When testing this, you’ll need to make sure .text is writable:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gcc <span class="nt">-Wl</span> <span class="nt">-N</span> <span class="nt">--static</span> <span class="nt">-nostdlib</span> <span class="nt">-o</span> <span class="nb">test </span>test.s
</code></pre></div></div>

<h3 id="x86和amd64的一些不一样的地方">x86和amd64的一些不一样的地方</h3>

<h4 id="特殊情况字符h">特殊情况：字符”H”</h4>

<p>在 amd64 shellcode 中，有一个字符比其他任何字符都更突出：“H”。</p>

<ul>
  <li>AMD 将 amd64 设计为与 x86 <em>向后兼容</em>，以便实际采用。在 amd64 处理器上执行的 x86 代码将完全按照 x86 代码运行。大多数情况下，amd64 是一个纯扩展，由16进制的0x48(字符”H”)的指令前缀控制。
例外情况：在 amd64 上，push 和 pop 适用于 64 位值（rax 等），无需前缀。</li>
</ul>

<table>
  <thead>
    <tr>
      <th>x86</th>
      <th>amd64</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>mov eax, ebx (89 d8)</td>
      <td>mov rax, rbx (<strong>48</strong> 89 d8)</td>
    </tr>
    <tr>
      <td>inc eax (ff c0)</td>
      <td>inc rax (<strong>48</strong> ff c0)</td>
    </tr>
  </tbody>
</table>

<h4 id="system-calls">system calls</h4>

<p><strong>amd64</strong> uses the <code class="language-plaintext highlighter-rouge">syscall</code> instruction to dispatch a system call to the OS kernel.</p>

<p><strong>x86</strong> used the <code class="language-plaintext highlighter-rouge">int 0x80</code> instruction to trigger an interrupt that would be interpreted by the OS kernel as a system call.</p>

<p>这是两个不同的指令，具有不同的系统调用映射！当然在 amd64 中也能使用 <code class="language-plaintext highlighter-rouge">int 0x80</code>。</p>

<p>有用的资源:</p>

<ul>
  <li><a href="https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md">chromium项目Syscalls</a> <a href="https://www.chromium.org/chromium-os/developer-library/reference/linux-constants/syscalls/">新地址</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Shellcode">Wikipedia</a></li>
  <li><a href="http://ref.x86asm.net/coder64.html">x86_64 assembly listing</a></li>
  <li><a href="https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/">Syscall Table</a></li>
  <li><a href="https://syscall.sh/">Another syscall table, with multiple architectures!</a></li>
</ul>

<h2 id="越过防护">越过防护</h2>

<h3 id="stack-canary">Stack Canary</h3>

<p>与canary相关的编译器选项</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-fstack-protector 只为局部变量中含有数组的函数开启保护
-fstack-protector-all 为所有函数开启保护
-fstack-protector-strong 为局部变量地址作为赋值语句的右值及函数参数、含有数组类型的局部变量、`register`声明的局部变量开启保护
 
-fstack-protector-explicit 对含义stack_protect attribute的函数开启保护
 
-fno-stack-protector 禁用保护
</code></pre></div></div>

<p>Canary的值是与线程相关的，不同的线程值不一样。从<code class="language-plaintext highlighter-rouge">fx+0x28</code>的位置取出</p>

<p>LibC使用fs寄存器存放线程局部存储TLS (Thread Local Stroage)，TLS可用于支持多线程同时访问同1个全局变量或静态变量。TLS的存在使得每个线程都独占1份全局变量及静态变量，不同线程间对同1个全局变量或静态变量的修改并不会产生冲突。这种特殊的变量需要<code class="language-plaintext highlighter-rouge">__thread</code>关键字修饰，编译器看到<code class="language-plaintext highlighter-rouge">__thread</code>修饰的变量后，二进制文件内会将这些变量放入<code class="language-plaintext highlighter-rouge">.tdata </code>节和<code class="language-plaintext highlighter-rouge">.tbss</code>节内。</p>

<p>(ps:在GDB中观察<code class="language-plaintext highlighter-rouge">fs</code>寄存器时，会发现<code class="language-plaintext highlighter-rouge">fs</code>寄存器的值永远是0，这是因为软件调试器GDB对系统寄存器没有访问权限导致的。但是内核提供了<code class="language-plaintext highlighter-rouge">arch_prctl</code>接口，用于修改或获取特定于体系结构的进程或线程状态。)</p>

<p>_start -&gt;init_tls初始化tls信息 -&gt; security_init产生随机值。但是随机值<code class="language-plaintext highlighter-rouge">stack_chk_guard</code>与<code class="language-plaintext highlighter-rouge">_dl_random</code>的值相关。这个值咋来的呢？可以使用gdb的内存监视断点观察。中断在<code class="language-plaintext highlighter-rouge">_dl_sysdep_parse_arguments</code>函数中</p>

<ol>
  <li>
    <p>泄漏Canary，</p>
  </li>
  <li>
    <p>对于fork的程序，可以使用brute-force的方法</p>

    <p>例如这种情况：</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">fork</span><span class="p">())</span> <span class="p">{</span> <span class="n">wait</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span> <span class="n">read</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">128</span><span class="p">);</span> <span class="k">return</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>写的时候跳过去</p>

    <p>例如这种情况可以通过控制i的值跳过canary：</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">128</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">read</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">buf</span><span class="o">+</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>在程序返回之前劫持程序</p>
  </li>
  <li>
    <p>覆盖.got.plt中的__stack_chk_fail函数地址</p>
  </li>
</ol>

<h3 id="aslr-address-space-layout-randomization">ASLR (Address Space Layout Randomization)</h3>

<p>History:First appeared in 2001 as part of a Linux kernel patch set called <strong>PaX</strong>. Written by a team led by an anonymous coder…(<strong>PaX</strong> also brought DEP to Linux)</p>

<ol>
  <li>
    <p>leak</p>
  </li>
  <li>
    <p>YOLO</p>

    <p>程序都是页对齐的，所以低12位是固定的。我们可以只overwrite两个字节（当然也得需要部分brute-force）</p>
  </li>
  <li>
    <p>brute-force（跟canary相似的情况，fork）</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">fork</span><span class="p">())</span> <span class="p">{</span> <span class="n">wait</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span> <span class="n">read</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">128</span><span class="p">);</span> <span class="k">return</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ol>

<h4 id="disabling-aslr-for-local-testing">Disabling ASLR for local testing</h4>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pwn.process<span class="o">(</span><span class="s2">"./vulnerable_proram"</span>, <span class="nv">aslr</span><span class="o">=</span>False<span class="o">)</span>
</code></pre></div></div>

<p>gdb will disable ASLR by default if has permissions to do so.</p>

<p>NOTE: for SUID binaries, remove the SUID bit before using gdb (chmod or cp).</p>

<p>可以启动一个 shell，其 (非 setuid) 子进程都将禁用 ASLR：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>setarch x86_64 <span class="nt">-R</span> /bin/bash
</code></pre></div></div>

<h3 id="dep">DEP:</h3>

<h4 id="rop">ROP</h4>

<p>从内存中已有的一组奇怪的指令中进行选择。使用 ret和堆栈上的地址链接指令（ropchains）。达到和连续的shellcode的一样的效果。</p>

<p>Return to libc :Discovered in 1997 by Solar Designer.</p>

<p>Code reuse in AMD64</p>

<p>The generalization of Return-to-libc is Return Oriented Programming.</p>

<h5 id="注意点">注意点：</h5>

<ol>
  <li>
    <p>syscalls are rare.</p>

    <ul>
      <li>In shellcode, you use syscall to invoke system calls. This instruction is quite rare in normal programs (even as a part of other instructions).You might have to call library functions, instead!</li>
      <li>Advice: Keep it Simple.</li>
    </ul>
  </li>
  <li>
    <p>know your environment. ex:heap address and stack address in register and stacks…</p>
  </li>
  <li>
    <p>finding the rop gadgets</p>

    <ul>
      <li>Many tools available <a href="https://github.com/zardus/ctf-tools">ctftools</a> has installers for 3!.</li>
      <li>For example, rp++:</li>
    </ul>

    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rp++ <span class="nt">--unique</span> <span class="nt">-r2</span> <span class="nt">-f</span> /bin/bash
   
<span class="c"># Can also try greater values than 2, but long gadgets become increasingly unstable (side-effects!).</span>
<span class="c"># From here, regular expressions are your friends.</span>
   
rp++ <span class="nt">--unique</span> <span class="nt">-r2</span> <span class="nt">-f</span> /bin/bash | <span class="nb">grep</span> <span class="nt">-P</span> <span class="s2">"(add|sub|mov) rax, r.."</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>Sometimes, your control of the stack is limited.  ex: Limited overflow size.  Inability to input NULL bytes. Often, we can still trigger one gadget!</p>

    <p>Consider system()…</p>

    <ul>
      <li>it has to set up a call to execve(“/bin/sh”, {“/bin/sh”, “-c”, command}, env);</li>
      <li>what if we jump partway through?</li>
    </ul>

    <p>This actually works! If you get lucky with register values and stack setup, you can often trigger /bin/sh by jumping partway into system(). This location is called the <strong>magic gadget</strong>.</p>

    <p>More useful for you: trigger execve(some_garbage); and create a some_garbage file that reads the flag.</p>
  </li>
  <li>
    <p>ASLR （跟之前讨论过的ASLR的方法类似，通过部分overwrite）</p>
  </li>
  <li>
    <p>Stack Canary</p>

    <p>泄漏或者绕过</p>
  </li>
  <li>
    <p>一些缓解rop的措施</p>

    <p>Anti-ROP approaches:</p>

    <p>删除 ROP gadgets（太繁重）：
G-Free：通过无小工具的二进制文件击败面向返回的编程
检测正在进行的 ROP（已部署，但可绕过）：
kBouncer：高效且透明的 ROP 缓解
ROPecker：一种通用且实用的防御 ROP 攻击的方法</p>
  </li>
  <li>
    <p>控制流完整性 Control Flow Integrity</p>

    <p>2009 年，Martin Abadi、Mihai Budiu、Ulfar Erlingsson 和 Jay Ligatti 在Control-Flow Integrity: Principles, Implementations, and Applications中提出了这一建议。
核心思想：每当发生可劫持的控制流传输时，确保其目标是它应该能够返回的东西！
这引发了一场军备竞赛。
反 CFI 技术：</p>

    <p><strong>B(lock)OP:</strong> ROP on a block (or multi-block) level by carefully compensating for side-effects.</p>

    <p><strong>J(ump)OP:</strong> instead of returns, use indirect jumps to control execution flow</p>

    <p><strong>C(all)OP:</strong> instead of returns, use indirect calls to control execution flow</p>

    <p><strong>S(ignreturn)ROP:</strong> instead of returns, use the sigreturn system call</p>

    <p><strong>D(ata)OP:</strong> instead of hijacking control flow, carefully overwrite the program’s data to puppet it</p>

    <p><strong>ex：Control Flow Integrity: Intel Edition!</strong></p>

    <ul>
      <li>英特尔（2020 年 9 月）发布了具有控制流执行技术 (CET) (Control-flow Enforcement Technology)的处理器。CET添加了endbr64 指令。在启用 CET 的 CPU 上，间接跳转（包括 ret、jmp rax、call rdx 等）必须以 endbr64 指令结束，否则程序将终止。这仍然可以通过一些高级 ROP 技术（面向块编程、SROP 等）绕过，但它将大大增加利用的复杂性。</li>
    </ul>
  </li>
  <li>
    <p>Hacking Blind</p>

    <p>Proposed by Andrea Bittau at the 2014 IEEE Symposium on Security &amp; Privacy.</p>

    <p>http://www.scs.stanford.edu/brop/bittau-brop.pdf</p>

    <p>逐字节破坏 ASLR 和金丝雀，我们可以半控制地重定向内存。重定向内存，直到我们有一个生存信号（即不会崩溃的地址）。使用生存信号查找非崩溃的 ROP 小工具。查找产生输出的功能。泄漏程序。破解它。</p>
  </li>
</ol>

<h4 id="存在jit的系统">存在JIT的系统</h4>

<p>在现代系统中，默认情况下，stack和heap是不可执行的。但是现代高级语言（JavaScript、Java、Lua、Python 等）都使用即时编译。代码是用 JavaScript 编写的。在运行时，必要的代码被编译为二进制代码，因为二进制代码执行速度非常快。当然，这意味着能够注入高级代码的攻击者可以影响生成的本机代码……</p>

<h5 id="jit编译">JIT编译：</h5>

<ul>
  <li>Just in Time compilers need to generate (and frequently re-generate) code that is executed.</li>
  <li>Pages must be writable for code generation.</li>
  <li>Pages must be executable for execution.</li>
  <li>Pages must be writable for code <em>re-generation</em>.</li>
</ul>

<p>The safe thing to do would be to:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">mmap(PROT_READ|PROT_WRITE)</code></li>
  <li><code class="language-plaintext highlighter-rouge">write the code</code></li>
  <li><code class="language-plaintext highlighter-rouge">mprotect(PROT_READ|PROT_EXEC)</code></li>
  <li><code class="language-plaintext highlighter-rouge">execute</code></li>
  <li><code class="language-plaintext highlighter-rouge">mprotect(PROT_READ|PROT_WRITE)</code></li>
  <li>update code</li>
  <li>etc…</li>
</ol>

<table>
  <tbody>
    <tr>
      <td>但是这种方式太慢了，所以PROT_WRITE</td>
      <td>PROT_EXEC的页面太常见了。</td>
    </tr>
  </tbody>
</table>

<p>If your binary uses a library that has a writable+executable page, that page lives in your memory space!</p>

<p>Consider the following JavaScript:
<code class="language-plaintext highlighter-rouge">var asdf = 0x050f3cb0c031;</code>
This might JIT to:
<code class="language-plaintext highlighter-rouge">mov rdx, 0x050f3cb0c031</code>
Which assembles to:
<code class="language-plaintext highlighter-rouge">48 ba 31 c0 be 3c 0f 05 00 00</code>
What if we jump to the 0x31 via another vulnerability?
<code class="language-plaintext highlighter-rouge">31 c0: xor eax, eax </code>
<code class="language-plaintext highlighter-rouge">be 3c: mov al, 0x3c</code> 
<code class="language-plaintext highlighter-rouge">0f 05: syscall</code></p>

<p>Shellcode execution (in this case, exit())!</p>

<p>JIT is used <em>everywhere</em>: browsers, Java, and most interpreted language runtimes (luajit, pypy, etc), so this vector is very relevant.</p>

<h5 id="jit-spraying">JIT spraying</h5>

<p>Shellcode injection technique: JIT spraying.</p>

<ul>
  <li>Make constants in the code that will be JITed:
	<code class="language-plaintext highlighter-rouge">var evil = "%90%90%90%90%90";</code></li>
  <li>The JIT engine will mprotect(PROT_WRITE), compile the code into memory, then mprotect(PROT_EXEC). Your constant is now present in executable memory.</li>
  <li>Use a vulnerability to redirect execution into the constant.</li>
</ul>

<h2 id="format-string-exploits">Format String Exploits</h2>

<h3 id="printf---turing-complete-mastery">printf - (turing) complete mastery</h3>

<p>When run in a loop, printf is <em>turing complete</em>!</p>

<p>https://github.com/HexHive/printbf</p>

<h3 id="printf---leaking-memory">printf - leaking memory</h3>

<p>Memory can be leaked by using:</p>

<p>%c: read a char off the stack</p>

<p>%d, %i, %x: read an int (4 bytes) off the stack</p>

<p>%x: read an int (4 bytes) in hex</p>

<p>%s: dereference a pointer and read out bytes until a null byte</p>

<h3 id="printf---controlling-how-much-you-leak">printf - controlling how much you leak</h3>

<p>Size parameters:</p>

<p>%x leaks 4 bytes</p>

<p>%hx leaks 2 bytes</p>

<p>%hhx leaks 1 byte</p>

<p>%lx leaks 8 bytes</p>

<h3 id="printf---controlling-what-you-leak">printf - controlling what you leak</h3>

<p>In their infinite wisdom, the glibc developers have given us $.</p>

<p>%7$x - print the <em>7th</em> parameter (on the stack)</p>

<h3 id="other-functions">other functions</h3>

<p>Format strings are sometimes:</p>

<ul>
  <li>dynamically generated</li>
  <li>used for internal logic, as opposed to i/o (i.e., sprintf, snprintf, sscanf)</li>
  <li>used for logging (fprintf)</li>
  <li>used for input (scanf)</li>
</ul>

<p>All of these are exploitable.</p>

<h3 id="printf---writing-memory">printf - writing memory</h3>

<p>%n requires a pointer to where we want to write. But:</p>

<ol>
  <li><strong>if our buffer is on the stack (and we can put a valid pointer into it), we can use that!</strong></li>
  <li>%7$n (and other offsets) let us use different pointers on the stack</li>
  <li>frame pointers point to each other!</li>
  <li>we can target ebp1 for %n, and modify ebp2, then target ebp2</li>
</ol>

<h3 id="problem-n-writes-4-bytes">Problem: %n writes 4 bytes.</h3>

<p>Solution:</p>

<ul>
  <li>%ln</li>
  <li>%hn</li>
  <li>%hhn</li>
</ul>

<h3 id="problem-how-do-we-control-what-to-write">Problem: how do we control <em>what</em> to write?</h3>

<p>Solution:</p>

<p>char buf[4];</p>

<p>printf(“%1145258561x%1$n”, buf);</p>

<h3 id="problem-limiting-output-amount">Problem: limiting output amount?</h3>

<p>Solution:</p>

<p>char buf[4];</p>

<p>printf(“%65x%1$hhn%c%2$hhn%c%3$hhn%c%4$hhn”, buf, buf+1, buf+2, buf+3);</p>

<h3 id="one-more-thing-10c11n">One more thing: <code class="language-plaintext highlighter-rouge">%*10$c%11$n</code></h3>

<p>specifies a <em>dynamic padding size</em>. This will:</p>

<ol>
  <li>get the 10th parameter</li>
  <li><em>use it as the padding size</em> of a single character</li>
  <li>print that many bytes</li>
  <li>write the number of bytes printed to the memory pointed to by the 11th parameter.</li>
</ol>

<p>This results in a copy.</p>

<h3 id="使用pwntools生成基于printf的exp">使用pwntools生成基于printf的exp</h3>

<p>fmtstr_payload() 和 leak_stack()</p>

<p>详细用法示例可以参考当时的writeup</p>

<h2 id="file-struct-exploits">File Struct Exploits</h2>

<p>攻击面总结：</p>

<ol>
  <li>修改结构体中的缓冲区指针，实现任意地址读写</li>
  <li>覆盖vtable达到控制执行流的目的</li>
</ol>

<p><a href="https://elixir.bootlin.com/linux/latest/source/include/linux/fs.h#L940">fs.h</a></p>

<p><a href="https://elixir.bootlin.com/glibc/glibc-2.31/source/libio/bits/types/struct_FILE.h#L49">FILE</a></p>

<h2 id="堆问题">堆问题</h2>

<p>堆结构比较复杂，分配器多种多样，这里只写了ptmalloc的机制，对堆进行攻击需要对堆的排布比较熟悉（难怪都叫“堆风水”）</p>

<h3 id="ptmalloc设计的cache种类">ptmalloc设计的cache种类:</h3>

<ol>
  <li>
    <p>64 singly-linked tcache bins for allocations of size 16 to 1032 (functionally “covers” fastbins and smallbins)</p>
  </li>
  <li>
    <p>10 singly-linked “fast” bins for allocations of size up to 160 bytes</p>
  </li>
  <li>
    <p>1 doubly-linked “unsorted” bin to quickly stash free()d chunks that don’t fit into tcache or</p>

    <p>fastbins</p>
  </li>
  <li>
    <p>64 doubly-linked “small” bins for allocations up to 512 bytes</p>
  </li>
  <li>
    <p>doubly-linked “large” bins (anything over 512 bytes) that contain different-sized chunks</p>
  </li>
</ol>

<p>双向链表的设计是为了方便合并：合并两个相邻的chunk，合并发生在free和malloc的时候</p>

<h3 id="malloc的简化过程">malloc的简化过程：</h3>

<ol>
  <li>检查tcache，</li>
  <li>fastbin</li>
  <li>检查请求大小，小内存直接通过small bin，</li>
  <li>清理 Fastbin</li>
  <li>检查/sort unsortedbins(chunk如果太小，会被移动到small bins或者large bins中，如果大于请求的大小则会分割一块出来，剩下的放回unsortbins中，然后返回，不会继续遍历chunks)</li>
  <li>large bin</li>
  <li>mmap或者从heap剩下的空间里分配</li>
</ol>

<p>free由于cache有很多种，所以比较复杂。</p>

<p>几种bin的放置顺序：</p>

<ol>
  <li>先检查M标志是否被设置，如果是的话，直接munmap掉</li>
  <li>检查是否可以放入tcache</li>
  <li>不能再检查fastbin是否满足</li>
  <li>不能放入fastbin，检查M标志是否被设置，如果是的话，直接munmap掉（不知道为啥检查两次）</li>
  <li>清理合并fastbins</li>
  <li>放到unsorted bin中，并后向合并</li>
</ol>

<h3 id="tcacheglibc-226引入">tcache(glibc-2.26引入)</h3>

<p>tcache:a <strong>caching</strong> layer for “small” allocations (&lt;1032 bytes on amd64)</p>

<p>有关结构题的定义：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* There is one of these for each thread, which contains the
   per-thread cache (hence "tcache_perthread_struct").  Keeping
   overall size low is mildly important.  Note that COUNTS and ENTRIES
   are redundant (we could have just counted the linked list each
   time), this is for performance reasons.  */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">tcache_perthread_struct</span>
<span class="p">{</span>
  <span class="kt">uint16_t</span> <span class="n">counts</span><span class="p">[</span><span class="n">TCACHE_MAX_BINS</span><span class="p">];</span>
  <span class="n">tcache_entry</span> <span class="o">*</span><span class="n">entries</span><span class="p">[</span><span class="n">TCACHE_MAX_BINS</span><span class="p">];</span>
<span class="p">}</span> <span class="n">tcache_perthread_struct</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">tcache_entry</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">tcache_entry</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
  <span class="cm">/* This field exists to detect double frees.  */</span>
  <span class="k">struct</span> <span class="n">tcache_perthread_struct</span> <span class="o">*</span><span class="n">key</span><span class="p">;</span>
<span class="p">}</span> <span class="n">tcache_entry</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">malloc_chunk</span> <span class="p">{</span>

  <span class="n">INTERNAL_SIZE_T</span>      <span class="n">mchunk_prev_size</span><span class="p">;</span>  <span class="cm">/* Size of previous chunk (if free).  */</span>
  <span class="n">INTERNAL_SIZE_T</span>      <span class="n">mchunk_size</span><span class="p">;</span>       <span class="cm">/* Size in bytes, including overhead. */</span>

  <span class="k">struct</span> <span class="n">malloc_chunk</span><span class="o">*</span> <span class="n">fd</span><span class="p">;</span>         <span class="cm">/* double links -- used only if free. */</span>
  <span class="k">struct</span> <span class="n">malloc_chunk</span><span class="o">*</span> <span class="n">bk</span><span class="p">;</span>

  <span class="cm">/* Only used for large blocks: pointer to next larger size.  */</span>
  <span class="k">struct</span> <span class="n">malloc_chunk</span><span class="o">*</span> <span class="n">fd_nextsize</span><span class="p">;</span> <span class="cm">/* double links -- used only if free. */</span>
  <span class="k">struct</span> <span class="n">malloc_chunk</span><span class="o">*</span> <span class="n">bk_nextsize</span><span class="p">;</span>
<span class="p">};</span>
<span class="cm">/* size field is or'ed with PREV_INUSE when previous adjacent chunk in use */</span>
<span class="cp">#define PREV_INUSE 0x1
</span>
<span class="cm">/* extract inuse bit of previous chunk */</span>
<span class="cp">#define prev_inuse(p)       ((p)-&gt;mchunk_size &amp; PREV_INUSE)
</span>

<span class="cm">/* size field is or'ed with IS_MMAPPED if the chunk was obtained with mmap() */</span>
<span class="cp">#define IS_MMAPPED 0x2
</span>
<span class="cm">/* check for mmap()'ed chunk */</span>
<span class="cp">#define chunk_is_mmapped(p) ((p)-&gt;mchunk_size &amp; IS_MMAPPED)
</span>

<span class="cm">/* size field is or'ed with NON_MAIN_ARENA if the chunk was obtained
   from a non-main arena.  This is only set immediately before handing
   the chunk to the user, if necessary.  */</span>
<span class="cp">#define NON_MAIN_ARENA 0x4
</span></code></pre></div></div>

<p>chunk的结构：</p>

<p>allocated chunk:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |             Size of previous chunk, if unallocated (P clear)  |
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |             Size of chunk, in bytes                     |A|M|P|
      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |             User data starts here...                          .
	    .                                                               .
	    .             (malloc_usable_size() bytes)                      .
	    .                                                               |
nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |             (size of chunk, but used for application data)    |
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |             Size of next chunk, in bytes                |A|0|1|
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

</code></pre></div></div>

<p>free chunk:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |             Size of previous chunk, if unallocated (P clear)  |
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    `head:' |             Size of chunk, in bytes                     |A|0|P|
      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |             Forward pointer to next chunk in list             |
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |             Back pointer to previous chunk in list            |
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |             Unused space (may be 0 bytes long)                .
	    .                                                               .
	    .                                                               |
nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    `foot:' |             Size of chunk, in bytes                           |
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |             Size of next chunk, in bytes                |A|0|0|
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

</code></pre></div></div>

<p>单链表结构</p>

<p>alloca过程：</p>

<ol>
  <li>
    <p>Select: 根据请求的size选择合适的bin，索引<code class="language-plaintext highlighter-rouge">idx = (requested_size - 1) / 16;</code></p>
  </li>
  <li>
    <p>Check: 检查是否有空闲的cache可用 <code class="language-plaintext highlighter-rouge">if our_tcache_perthread_struct.count[idx] &gt; 0;</code></p>
  </li>
  <li>
    <p>Reuse: 如果可用，分配链表头部的chunk</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>unsigned long *to_return = our_tcache_perthread_struct.entries[idx];
tcache_perthread_struct.entries[idx] = to_return[0];
tcache_perthread_struct.count[idx]--;
return to_return;
</code></pre></div>    </div>
  </li>
  <li>
    <p>Clear:  key清空</p>
  </li>
  <li>
    <p>Checking: 检查下一个链表指针是否合法</p>
  </li>
</ol>

<h4 id="防护">防护</h4>

<h5 id="key是在glibc-229引入主要是为了防止double-free的问题">Key是在glibc-2.29引入主要是为了防止double-free的问题。</h5>

<h5 id="safe-linking-glibc-232引入">Safe-linking （glibc-2.32引入）</h5>

<p>tcache中的next指针被xor处理保存(mangle)。</p>

<p>demangle后的值低4位必须是0。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define PROTECT_PTR(pos, ptr)
</span><span class="p">((</span><span class="n">__typeof</span> <span class="p">(</span><span class="n">ptr</span><span class="p">))</span> <span class="p">((((</span><span class="kt">size_t</span><span class="p">)</span> <span class="n">pos</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">)</span> <span class="o">^</span> <span class="p">((</span><span class="kt">size_t</span><span class="p">)</span> <span class="n">ptr</span><span class="p">)))</span>
<span class="cp">#define REVEAL_PTR(ptr) PROTECT_PTR (&amp;ptr, ptr)
</span></code></pre></div></div>

<h3 id="注意点-1">注意点</h3>

<p>printf，scanf将会使用malloc，</p>

<p>可以用setbuf禁用:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">setbuf</span> <span class="p">(</span><span class="n">stdout</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="n">setbuf</span><span class="p">(</span><span class="n">stdin</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="fastbins">Fastbins</h3>

<ol>
  <li>单链表并且也有safe-linking机制，与tcache相似</li>
  <li>链表没有长度限制，tcache限制有7个</li>
  <li>大小支持到88byte，tcach可以支持到1032</li>
  <li>P标志位会被永远设置，阻止合并</li>
  <li>double free检测只支持最顶部的chunk检测（由于它没有长度限制，都检测一遍那还了得，还干不干别的事了）</li>
</ol>

<h3 id="small-bins">Small bins</h3>

<ol>
  <li>双向链表</li>
  <li>大小支持到1024 bytes</li>
  <li>Fast access，但是支持合并</li>
</ol>

<h3 id="unsorted-bins">unsorted bins</h3>

<ol>
  <li>双向链表</li>
  <li>存放large bins和small bins，因此任何无法放进fastbins的都可以放这里</li>
  <li>malloc的时候这个unsorted bins会被检查，如果chunk不满足malloc，它就会被放进合适的small/large bins</li>
</ol>

<h3 id="large-bins">large bins</h3>

<ol>
  <li>双向链表</li>
  <li>bins包含 a range of size</li>
  <li>这意味着每个bin都被排好序，最大的在前</li>
  <li>bk_nextsize is used “jump up” in size category quickly，因为bins包含的是size的范围，这样如果区间没有大于请求的大小的chunk，就可以直接通过这个jump up到下一个区间的chunk里不需要再回bin中去遍历了。</li>
</ol>

<h3 id="exploitions">exploitions</h3>

<ul>
  <li>
    <p>Double Free</p>
  </li>
  <li>
    <p>Use After Free</p>
  </li>
  <li>
    <p>Corrupting Heap Metadata</p>
  </li>
  <li>
    <p>Overlapping Allocations</p>
  </li>
</ul>

<h2 id="linux内核">Linux内核</h2>

<p><a href="https://github.com/seacho/writeup/tree/main/pwncollege/kernelExp">writeup</a></p>

<h2 id="基于cpu缓存的攻击">基于CPU缓存的攻击</h2>

<p>详见<a href="https://github.com/seacho/writeup/blob/main/pwncollege/microarchitecture/meltdown.c">demo</a></p>]]></content><author><name>樵夫砍柴手札</name><email>p1ain0@outlook.com</email></author><category term="PWN" /><summary type="html"><![CDATA[最近刚刚在pwn.college上已经获得了蓝带，现在总结下：]]></summary></entry></feed>