<!DOCTYPE html>
<html class="no-js">
	<head>
	<meta charset="utf-8">

	

	<title>fuzzingbook阅读笔记 | kaka</title>
	
	<meta name="description" content="最近学习的fuzz技术，简单做下笔记。">
	

	<meta name="viewport" content="width=device-width, initial-scale=1">

	<!-- CSS -->
	<link rel="stylesheet" href="/css/main.css">

	<!--Favicon-->
	<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

	<!-- Canonical -->
	<link rel="canonical" href="http://localhost:4000/2025/03/fuzzingbook-study/">

	<!-- RSS -->
	<link rel="alternate" type="application/atom+xml" title="kaka" href="http://localhost:4000/feed.xml">

	<!-- Font Awesome -->
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

	

	
</head>

	<body>
		<header class="site-header">
	
	<h1 class="site-title">
		<a href="/">kaka</a>
	</h1>
	<div class="space padding"></div>
	<nav class="site-navigation">
		<ul>
			
			
			
			
			
			
			<li>
				<a class="page-link" href="/about/">
					About
				</a>
			</li>
			
			
			
			
			
			
			
			
			
			
			

<li>
	<a href="/feed.xml" title="RSS feed">
			<i class="fa fa-fw fa-rss"></i>
	</a>
</li>



<li>
	<a href="https://github.com/seacho" title="Github">
			<i class="fa fa-fw fa-github"></i>
	</a>
</li>



<li>
	<a href="mailto:assdfgzxcv4@gmail.com" title="Email">
			<i class="fa fa-fw fa-envelope"></i>
	</a>
</li>



		</ul>
	</nav>
</header>

		<div class="content">
			<article class="post">
	<header>
		<h1 class="title">fuzzingbook阅读笔记</h1>
		<p class="byline-dateline">
	
	<span class="dateline">March 24, 2025</span>
</p>


	</header>
	<section class="post-content"><p>最近学习的fuzz技术，简单做下笔记。</p>

<!--more-->

<h2 id="coverage">coverage</h2>

<p>cc –coverage -o cgi_decode cgi_decode.c</p>

<p>gcov cgi_decode cgi_decode-cgi_decode</p>

<p>cgi_decode.c.gcov</p>

<p>In the .gcov file, each line is prefixed with the number of times it was called (- stands for a non-executable line, ##### stands for zero) as well as the line number. We can take a look at cgi_decode(), for instance, and see that the only code not executed yet is the return -1 for an illegal input.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">def</span> <span class="nf">read_gcov_coverage</span><span class="p">(</span><span class="n">c_file</span><span class="p">):</span>
    <span class="n">gcov_file</span> <span class="o">=</span> <span class="n">c_file</span> <span class="o">+</span> <span class="s">".gcov"</span>
    <span class="n">coverage</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">gcov_file</span><span class="p">)</span> <span class="k">as</span> <span class="nb">file</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">file</span><span class="p">.</span><span class="n">readlines</span><span class="p">():</span>
            <span class="n">elems</span> <span class="o">=</span> <span class="n">line</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">':'</span><span class="p">)</span>
            <span class="n">covered</span> <span class="o">=</span> <span class="n">elems</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">strip</span><span class="p">()</span>
            <span class="n">line_number</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">elems</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">strip</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">covered</span><span class="p">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">'-'</span><span class="p">)</span> <span class="ow">or</span> <span class="n">covered</span><span class="p">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">'#'</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="n">coverage</span><span class="p">.</span><span class="n">add</span><span class="p">((</span><span class="n">c_file</span><span class="p">,</span> <span class="n">line_number</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">coverage</span>


<span class="n">coverage</span> <span class="o">=</span> <span class="n">read_gcov_coverage</span><span class="p">(</span><span class="s">'cgi_decode.c'</span><span class="p">)</span>    

</code></pre></div></div>

<h2 id="greybox-fuzzing">Greybox Fuzzing</h2>

<p>power schedule：我们的目标是最大限度地利用fuzz的seed所花费的时间，从而在更短的时间内实现更高的覆盖率。于是我们给seed的优先级排个序。我们定义seed的被选择的可能性叫做，seed’s energy 在整个模糊测试过程中，我们希望优先考虑更有希望的seed，我们将确定seed ‘s power的过程称为模糊器的power schedule。</p>

<h2 id="search-based-fuzzing">Search-Based Fuzzing</h2>

<p>启发式比彻底的搜索要高效。</p>

<p>基本思想：</p>

<h3 id="fitness-function">fitness function</h3>

<p>定义一个Fitness function，所有的启发式算法（meta-heuristics）都是基于启发式（heuristics）函数的使用，该函数用来估计给定候选方案的好坏。这种“goodness”被称为个体的“fitness”。适应度函数是将搜索空间中的任何点映射到数值（适应度值）的函数。搜索空间中的候选解相对于最优解越好，其适应度值就越好。</p>

<p>比如，下面这个例子</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">test_me</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>

<span class="k">def</span> <span class="nf">calculate_distance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
  <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>


</code></pre></div></div>

<p>我们可以使用这个距离值作为我们的适应度函数，因为我们可以很好地衡量我们离最优解有多近。然而，请注意，在这种情况下，距离越小越好。</p>

<p>适应度函数应计算具体测试执行的距离值。也就是说，我们想运行程序，然后学习这次执行的距离值。但是分支条件隐藏在目标函数的源代码中，其值可能是沿着到达它的执行路径进行的各种计算的结果。即使在我们的例子中，该条件是一个直接使用函数输入值的方程，但通常情况并非如此，它可能和衍生出来值一样。因此，我们需要在条件语句中直接观察到计算距离度量所需的值。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">def</span> <span class="nf">test_me_instrumented</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>  <span class="c1"># type: ignore
</span>    <span class="k">global</span> <span class="n">distance</span>
    <span class="n">distance</span> <span class="o">=</span> <span class="n">calculate_distance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>

<span class="k">def</span> <span class="nf">get_fitness</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
  <span class="k">global</span> <span class="n">distance</span>
  <span class="n">test_me_instrumented</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
  <span class="n">fitness</span> <span class="o">=</span> <span class="n">distance</span>
  <span class="k">return</span> <span class="n">fitness</span>

</code></pre></div></div>

<h3 id="hillclimbing-算法">Hillclimbing 算法</h3>

<p>让我们使用最简单的元启发式算法来探索这个搜索空间，Hillclimbing算法。（跟机器学习有点像）</p>

<p>在确定了表示（整数的两个元组）和适应度函数（到目标分支的距离）之后。我们来看这个算法，该算法试图在我们的表示定义的搜索空间中寻找最优解。但是在我们的搜索环境中，最好的值不是那些高的值，而是低的值。（下山更形象）。算法本身非常简单：
1.取一个随机起点
2.确定所有邻居的适应度值
3.移动到具有最佳健身值的邻居
4.如果未找到解决方案，请继续执行步骤2</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">LOG_VALUES</span> <span class="o">=</span> <span class="mi">20</span>  <span class="c1"># Number of values to log
</span><span class="k">def</span> <span class="nf">hillclimber</span><span class="p">():</span>
    <span class="c1"># Create and evaluate starting point
</span>    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="n">randint</span><span class="p">(</span><span class="n">MIN</span><span class="p">,</span> <span class="n">MAX</span><span class="p">),</span> <span class="n">random</span><span class="p">.</span><span class="n">randint</span><span class="p">(</span><span class="n">MIN</span><span class="p">,</span> <span class="n">MAX</span><span class="p">)</span>
    <span class="n">fitness</span> <span class="o">=</span> <span class="n">get_fitness</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"Initial value: %d, %d at fitness %.4f"</span> <span class="o">%</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">fitness</span><span class="p">))</span>
    <span class="n">iterations</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">logs</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># Stop once we have found an optimal solution
</span>    <span class="k">while</span> <span class="n">fitness</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">iterations</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># Move to first neighbor with a better fitness
</span>        <span class="k">for</span> <span class="p">(</span><span class="n">nextx</span><span class="p">,</span> <span class="n">nexty</span><span class="p">)</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
            <span class="n">new_fitness</span> <span class="o">=</span> <span class="n">get_fitness</span><span class="p">(</span><span class="n">nextx</span><span class="p">,</span> <span class="n">nexty</span><span class="p">)</span>

            <span class="c1"># Smaller fitness values are better
</span>            <span class="k">if</span> <span class="n">new_fitness</span> <span class="o">&lt;</span> <span class="n">fitness</span><span class="p">:</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">nextx</span><span class="p">,</span> <span class="n">nexty</span>
                <span class="n">fitness</span> <span class="o">=</span> <span class="n">new_fitness</span>
                <span class="k">if</span> <span class="n">logs</span> <span class="o">&lt;</span> <span class="n">LOG_VALUES</span><span class="p">:</span>
                    <span class="k">print</span><span class="p">(</span><span class="s">"New value: %d, %d at fitness %.4f"</span> <span class="o">%</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">fitness</span><span class="p">))</span>
                <span class="k">elif</span> <span class="n">logs</span> <span class="o">==</span> <span class="n">LOG_VALUES</span><span class="p">:</span>
                    <span class="k">print</span><span class="p">(</span><span class="s">"..."</span><span class="p">)</span>
                <span class="n">logs</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">break</span>

    <span class="k">print</span><span class="p">(</span><span class="s">"Found optimum after %d iterations at %d, %d"</span> <span class="o">%</span> <span class="p">(</span><span class="n">iterations</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>

</code></pre></div></div>

<p>首先为x和y选择随机值。我们使用-1000–1000范围内的低值来减少玩这个例子时的搜索时间。然后，我们通过调用get_fitness来确定这个起点的适应度值。我们正试图找到最小的适应度值，因此我们现在循环，直到找到适应度值0（即最佳值）。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">steepest_ascent_hillclimber</span><span class="p">():</span>
  <span class="c1"># Create and evaluate starting point
</span>  <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="n">randint</span><span class="p">(</span><span class="n">MIN</span><span class="p">,</span> <span class="n">MAX</span><span class="p">),</span> <span class="n">random</span><span class="p">.</span><span class="n">randint</span><span class="p">(</span><span class="n">MIN</span><span class="p">,</span> <span class="n">MAX</span><span class="p">)</span>
  <span class="n">fitness</span> <span class="o">=</span> <span class="n">get_fitness</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
  <span class="k">print</span><span class="p">(</span><span class="s">"Initial value: %d, %d at fitness %.4f"</span> <span class="o">%</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">fitness</span><span class="p">))</span>
  <span class="n">iterations</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="n">logs</span> <span class="o">=</span> <span class="mi">0</span>

  <span class="c1"># Stop once we have found an optimal solution
</span>  <span class="k">while</span> <span class="n">fitness</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
      <span class="n">iterations</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="c1"># Move to first neighbor with a better fitness
</span>      <span class="k">for</span> <span class="p">(</span><span class="n">nextx</span><span class="p">,</span> <span class="n">nexty</span><span class="p">)</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
          <span class="n">new_fitness</span> <span class="o">=</span> <span class="n">get_fitness</span><span class="p">(</span><span class="n">nextx</span><span class="p">,</span> <span class="n">nexty</span><span class="p">)</span>
          <span class="k">if</span> <span class="n">new_fitness</span> <span class="o">&lt;</span> <span class="n">fitness</span><span class="p">:</span>
              <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">nextx</span><span class="p">,</span> <span class="n">nexty</span>
              <span class="n">fitness</span> <span class="o">=</span> <span class="n">new_fitness</span>
              <span class="k">if</span> <span class="n">logs</span> <span class="o">&lt;</span> <span class="n">LOG_VALUES</span><span class="p">:</span>
                  <span class="k">print</span><span class="p">(</span><span class="s">"New value: %d, %d at fitness %.4f"</span> <span class="o">%</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">fitness</span><span class="p">))</span>
              <span class="k">elif</span> <span class="n">logs</span> <span class="o">==</span> <span class="n">LOG_VALUES</span><span class="p">:</span>
                  <span class="k">print</span><span class="p">(</span><span class="s">"..."</span><span class="p">)</span>
              <span class="n">logs</span> <span class="o">+=</span> <span class="mi">1</span>

  <span class="k">print</span><span class="p">(</span><span class="s">"Found optimum after %d iterations at %d, %d"</span> <span class="o">%</span> <span class="p">(</span><span class="n">iterations</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>


</code></pre></div></div>

<p>但有一个问题：用这个运行我们的登山者不是一个最优的方案，因为它可能永远不会终止。假设我们已经达到了一个点，所有邻居的适应度值都相同或更差。登山者无法移动，永远被困在那里！搜索环境中的这样一个点称为局部最优点。如果达到这样一个点，最简单的办法就是放弃，从一个新的随机点重新开始。这就是我们将在登山者身上随机重启的方法。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">restarting_hillclimber</span><span class="p">(</span><span class="n">fitness_function</span><span class="p">):</span>
    <span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Create and evaluate starting point
</span>    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="n">randint</span><span class="p">(</span><span class="n">MIN</span><span class="p">,</span> <span class="n">MAX</span><span class="p">),</span> <span class="n">random</span><span class="p">.</span><span class="n">randint</span><span class="p">(</span><span class="n">MIN</span><span class="p">,</span> <span class="n">MAX</span><span class="p">)</span>
    <span class="n">fitness</span> <span class="o">=</span> <span class="n">fitness_function</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">+=</span> <span class="p">[</span><span class="n">fitness</span><span class="p">]</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"Initial value: %d, %d at fitness %.4f"</span> <span class="o">%</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">fitness</span><span class="p">))</span>
    <span class="n">iterations</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># Stop once we have found an optimal solution
</span>    <span class="k">while</span> <span class="n">fitness</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">changed</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">iterations</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># Move to first neighbor with a better fitness
</span>        <span class="k">for</span> <span class="p">(</span><span class="n">nextx</span><span class="p">,</span> <span class="n">nexty</span><span class="p">)</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
            <span class="n">new_fitness</span> <span class="o">=</span> <span class="n">fitness_function</span><span class="p">(</span><span class="n">nextx</span><span class="p">,</span> <span class="n">nexty</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">new_fitness</span> <span class="o">&lt;</span> <span class="n">fitness</span><span class="p">:</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">nextx</span><span class="p">,</span> <span class="n">nexty</span>
                <span class="n">fitness</span> <span class="o">=</span> <span class="n">new_fitness</span>
                <span class="n">data</span> <span class="o">+=</span> <span class="p">[</span><span class="n">fitness</span><span class="p">]</span>
                <span class="n">changed</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">changed</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="n">randint</span><span class="p">(</span><span class="n">MIN</span><span class="p">,</span> <span class="n">MAX</span><span class="p">),</span> <span class="n">random</span><span class="p">.</span><span class="n">randint</span><span class="p">(</span><span class="n">MIN</span><span class="p">,</span> <span class="n">MAX</span><span class="p">)</span>
            <span class="n">fitness</span> <span class="o">=</span> <span class="n">fitness_function</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">+=</span> <span class="p">[</span><span class="n">fitness</span><span class="p">]</span>

    <span class="k">print</span><span class="p">(</span><span class="s">"Found optimum after %d iterations at %d, %d"</span> <span class="o">%</span> <span class="p">(</span><span class="n">iterations</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">data</span>

</code></pre></div></div>

<h3 id="fitness-function-to-create-valid-hexadecimal-inputs">Fitness Function to Create Valid Hexadecimal Inputs</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">get_fitness_cgi</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="c1"># Reset any distance values from previous executions
</span>    <span class="k">global</span> <span class="n">distances_true</span><span class="p">,</span> <span class="n">distances_false</span>
    <span class="n">distances_true</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">distances_false</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># Run the function under test
</span>    <span class="k">try</span><span class="p">:</span>
        <span class="n">cgi_decode_instrumented</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">except</span> <span class="nb">BaseException</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="c1"># Sum up branch distances
</span>    <span class="n">fitness</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">for</span> <span class="n">branch</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">branch</span> <span class="ow">in</span> <span class="n">distances_true</span><span class="p">:</span>
            <span class="n">fitness</span> <span class="o">+=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">distances_true</span><span class="p">[</span><span class="n">branch</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fitness</span> <span class="o">+=</span> <span class="mf">1.0</span>

    <span class="k">for</span> <span class="n">branch</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">branch</span> <span class="ow">in</span> <span class="n">distances_false</span><span class="p">:</span>
            <span class="n">fitness</span> <span class="o">+=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">distances_false</span><span class="p">[</span><span class="n">branch</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fitness</span> <span class="o">+=</span> <span class="mf">1.0</span>

    <span class="k">return</span> <span class="n">fitness</span>


</code></pre></div></div>

<h3 id="具体应用到现实程序中">具体应用到现实程序中</h3>

<p>假设我们现在有一个这样的程序</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">def</span> <span class="nf">cgi_decode</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="s">"""Decode the CGI-encoded string `s`:
       * replace "+" by " "
       * replace "%xx" by the character with hex number xx.
       Return the decoded string.  Raise `ValueError` for invalid inputs."""</span>

    <span class="c1"># Mapping of hex digits to their integer values
</span>    <span class="n">hex_values</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s">'0'</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s">'1'</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s">'2'</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s">'3'</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s">'4'</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
        <span class="s">'5'</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="s">'6'</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span> <span class="s">'7'</span><span class="p">:</span> <span class="mi">7</span><span class="p">,</span> <span class="s">'8'</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span> <span class="s">'9'</span><span class="p">:</span> <span class="mi">9</span><span class="p">,</span>
        <span class="s">'a'</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="s">'b'</span><span class="p">:</span> <span class="mi">11</span><span class="p">,</span> <span class="s">'c'</span><span class="p">:</span> <span class="mi">12</span><span class="p">,</span> <span class="s">'d'</span><span class="p">:</span> <span class="mi">13</span><span class="p">,</span> <span class="s">'e'</span><span class="p">:</span> <span class="mi">14</span><span class="p">,</span> <span class="s">'f'</span><span class="p">:</span> <span class="mi">15</span><span class="p">,</span>
        <span class="s">'A'</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="s">'B'</span><span class="p">:</span> <span class="mi">11</span><span class="p">,</span> <span class="s">'C'</span><span class="p">:</span> <span class="mi">12</span><span class="p">,</span> <span class="s">'D'</span><span class="p">:</span> <span class="mi">13</span><span class="p">,</span> <span class="s">'E'</span><span class="p">:</span> <span class="mi">14</span><span class="p">,</span> <span class="s">'F'</span><span class="p">:</span> <span class="mi">15</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="n">t</span> <span class="o">=</span> <span class="s">""</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="s">'+'</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">+=</span> <span class="s">' '</span>
        <span class="k">elif</span> <span class="n">c</span> <span class="o">==</span> <span class="s">'%'</span><span class="p">:</span>
            <span class="n">digit_high</span><span class="p">,</span> <span class="n">digit_low</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span>
            <span class="k">if</span> <span class="n">digit_high</span> <span class="ow">in</span> <span class="n">hex_values</span> <span class="ow">and</span> <span class="n">digit_low</span> <span class="ow">in</span> <span class="n">hex_values</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">hex_values</span><span class="p">[</span><span class="n">digit_high</span><span class="p">]</span> <span class="o">*</span> <span class="mi">16</span> <span class="o">+</span> <span class="n">hex_values</span><span class="p">[</span><span class="n">digit_low</span><span class="p">]</span>
                <span class="n">t</span> <span class="o">+=</span> <span class="nb">chr</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="nb">ValueError</span><span class="p">(</span><span class="s">"Invalid encoding"</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">+=</span> <span class="n">c</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">t</span>  
</code></pre></div></div>

<p>我们现在建模定义它的临点和评估每个点好坏的函数：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">def</span> <span class="nf">neighbor_strings</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="n">c</span> <span class="o">=</span> <span class="nb">ord</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="mi">126</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">+=</span> <span class="p">[</span><span class="n">x</span><span class="p">[:</span><span class="n">pos</span><span class="p">]</span> <span class="o">+</span> <span class="nb">chr</span><span class="p">(</span><span class="n">c</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]]</span>
        <span class="k">if</span> <span class="n">c</span> <span class="o">&gt;</span> <span class="mi">32</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">+=</span> <span class="p">[</span><span class="n">x</span><span class="p">[:</span><span class="n">pos</span><span class="p">]</span> <span class="o">+</span> <span class="nb">chr</span><span class="p">(</span><span class="n">c</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]]</span>
    <span class="k">return</span> <span class="n">n</span>

<span class="k">def</span> <span class="nf">distance_character</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>

  <span class="c1"># Initialize with very large value so that any comparison is better
</span>  <span class="n">minimum</span> <span class="o">=</span> <span class="n">sys</span><span class="p">.</span><span class="n">maxsize</span>

  <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
      <span class="n">distance</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">target</span> <span class="o">-</span> <span class="n">elem</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">distance</span> <span class="o">&lt;</span> <span class="n">minimum</span><span class="p">:</span>
          <span class="n">minimum</span> <span class="o">=</span> <span class="n">distance</span>
  <span class="k">return</span> <span class="n">minimum</span>
</code></pre></div></div>

<p>到目前为止，我们假设我们总是希望条件评估为true，实际情况我们也可能希望我们的条件评估为false。因此，每个if条件实际上都有两个距离估计，一个用于估计它离真有多近，一个是估计它离假有多近。如果条件为真，则true distance 为0；如果条件为假，则false distance为0。</p>

<p>更一般地说，可以有其他类型的比较，例如使用关系运算符。考虑cgi_decode（）中的循环条件：i&lt;len（s），即它使用小于比较运算符。将我们的分支距离概念扩展到涵盖不同类型的比较，并计算真距离和假距离，这是非常简单的。下表显示了如何计算不同类型比较的距离：</p>

<table>
  <thead>
    <tr>
      <th>Condition</th>
      <th>Distance True</th>
      <th>Distance False</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>a == b</td>
      <td>abs(a - b)</td>
      <td>1</td>
    </tr>
    <tr>
      <td>a != b</td>
      <td>1</td>
      <td>abs(a - b)</td>
    </tr>
    <tr>
      <td>a &lt; b</td>
      <td>b - a + 1</td>
      <td>a - b</td>
    </tr>
    <tr>
      <td>a &lt;= b</td>
      <td>b - a</td>
      <td>a - b + 1</td>
    </tr>
    <tr>
      <td>a &gt; b</td>
      <td>a - b + 1</td>
      <td>b - a</td>
    </tr>
  </tbody>
</table>

<p>请注意，其中一些计算添加了一个常数1。原因很简单：假设我们想让a&lt;b求值为真，让a=27和b=27。条件不成立，但简单地取差值会得到0的结果。为了避免这种情况，我们必须添加一个常量值。这个值是否为1并不重要——任何正常数都有效。</p>

<p>在cgi_decode（）函数中，我们还可以找到一个更复杂的谓词，它由两个条件组成，由逻辑和连接：</p>

<p><code class="language-plaintext highlighter-rouge">if digit_high in hex_values and digit_low in hex_values:</code></p>

<p>原则上，分支距离的定义是，使连接A和B为真的距离等于A和B的分支距离之和，因为这两个条件都需要为真。同样，使A或B为真的分支距离将是A和B的两个分支距离中的最小值，因为如果这两个条件之一为真，则足以使整个表达式为真。</p>

<p>但是，这在实践中并不像那么容易：谓词可以由嵌套条件和否定组成，在能够应用此计算之前，需要将表达式转换为规范形式。此外，大多数现代编程语言都使用短路求值：如果存在条件A或B，并且A为真，则B永远不会被求值。如果B是一个有函数调用的表达式，那么通过计算B的分支距离，即使短路评估会避免其执行，我们也可能会改变程序行为（通过调用在正常行为中不会执行的调用函数），这就有问题了。</p>

<p>使用全局变量和临时变量的另一种方法是用对辅助函数的调用替换实际比较，其中原始表达式被视为参数，运算符是一个额外的参数。假设我们有一个函数evaluate_condition（），它有四个参数：
num是标识条件的唯一id；
op是比较的运算符；
lhs和rhs是操作数。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">evaluate_condition</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
    <span class="n">distance_true</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">distance_false</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="s">"Eq"</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">lhs</span> <span class="o">==</span> <span class="n">rhs</span><span class="p">:</span>
            <span class="n">distance_false</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">distance_true</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">lhs</span> <span class="o">-</span> <span class="n">rhs</span><span class="p">)</span>

    <span class="c1"># ... code for other types of conditions
</span>
    <span class="k">if</span> <span class="n">distance_true</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>


</code></pre></div></div>

<p>evaluate_condition（）函数还没有存储观测到的距离。显然，我们需要将值存储在某个地方，以便我们可以从健身函数访问它。由于cgi_decode（）程序由几个条件组成，对于每个条件，我们可能对真距离和假距离感兴趣，因此我们只需使用两个全局字典distances_true和distances_false，并定义一个辅助函数来存储字典中观察到的距离值：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">update_maps</span><span class="p">(</span><span class="n">condition_num</span><span class="p">,</span> <span class="n">d_true</span><span class="p">,</span> <span class="n">d_false</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">distances_true</span><span class="p">,</span> <span class="n">distances_false</span>

    <span class="k">if</span> <span class="n">condition_num</span> <span class="ow">in</span> <span class="n">distances_true</span><span class="p">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">distances_true</span><span class="p">[</span><span class="n">condition_num</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
            <span class="n">distances_true</span><span class="p">[</span><span class="n">condition_num</span><span class="p">],</span> <span class="n">d_true</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">distances_true</span><span class="p">[</span><span class="n">condition_num</span><span class="p">]</span> <span class="o">=</span> <span class="n">d_true</span>

    <span class="k">if</span> <span class="n">condition_num</span> <span class="ow">in</span> <span class="n">distances_false</span><span class="p">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">distances_false</span><span class="p">[</span><span class="n">condition_num</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
            <span class="n">distances_false</span><span class="p">[</span><span class="n">condition_num</span><span class="p">],</span> <span class="n">d_false</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">distances_false</span><span class="p">[</span><span class="n">condition_num</span><span class="p">]</span> <span class="o">=</span> <span class="n">d_false</span>

</code></pre></div></div>

<p>但是如果条件复杂了如何，在Python中，使用程序的抽象语法树（AST）自动替换比较实际上非常容易。在AST中，比较通常是一个具有运算符属性的树节点，以及左侧和右侧运算符的两个子节点。要用evaluate_condition（）调用替换这样的比较，只需将AST中的比较节点替换为函数调用节点，BranchTransformer类就是这样使用Python AST模块中的NodeTransformer的：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kn">import</span> <span class="nn">ast</span>
  <span class="k">class</span> <span class="nc">BranchTransformer</span><span class="p">(</span><span class="n">ast</span><span class="p">.</span><span class="n">NodeTransformer</span><span class="p">):</span>

    <span class="n">branch_num</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">visit_FunctionDef</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="n">node</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">name</span> <span class="o">+</span> <span class="s">"_instrumented"</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">generic_visit</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_Compare</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">ops</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="n">ast</span><span class="p">.</span><span class="n">Is</span><span class="p">,</span> <span class="n">ast</span><span class="p">.</span><span class="n">IsNot</span><span class="p">,</span> <span class="n">ast</span><span class="p">.</span><span class="n">In</span><span class="p">,</span> <span class="n">ast</span><span class="p">.</span><span class="n">NotIn</span><span class="p">]:</span>
            <span class="k">return</span> <span class="n">node</span>

        <span class="bp">self</span><span class="p">.</span><span class="n">branch_num</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">ast</span><span class="p">.</span><span class="n">Call</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="n">ast</span><span class="p">.</span><span class="n">Name</span><span class="p">(</span><span class="s">"evaluate_condition"</span><span class="p">,</span> <span class="n">ast</span><span class="p">.</span><span class="n">Load</span><span class="p">()),</span>
                        <span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="n">ast</span><span class="p">.</span><span class="n">Num</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">branch_num</span><span class="p">),</span>
                              <span class="n">ast</span><span class="p">.</span><span class="n">Str</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">ops</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">__class__</span><span class="p">.</span><span class="n">__name__</span><span class="p">),</span>
                              <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">,</span>
                              <span class="n">node</span><span class="p">.</span><span class="n">comparators</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                        <span class="n">keywords</span><span class="o">=</span><span class="p">[],</span>
                        <span class="n">starargs</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                        <span class="n">kwargs</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>


<span class="n">source</span> <span class="o">=</span> <span class="n">inspect</span><span class="p">.</span><span class="n">getsource</span><span class="p">(</span><span class="n">cgi_decode</span><span class="p">)</span>
<span class="n">node</span> <span class="o">=</span> <span class="n">ast</span><span class="p">.</span><span class="n">parse</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
<span class="n">BranchTransformer</span><span class="p">().</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

<span class="c1"># Make sure the line numbers are ok before printing
</span><span class="n">node</span> <span class="o">=</span> <span class="n">ast</span><span class="p">.</span><span class="n">fix_missing_locations</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
<span class="n">print_content</span><span class="p">(</span><span class="n">ast</span><span class="p">.</span><span class="n">unparse</span><span class="p">(</span><span class="n">node</span><span class="p">),</span> <span class="s">'.py'</span><span class="p">)</span>


</code></pre></div></div>

<h3 id="evolutionary-search">Evolutionary Search</h3>

<p>如果搜索空间很小，hillclimbing自然挺好，但是如果是UNICODE呢，所以我们可以在hillclimb之前做点更改提高效率，比如让它迭代100次，而不是全部迭代完。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">terminal_repr</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">terminal_escape</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">hillclimb_cgi_limited</span><span class="p">(</span><span class="n">max_iterations</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">random_unicode_string</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">fitness</span> <span class="o">=</span> <span class="n">get_fitness_cgi</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"Initial input: %s at fitness %.4f"</span> <span class="o">%</span> <span class="p">(</span><span class="n">terminal_repr</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">fitness</span><span class="p">))</span>

    <span class="n">iteration</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">logs</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">fitness</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">iteration</span> <span class="o">&lt;</span> <span class="n">max_iterations</span><span class="p">:</span>
        <span class="n">changed</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">nextx</span><span class="p">)</span> <span class="ow">in</span> <span class="n">unicode_string_neighbors</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="n">new_fitness</span> <span class="o">=</span> <span class="n">get_fitness_cgi</span><span class="p">(</span><span class="n">nextx</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">new_fitness</span> <span class="o">&lt;</span> <span class="n">fitness</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">nextx</span>
                <span class="n">fitness</span> <span class="o">=</span> <span class="n">new_fitness</span>
                <span class="n">changed</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">if</span> <span class="n">logs</span> <span class="o">&lt;</span> <span class="n">LOG_VALUES</span><span class="p">:</span>
                    <span class="k">print</span><span class="p">(</span><span class="s">"New value: %s at fitness %.4f"</span> <span class="o">%</span>
                          <span class="p">(</span><span class="n">terminal_repr</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">fitness</span><span class="p">))</span>
                <span class="k">elif</span> <span class="n">logs</span> <span class="o">==</span> <span class="n">LOG_VALUES</span><span class="p">:</span>
                    <span class="k">print</span><span class="p">(</span><span class="s">"..."</span><span class="p">)</span>
                <span class="n">logs</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">break</span>

        <span class="c1"># Random restart if necessary
</span>        <span class="k">if</span> <span class="ow">not</span> <span class="n">changed</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">random_string</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
            <span class="n">fitness</span> <span class="o">=</span> <span class="n">get_fitness_cgi</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">iteration</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">print</span><span class="p">(</span><span class="s">"Optimum at %s, fitness %.4f"</span> <span class="o">%</span> <span class="p">(</span><span class="n">terminal_repr</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">fitness</span><span class="p">))</span>

</code></pre></div></div>

<h2 id="global-search">Global Search</h2>

<p>hillclimb算法在搜索的每一步都会探索一个点的neibor，如果搜索空间太大，那么这需要太长时间。另一种策略是不将搜索限制在局部邻域，而是全局搜索搜索空间。也就是说，允许搜索算法在搜索空间周围进行更大的步骤。hillclimb的一个简单修改将其从局部搜索算法转换为全局搜索算法：不是查看所有近邻，而是以允许更大修改的方式对个体进行突变。</p>

<p>突变是指在搜索空间中迈出更大一步的变化。实现突变时的一个重要决定是，理论上，只需连续应用突变，就可以到达搜索空间中的任何点。然而，突变通常不应该用随机的个体完全取代个体。为了使搜索有效，重要的是突变对仍然保持其大部分特征的个体构成合理的改变。对于我们的10个字符串的搜索问题，一个可能的突变是只替换10个字符中的1个，如下所示：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">randomized_hillclimb</span><span class="p">():</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">random_unicode_string</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">fitness</span> <span class="o">=</span> <span class="n">get_fitness_cgi</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"Initial value: %s at fitness %.4f"</span> <span class="o">%</span>
          <span class="p">(</span><span class="n">terminal_repr</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">fitness</span><span class="p">))</span>

    <span class="n">iterations</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">fitness</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">mutated</span> <span class="o">=</span> <span class="n">flip_random_character</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">new_fitness</span> <span class="o">=</span> <span class="n">get_fitness_cgi</span><span class="p">(</span><span class="n">mutated</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">new_fitness</span> <span class="o">&lt;=</span> <span class="n">fitness</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">mutated</span>
            <span class="n">fitness</span> <span class="o">=</span> <span class="n">new_fitness</span>
            <span class="c1">#print("New value: %s at fitness %.4f" %(terminal_repr(x), fitness))
</span>        <span class="n">iterations</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">print</span><span class="p">(</span><span class="s">"Optimum at %s after %d iterations"</span> <span class="o">%</span>
          <span class="p">(</span><span class="n">terminal_repr</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">iterations</span><span class="p">))</span>

</code></pre></div></div>

<h3 id="genetic-algorithms">Genetic Algorithms</h3>

<p>最著名的突变算法之一是遗传算法（GA）。遗传算法基于这样一种理念，即问题解决方案可以通过基因编码：染色体由一系列基因组成，其中每个基因编码一个个体的一个特征（例如眼睛颜色、头发颜色等）。适应度函数可以获取此描述中包含的信息，即所谓的基因型，并评估由此产生的表型的特性，即这种遗传编码所代表的实际解决方案。个体的适应度值是根据表型来衡量的。</p>

<p>在搜索中使用适应度值通常用“适者生存”来解释，但达尔文对进化的一个关键见解是，选择不仅由生存来定义——个体有性繁殖，选择描述了繁殖过程中的选择压力。这种选择通常受到两种战斗的影响：与雄性竞争的雌性会赢得胜利，而更强壮（更健康）的雄性会获胜；选择也受到显示的影响。达尔文的例子是孔雀：孔雀有长而美丽的尾羽，似乎没有任何作用，似乎也不支持自然选择的概念。然而，雌孔雀在选择性伴侣时会受到其外貌的影响。令人印象深刻的装饰表明，雄性在基因上特别健康，会产生健康的后代。这反映在遗传算法中：个体的健康值越高，与另一个个体交配的可能性就越大。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">selection</span><span class="p">(</span><span class="n">evaluated_population</span><span class="p">,</span> <span class="n">tournament_size</span><span class="p">):</span>
    <span class="n">competition</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="n">sample</span><span class="p">(</span><span class="n">evaluated_population</span><span class="p">,</span> <span class="n">tournament_size</span><span class="p">)</span>
    <span class="n">winner</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">competition</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">individual</span><span class="p">:</span> <span class="n">individual</span><span class="p">[</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Return a copy of the selected individual
</span>    <span class="k">return</span> <span class="n">winner</span><span class="p">[:]</span>


</code></pre></div></div>

<p>tournament_size参数指定从人群中随机选择的个人参与比较的数量。这是一个重要的选择，因为它决定了选择压力：比较规模越大，非常优秀的个人被纳入比赛的可能性就越大。这反过来又增加了这些非常优秀的个体支配下一代的可能性，从而降低了多样性并导致过早收敛。相比之下，如果比较规模太小，那么这会抑制进化。比较规模的最佳值取决于参加人数，但通常相当小（例如5个）。</p>

<p>就像在自然进化中一样，根据健康状况选择的个体会繁殖，形成新一代。在这种繁殖过程中，就像自然繁殖一样，被选中的父母的遗传物质被结合在一起。这通常是通过一种称为交叉的过程完成的，在这种过程中，后代染色体是由其父母的基因产生的。在我们的例子中，染色体是一个字符序列，通过选择一个截止随机点，并根据截止点组合父母染色体的一半来创建后代，就可以简单地跨越两个亲本字符序列。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">def</span> <span class="nf">crossover</span><span class="p">(</span><span class="n">parent1</span><span class="p">,</span> <span class="n">parent2</span><span class="p">):</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">parent1</span><span class="p">))</span>

    <span class="n">offspring1</span> <span class="o">=</span> <span class="n">parent1</span><span class="p">[:</span><span class="n">pos</span><span class="p">]</span> <span class="o">+</span> <span class="n">parent2</span><span class="p">[</span><span class="n">pos</span><span class="p">:]</span>
    <span class="n">offspring2</span> <span class="o">=</span> <span class="n">parent2</span><span class="p">[:</span><span class="n">pos</span><span class="p">]</span> <span class="o">+</span> <span class="n">parent1</span><span class="p">[</span><span class="n">pos</span><span class="p">:]</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">offspring1</span><span class="p">,</span> <span class="n">offspring2</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">mutate</span><span class="p">(</span><span class="n">chromosome</span><span class="p">):</span>
  <span class="n">mutated</span> <span class="o">=</span> <span class="n">chromosome</span><span class="p">[:]</span>
  <span class="n">P</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">mutated</span><span class="p">)</span>

  <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mutated</span><span class="p">)):</span>
      <span class="k">if</span> <span class="n">random</span><span class="p">.</span><span class="n">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">P</span><span class="p">:</span>
          <span class="n">new_c</span> <span class="o">=</span> <span class="nb">chr</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">random</span><span class="p">.</span><span class="n">gauss</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="n">mutated</span><span class="p">[</span><span class="n">pos</span><span class="p">]),</span> <span class="mi">100</span><span class="p">)</span> <span class="o">%</span> <span class="mi">65536</span><span class="p">))</span>
          <span class="n">mutated</span> <span class="o">=</span> <span class="n">mutated</span><span class="p">[:</span><span class="n">pos</span><span class="p">]</span> <span class="o">+</span> <span class="n">new_c</span> <span class="o">+</span> <span class="n">mutated</span><span class="p">[</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span>
  <span class="k">return</span> <span class="n">mutated</span>

<span class="k">def</span> <span class="nf">genetic_algorithm</span><span class="p">():</span>
  <span class="c1"># Generate and evaluate initial population
</span>  <span class="n">generation</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="n">population</span> <span class="o">=</span> <span class="n">create_population</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
  <span class="n">fitness</span> <span class="o">=</span> <span class="n">evaluate_population</span><span class="p">(</span><span class="n">population</span><span class="p">)</span>
  <span class="n">best</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">fitness</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">item</span><span class="p">:</span> <span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
  <span class="n">best_individual</span> <span class="o">=</span> <span class="n">best</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="n">best_fitness</span> <span class="o">=</span> <span class="n">best</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
  <span class="k">print</span><span class="p">(</span><span class="s">"Best fitness of initial population: %s - %.10f"</span> <span class="o">%</span>
      <span class="p">(</span><span class="n">terminal_repr</span><span class="p">(</span><span class="n">best_individual</span><span class="p">),</span> <span class="n">best_fitness</span><span class="p">))</span>
  <span class="n">logs</span> <span class="o">=</span> <span class="mi">0</span>

  <span class="c1"># Stop when optimum found, or we run out of patience
</span>  <span class="k">while</span> <span class="n">best_fitness</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">generation</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">:</span>

      <span class="c1"># The next generation will have the same size as the current one
</span>      <span class="n">new_population</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_population</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">population</span><span class="p">):</span>
          <span class="c1"># Selection
</span>          <span class="n">offspring1</span> <span class="o">=</span> <span class="n">selection</span><span class="p">(</span><span class="n">fitness</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
          <span class="n">offspring2</span> <span class="o">=</span> <span class="n">selection</span><span class="p">(</span><span class="n">fitness</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>

          <span class="c1"># Crossover
</span>          <span class="k">if</span> <span class="n">random</span><span class="p">.</span><span class="n">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.7</span><span class="p">:</span>
              <span class="p">(</span><span class="n">offspring1</span><span class="p">,</span> <span class="n">offspring2</span><span class="p">)</span> <span class="o">=</span> <span class="n">crossover</span><span class="p">(</span><span class="n">offspring1</span><span class="p">,</span> <span class="n">offspring2</span><span class="p">)</span>

          <span class="c1"># Mutation
</span>          <span class="n">offspring1</span> <span class="o">=</span> <span class="n">mutate</span><span class="p">(</span><span class="n">offspring1</span><span class="p">)</span>
          <span class="n">offspring2</span> <span class="o">=</span> <span class="n">mutate</span><span class="p">(</span><span class="n">offspring2</span><span class="p">)</span>

          <span class="n">new_population</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">offspring1</span><span class="p">)</span>
          <span class="n">new_population</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">offspring2</span><span class="p">)</span>

      <span class="c1"># Once full, the new population replaces the old one
</span>      <span class="n">generation</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="n">population</span> <span class="o">=</span> <span class="n">new_population</span>
      <span class="n">fitness</span> <span class="o">=</span> <span class="n">evaluate_population</span><span class="p">(</span><span class="n">population</span><span class="p">)</span>

      <span class="n">best</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">fitness</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">item</span><span class="p">:</span> <span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
      <span class="n">best_individual</span> <span class="o">=</span> <span class="n">best</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
      <span class="n">best_fitness</span> <span class="o">=</span> <span class="n">best</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
      <span class="k">if</span> <span class="n">logs</span> <span class="o">&lt;</span> <span class="n">LOG_VALUES</span><span class="p">:</span>
          <span class="k">print</span><span class="p">(</span>
              <span class="s">"Best fitness at generation %d: %s - %.8f"</span> <span class="o">%</span>
              <span class="p">(</span><span class="n">generation</span><span class="p">,</span> <span class="n">terminal_repr</span><span class="p">(</span><span class="n">best_individual</span><span class="p">),</span> <span class="n">best_fitness</span><span class="p">))</span>
      <span class="k">elif</span> <span class="n">logs</span> <span class="o">==</span> <span class="n">LOG_VALUES</span><span class="p">:</span>
          <span class="k">print</span><span class="p">(</span><span class="s">"..."</span><span class="p">)</span>
      <span class="n">logs</span> <span class="o">+=</span> <span class="mi">1</span>

  <span class="k">print</span><span class="p">(</span>
      <span class="s">"Best individual: %s, fitness %.10f"</span> <span class="o">%</span>
      <span class="p">(</span><span class="n">terminal_repr</span><span class="p">(</span><span class="n">best_individual</span><span class="p">),</span> <span class="n">best_fitness</span><span class="p">))</span>



</code></pre></div></div>

<h2 id="fuzzing-with-grammars">Fuzzing with Grammars</h2>

<p>本章介绍语法作为一种简单的方法来指定输入语言，并将其用于测试具有语法有效输入的程序。语法被定义为非终结符到替代扩展列表的映射，如下例所示：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">US_PHONE_GRAMMAR</span><span class="p">:</span> <span class="n">Grammar</span> <span class="o">=</span> <span class="p">{</span>
<span class="o">&gt;&gt;&gt;</span>     <span class="s">"&lt;start&gt;"</span><span class="p">:</span> <span class="p">[</span><span class="s">"&lt;phone-number&gt;"</span><span class="p">],</span>
<span class="o">&gt;&gt;&gt;</span>     <span class="s">"&lt;phone-number&gt;"</span><span class="p">:</span> <span class="p">[</span><span class="s">"(&lt;area&gt;)&lt;exchange&gt;-&lt;line&gt;"</span><span class="p">],</span>
<span class="o">&gt;&gt;&gt;</span>     <span class="s">"&lt;area&gt;"</span><span class="p">:</span> <span class="p">[</span><span class="s">"&lt;lead-digit&gt;&lt;digit&gt;&lt;digit&gt;"</span><span class="p">],</span>
<span class="o">&gt;&gt;&gt;</span>     <span class="s">"&lt;exchange&gt;"</span><span class="p">:</span> <span class="p">[</span><span class="s">"&lt;lead-digit&gt;&lt;digit&gt;&lt;digit&gt;"</span><span class="p">],</span>
<span class="o">&gt;&gt;&gt;</span>     <span class="s">"&lt;line&gt;"</span><span class="p">:</span> <span class="p">[</span><span class="s">"&lt;digit&gt;&lt;digit&gt;&lt;digit&gt;&lt;digit&gt;"</span><span class="p">],</span>
<span class="o">&gt;&gt;&gt;</span>     <span class="s">"&lt;lead-digit&gt;"</span><span class="p">:</span> <span class="p">[</span><span class="s">"2"</span><span class="p">,</span> <span class="s">"3"</span><span class="p">,</span> <span class="s">"4"</span><span class="p">,</span> <span class="s">"5"</span><span class="p">,</span> <span class="s">"6"</span><span class="p">,</span> <span class="s">"7"</span><span class="p">,</span> <span class="s">"8"</span><span class="p">,</span> <span class="s">"9"</span><span class="p">],</span>
<span class="o">&gt;&gt;&gt;</span>     <span class="s">"&lt;digit&gt;"</span><span class="p">:</span> <span class="p">[</span><span class="s">"0"</span><span class="p">,</span> <span class="s">"1"</span><span class="p">,</span> <span class="s">"2"</span><span class="p">,</span> <span class="s">"3"</span><span class="p">,</span> <span class="s">"4"</span><span class="p">,</span> <span class="s">"5"</span><span class="p">,</span> <span class="s">"6"</span><span class="p">,</span> <span class="s">"7"</span><span class="p">,</span> <span class="s">"8"</span><span class="p">,</span> <span class="s">"9"</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">}</span>
<span class="o">&gt;&gt;&gt;</span> 
<span class="o">&gt;&gt;&gt;</span> <span class="k">assert</span> <span class="n">is_valid_grammar</span><span class="p">(</span><span class="n">US_PHONE_GRAMMAR</span><span class="p">)</span>

</code></pre></div></div>

<p>非终端符号用尖括号括起来（比如<digital>）。为了从语法生成输入字符串，生产者从开始符号（<start>）开始，并随机选择该符号的随机展开。它会继续这个过程，直到所有非终结符都展开</start></digital></p>

<p>语法作为人类语言的基础之一，自人类语言存在以来就一直存在。生成语法的第一次形式化是由Dakṣiputra Pā̇ini在公元前350年提出的。作为表达数据和程序形式语言的一般手段，它们在计算机科学中的作用怎么强调都不为过。乔姆斯基的开创性工作介绍了规则语言、上下文无关语法、上下文敏感语法和通用语法的中心模型，因为它们在计算机科学中被使用（和教授）作为指定输入和编程语言的手段。</p>

<p>使用语法生成测试输入可以追溯到Burkhardt{Burkhardt1967}，后来被Hanford{Hanford1970}和Purdom{Purdom1972}重新发现和应用。从那时起，语法测试最重要的用途就是编译器测试。实际上，基于语法的测试是编译器和Web浏览器正常工作的一个重要原因：</p>

<p><a href="https://embed.cs.utah.edu/csmith/">CSmith</a>工具{Yang2011}专门针对C程序，从C语法开始，然后应用其他步骤，例如引用之前定义的变量和函数或确保整数和类型安全。他们的作者使用它“发现并报告了400多个以前未知的编译器错误”</p>

<p><a href="http://issta2016.cispa.saarland/interview-with-christian-holler/">LangFuzz</a>的著作《Holler2012》与本书共有两位作者，该著作使用通用语法生成输出，并日夜用于生成JavaScript程序和测试其解释器；截至今天，它在Mozilla Firefox、Google Chrome和Microsoft Edge等浏览器中发现了2600多个错误。</p>

<p><a href="https://web.cs.ucdavis.edu/~su/emi-project/">EMI</a>项目{Le2014}使用语法对C编译器进行压力测试，将已知的测试转换为在所有输入上语义等效的替代程序。这再次导致C编译器中的100多个错误得到修复。</p>

<p><a href="https://github.com/renatahodovan/grammarinator">Grammarinator</a> \cite{Hodovan2018}是一个开源语法模糊器（用Python编写！），使用流行的ANTLR格式作为语法规范。与LangFuzz一样，它使用语法进行解析和生成，并在JerryScript轻量级JavaScript引擎和相关平台中发现了100多个问题。</p>

<p><a href="https://github.com/googleprojectzero/domato">Domato</a>是一个通用的语法生成引擎，专门用于模糊DOM输入。它揭示了流行网络浏览器中的许多安全问题。</p>
</section>
</article>

<div class="left-right-navigation">
	
	<a class="left" href="/2025/05/Objective-C%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/">
		<i class="fa fa-chevron-left"></i>
		<div>Objective-C底层原理</div>
	</a>
	
	
	<a class="right" href="/2025/03/afl-study/">
		<div>afl源码分析</div>
		<i class="fa fa-chevron-right"></i>
	</a>
	
</div>


		</div>
		<footer class="site-footer">
	<div>
		&copy; 2025 p1ain0
		<span>&middot;</span>
		Code licensed under <a rel="license" href="https://github.com/bazad/bazad.github.io/blob/master/LICENSE">MIT</a>
		<span>&middot;</span>
		Content licensed under <a rel="license" href="https://creativecommons.org/licenses/by/4.0/" target="_blank">CC BY 4.0</a>
		<span>&middot;</span>
		<a href="/about-this-site">About this site</a>
	</div>
</footer>

		
	</body>
</html>
