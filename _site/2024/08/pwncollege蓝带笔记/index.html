<!DOCTYPE html>
<html class="no-js">
	<head>
	<meta charset="utf-8">

	

	<title>pwncollege蓝带笔记 | kaka</title>
	
	<meta name="description" content="最近刚刚在pwn.college上已经获得了蓝带，现在总结下：">
	

	<meta name="viewport" content="width=device-width, initial-scale=1">

	<!-- CSS -->
	<link rel="stylesheet" href="/css/main.css">

	<!--Favicon-->
	<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

	<!-- Canonical -->
	<link rel="canonical" href="http://localhost:4000/2024/08/pwncollege%E8%93%9D%E5%B8%A6%E7%AC%94%E8%AE%B0/">

	<!-- RSS -->
	<link rel="alternate" type="application/atom+xml" title="kaka" href="http://localhost:4000/feed.xml">

	<!-- Font Awesome -->
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

	

	
</head>

	<body>
		<header class="site-header">
	
	<h1 class="site-title">
		<a href="/">kaka</a>
	</h1>
	<div class="space padding"></div>
	<nav class="site-navigation">
		<ul>
			
			
			
			
			
			
			<li>
				<a class="page-link" href="/about/">
					About
				</a>
			</li>
			
			
			
			
			
			
			
			
			
			
			

<li>
	<a href="/feed.xml" title="RSS feed">
			<i class="fa fa-fw fa-rss"></i>
	</a>
</li>



<li>
	<a href="https://github.com/seacho" title="Github">
			<i class="fa fa-fw fa-github"></i>
	</a>
</li>



<li>
	<a href="mailto:assdfgzxcv4@gmail.com" title="Email">
			<i class="fa fa-fw fa-envelope"></i>
	</a>
</li>



		</ul>
	</nav>
</header>

		<div class="content">
			<article class="post">
	<header>
		<h1 class="title">pwncollege蓝带笔记</h1>
		<p class="byline-dateline">
	
	<span class="dateline">August 17, 2024</span>
</p>


	</header>
	<section class="post-content"><p>最近刚刚在pwn.college上已经获得了蓝带，现在总结下：</p>

<!--more-->

<h2 id="x86基础">x86基础</h2>

<p>x86体系架构以及汇编：网上一堆教程自己找着看吧。</p>

<p>linux上的函数调用约定；然后就自己手写汇编反弹shell会各种的syscall传参。如何压缩shellcode，如何绕过一些特殊字符的限制</p>

<h3 id="汇编示例">汇编示例</h3>

<p>execve(“/bin/sh”, NULL, NULL)</p>

<pre><code class="language-assembly">.global _start
_start:
.intel_syntax noprefix
mov rax, 59
lea rdi, [rip+binsh]
mov rsi, 0
mov rdx,0
syscall
binsh:
.string "/bin/sh"

</code></pre>

<p>提取shellcode</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#assmbly it!</span>
gcc <span class="nt">-nostdlib</span> <span class="nt">-static</span> shellcode.s <span class="nt">-o</span> shellcode-elf

objcopy <span class="nt">--dump-section</span> .text<span class="o">=</span>shellcode-raw shellcode-elf

Assemble Code
as <span class="nt">-o</span> shellcode.o shellcode.s

Link Object File
ld <span class="nt">-o</span> shellcode shellcode.o

Link Object File
objcopy -–dump-section .text<span class="o">=</span>shellcode-raw shellcode-elf

</code></pre></div></div>

<p>再比如<code class="language-plaintext highlighter-rouge">sendfile(1, open("flag", NULL), 0, 1000); exit()</code></p>

<pre><code class="language-assembly">mov rbx, 0x00000067616c662f
push rbx
mov rax, 2
mov rdi, rsp
mov rsi, 0
syscall

mov rdi, 1
mov rsi, rax
mov rdx, 0
mov r10, 1000
mov rax, 40
syscall

mov rax, 60
syscall
</code></pre>

<p>也可以使用python的pwntools生成</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>
<span class="n">context</span><span class="p">.</span><span class="n">arch</span> <span class="o">=</span> <span class="s">"amd64"</span>
<span class="n">my_sc_bytes</span> <span class="o">=</span> <span class="n">asm</span><span class="p">(</span><span class="s">'''mov rax, 0x1337'''</span><span class="p">)</span>
<span class="c1"># display the bytes
</span><span class="k">print</span><span class="p">(</span><span class="n">disasm</span><span class="p">(</span><span class="n">my_sc_bytes</span><span class="p">))</span>


<span class="c1">#shellcraft 自动化生成
</span><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>
<span class="n">context</span><span class="p">.</span><span class="n">arch</span> <span class="o">=</span> <span class="s">"amd64"</span>
<span class="n">my_sc</span> <span class="o">=</span> <span class="n">asm</span><span class="p">(</span><span class="n">shellcraft</span><span class="p">.</span><span class="n">cat</span><span class="p">(</span><span class="s">"/flag"</span><span class="p">)</span>
<span class="c1"># display the bytes
</span><span class="k">print</span><span class="p">(</span><span class="n">disasm</span><span class="p">(</span><span class="n">my_sc_bytes</span><span class="p">))</span>
</code></pre></div></div>

<h3 id="调试shellcode的方法">调试shellcode的方法</h3>

<h4 id="debug-shellcode-with-strace">Debug shellcode with strace</h4>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$cat</span> my_shellcode | strace ./target_binary 
</code></pre></div></div>

<h4 id="debug-shellcode-with-pwntools">Debug shellcode with pwntools</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#Debug shellcode with pwntools
</span><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>
<span class="n">Context</span><span class="p">.</span><span class="n">arch</span> <span class="o">=</span> <span class="err">“</span><span class="n">amd64</span><span class="err">”</span>
<span class="n">sc_bytes</span> <span class="o">=</span> <span class="n">asm</span><span class="p">(</span><span class="err">‘’’</span>
  <span class="n">int3</span>
  <span class="n">mov</span> <span class="n">rax</span><span class="p">,</span> <span class="mh">0x1337</span>
  <span class="err">‘’’</span><span class="p">)</span>
<span class="c1">#p = process(“challenge/whatever”)
</span><span class="n">p</span> <span class="o">=</span> <span class="n">gdb</span><span class="p">.</span><span class="n">debug</span><span class="p">(</span><span class="err">“</span><span class="o">/</span><span class="n">challenge</span><span class="o">/</span><span class="n">whatever</span><span class="err">”</span><span class="p">)</span>
<span class="n">p</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">sc_bytes</span><span class="p">)</span>
<span class="n">p</span><span class="p">.</span><span class="n">interactive</span><span class="p">()</span>


<span class="c1">#Debug shellcode inside the challenge itself
</span><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>
<span class="n">context</span><span class="p">.</span><span class="n">arch</span> <span class="o">=</span> <span class="err">“</span><span class="n">amd64</span><span class="err">”</span>
<span class="n">sc_bytes</span> <span class="o">=</span> <span class="n">asm</span><span class="p">(</span><span class="s">'''
  int3
  mov rax, 0x1337
  '''</span><span class="p">)</span>
<span class="c1">#p = process(“challenge/whatever”)
</span><span class="n">p</span> <span class="o">=</span> <span class="n">gdb</span><span class="p">.</span><span class="n">debug</span><span class="p">(</span><span class="err">“</span><span class="o">/</span><span class="n">challenge</span><span class="o">/</span><span class="n">whatever</span><span class="err">”</span><span class="p">)</span>
<span class="n">p</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">sc_bytes</span><span class="p">)</span>
<span class="n">p</span><span class="p">.</span><span class="n">interactive</span><span class="p">()</span>


<span class="c1">#Testing your shellcode for “bad bytes”
</span><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>
<span class="n">Context</span><span class="p">.</span><span class="n">arch</span> <span class="o">=</span> <span class="err">“</span><span class="n">amd64</span><span class="err">”</span>
<span class="n">sc_bytes</span> <span class="o">=</span> <span class="n">asm</span><span class="p">(</span><span class="s">'''mov rax, 0x1337'''</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">disasm</span><span class="p">(</span><span class="n">sc_bytes</span><span class="p">))</span>
<span class="k">if</span> <span class="n">b</span><span class="err">’</span><span class="n">X</span><span class="err">’</span> <span class="ow">in</span> <span class="n">sc_bytes</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="err">“</span><span class="n">X</span> <span class="n">was</span> <span class="n">found</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">shellcode</span><span class="err">!”</span>

</code></pre></div></div>

<h3 id="跨平台的shellcode">跨平台的shellcode</h3>

<h4 id="shellcode-for-otherarchitectures">shellcode for otherarchitectures</h4>

<p>Our way of building shellcode translates well to other architectures:</p>

<ul>
  <li>
    <p>amd64: gcc -nostdlib -static shellcode.s -o shellcode-elf</p>
  </li>
  <li>
    <p>mips: <strong>mips-linux-gnu-</strong>gcc -nostdlib shellcode-mips.s -o shellcode-mips-elf</p>
  </li>
</ul>

<p>Similarly, we can run cross-architecture shellcode with an emulator:</p>

<ul>
  <li>
    <p>amd64: ./shellcode</p>
  </li>
  <li>
    <p>mips: <strong>qemu-mips-static</strong> ./shellcode-mips</p>
  </li>
</ul>

<p>Useful qemu options:</p>

<ul>
  <li>
    <p>-strace		print out a log of the system calls (like strace)</p>
  </li>
  <li>
    <p>-g 1234		wait for a gdb connection on port 1234. Connect with
	target remote localhost:1234 in gdb-multiarch</p>
  </li>
</ul>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mips: mips-linux-gun-gcc <span class="nt">-nostdlib</span> xxx.s <span class="nt">-o</span> xxx
qemu-mips-static ./xxx
qemu useful option:
<span class="nt">-strace</span>
<span class="nt">-g</span> 1234
</code></pre></div></div>

<h4 id="跨架构的shellcode制作方法">跨架构的shellcode制作方法：</h4>

<p>以x86的32 位和 64 位为例，制作跨平台运行的shellcode：典型策略：以“多语言”方式启动，对实际架构进行指纹识别，然后跳转到特定于架构的shellcode。</p>

<ol>
  <li>将 eax 推送到堆栈（x86 和 amd64 上的操作码相同）</li>
  <li>检查 esp 是否移位 32 位或 64 位（x86 和 amd64 上的操作码相同）</li>
  <li>如果是 32 位，则跳转到 32 位 shellcode，如果是 64 位，则跳转到 64 位</li>
</ol>

<h3 id="汇编的操作数的宽度">汇编的操作数的宽度：</h3>

<pre><code class="language-assembly">1-byte : mov [rax], bl
2-byte : mov [rax], bx
4-byte : mov [rax], ebx
8-byte : mov [rax], rbx

1-byte : mov BYTE PTR[rax], 5
2-byte : mov WORD PTR [rax], 5
4-byte : mov DWORD PTR [rax], 5
8-byte : mov QWORD PTR [rax], 5
</code></pre>

<h3 id="输入的一些限制">输入的一些限制</h3>

<p>我们在制作shellcode的时候要考虑输入的函数在遇到特殊的字符的时候会自动截断等问题。</p>

<table>
  <thead>
    <tr>
      <th>Byte(hex value)</th>
      <th>Problematic Methods</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Null byte \0 (0x00)</td>
      <td>strcpy</td>
    </tr>
    <tr>
      <td>Newline \n (0x0a)</td>
      <td>scanf gets getline fgets</td>
    </tr>
    <tr>
      <td>Carriage return \r (0x0d)Space (0x20) Tab \t (0x09)</td>
      <td>scanf</td>
    </tr>
    <tr>
      <td>DEL (0x7f)</td>
      <td>protocol-specific(telnet VT100, etc)</td>
    </tr>
  </tbody>
</table>

<p>当然实际情况更复杂，比如input format只允许可打印的字符…</p>

<p>shellcode变形demo：</p>

<table>
  <thead>
    <tr>
      <th>Filter</th>
      <th>Bad</th>
      <th>Good</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>no NULLs</td>
      <td>mov rax, 0 (48c7c0<strong>00000000</strong>)</td>
      <td>xor rax, rax (4831C0)</td>
    </tr>
    <tr>
      <td>no NULLs</td>
      <td>mov rax, 5 (48c7c005<strong>000000)</strong></td>
      <td>xor rax, rax; mov al, 5 (4831C0B005)</td>
    </tr>
    <tr>
      <td>no newlines</td>
      <td>mov rax, 10 (48c7c0<strong>0a</strong>000000<strong>)</strong></td>
      <td>mov rax, 9; inc rax (48C7C00900000048FFC0)</td>
    </tr>
    <tr>
      <td>no NULLs</td>
      <td>mov rbx, 0x67616c662f “/flag” (48BB2F666C6167<strong>000000</strong>)</td>
      <td>mov ebx, 0x67616c66; shl rbx, 8; mov bl, 0x2f (BB666C616748C1E308B32F)</td>
    </tr>
    <tr>
      <td>printables</td>
      <td>mov rax, rbx (48<strong>89d8</strong>)</td>
      <td>push rbx; pop rax (5358, “SX”)</td>
    </tr>
  </tbody>
</table>

<p>如果shellcode的约束太难用巧妙的变形来解决，但是你的 shellcode 所映射的页面是可写的……</p>

<p>记住：code == data</p>

<p>Bypassing a restriction on <code class="language-plaintext highlighter-rouge">int 3</code>:</p>

<pre><code class="language-assembly">inc BYTE PTR [rip]
.byte 0xcb
</code></pre>

<p>When testing this, you’ll need to make sure .text is writable:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gcc <span class="nt">-Wl</span> <span class="nt">-N</span> <span class="nt">--static</span> <span class="nt">-nostdlib</span> <span class="nt">-o</span> <span class="nb">test </span>test.s
</code></pre></div></div>

<h3 id="x86和amd64的一些不一样的地方">x86和amd64的一些不一样的地方</h3>

<h4 id="特殊情况字符h">特殊情况：字符”H”</h4>

<p>在 amd64 shellcode 中，有一个字符比其他任何字符都更突出：“H”。</p>

<ul>
  <li>AMD 将 amd64 设计为与 x86 <em>向后兼容</em>，以便实际采用。在 amd64 处理器上执行的 x86 代码将完全按照 x86 代码运行。大多数情况下，amd64 是一个纯扩展，由16进制的0x48(字符”H”)的指令前缀控制。
例外情况：在 amd64 上，push 和 pop 适用于 64 位值（rax 等），无需前缀。</li>
</ul>

<table>
  <thead>
    <tr>
      <th>x86</th>
      <th>amd64</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>mov eax, ebx (89 d8)</td>
      <td>mov rax, rbx (<strong>48</strong> 89 d8)</td>
    </tr>
    <tr>
      <td>inc eax (ff c0)</td>
      <td>inc rax (<strong>48</strong> ff c0)</td>
    </tr>
  </tbody>
</table>

<h4 id="system-calls">system calls</h4>

<p><strong>amd64</strong> uses the <code class="language-plaintext highlighter-rouge">syscall</code> instruction to dispatch a system call to the OS kernel.</p>

<p><strong>x86</strong> used the <code class="language-plaintext highlighter-rouge">int 0x80</code> instruction to trigger an interrupt that would be interpreted by the OS kernel as a system call.</p>

<p>这是两个不同的指令，具有不同的系统调用映射！当然在 amd64 中也能使用 <code class="language-plaintext highlighter-rouge">int 0x80</code>。</p>

<p>有用的资源:</p>

<ul>
  <li><a href="https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md">chromium项目Syscalls</a> <a href="https://www.chromium.org/chromium-os/developer-library/reference/linux-constants/syscalls/">新地址</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Shellcode">Wikipedia</a></li>
  <li><a href="http://ref.x86asm.net/coder64.html">x86_64 assembly listing</a></li>
  <li><a href="https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/">Syscall Table</a></li>
  <li><a href="https://syscall.sh/">Another syscall table, with multiple architectures!</a></li>
</ul>

<h2 id="越过防护">越过防护</h2>

<h3 id="stack-canary">Stack Canary</h3>

<p>与canary相关的编译器选项</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-fstack-protector 只为局部变量中含有数组的函数开启保护
-fstack-protector-all 为所有函数开启保护
-fstack-protector-strong 为局部变量地址作为赋值语句的右值及函数参数、含有数组类型的局部变量、`register`声明的局部变量开启保护
 
-fstack-protector-explicit 对含义stack_protect attribute的函数开启保护
 
-fno-stack-protector 禁用保护
</code></pre></div></div>

<p>Canary的值是与线程相关的，不同的线程值不一样。从<code class="language-plaintext highlighter-rouge">fx+0x28</code>的位置取出</p>

<p>LibC使用fs寄存器存放线程局部存储TLS (Thread Local Stroage)，TLS可用于支持多线程同时访问同1个全局变量或静态变量。TLS的存在使得每个线程都独占1份全局变量及静态变量，不同线程间对同1个全局变量或静态变量的修改并不会产生冲突。这种特殊的变量需要<code class="language-plaintext highlighter-rouge">__thread</code>关键字修饰，编译器看到<code class="language-plaintext highlighter-rouge">__thread</code>修饰的变量后，二进制文件内会将这些变量放入<code class="language-plaintext highlighter-rouge">.tdata </code>节和<code class="language-plaintext highlighter-rouge">.tbss</code>节内。</p>

<p>(ps:在GDB中观察<code class="language-plaintext highlighter-rouge">fs</code>寄存器时，会发现<code class="language-plaintext highlighter-rouge">fs</code>寄存器的值永远是0，这是因为软件调试器GDB对系统寄存器没有访问权限导致的。但是内核提供了<code class="language-plaintext highlighter-rouge">arch_prctl</code>接口，用于修改或获取特定于体系结构的进程或线程状态。)</p>

<p>_start -&gt;init_tls初始化tls信息 -&gt; security_init产生随机值。但是随机值<code class="language-plaintext highlighter-rouge">stack_chk_guard</code>与<code class="language-plaintext highlighter-rouge">_dl_random</code>的值相关。这个值咋来的呢？可以使用gdb的内存监视断点观察。中断在<code class="language-plaintext highlighter-rouge">_dl_sysdep_parse_arguments</code>函数中</p>

<ol>
  <li>
    <p>泄漏Canary，</p>
  </li>
  <li>
    <p>对于fork的程序，可以使用brute-force的方法</p>

    <p>例如这种情况：</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">fork</span><span class="p">())</span> <span class="p">{</span> <span class="n">wait</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span> <span class="n">read</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">128</span><span class="p">);</span> <span class="k">return</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>写的时候跳过去</p>

    <p>例如这种情况可以通过控制i的值跳过canary：</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">128</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">read</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">buf</span><span class="o">+</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>在程序返回之前劫持程序</p>
  </li>
  <li>
    <p>覆盖.got.plt中的__stack_chk_fail函数地址</p>
  </li>
</ol>

<h3 id="aslr-address-space-layout-randomization">ASLR (Address Space Layout Randomization)</h3>

<p>History:First appeared in 2001 as part of a Linux kernel patch set called <strong>PaX</strong>. Written by a team led by an anonymous coder…(<strong>PaX</strong> also brought DEP to Linux)</p>

<ol>
  <li>
    <p>leak</p>
  </li>
  <li>
    <p>YOLO</p>

    <p>程序都是页对齐的，所以低12位是固定的。我们可以只overwrite两个字节（当然也得需要部分brute-force）</p>
  </li>
  <li>
    <p>brute-force（跟canary相似的情况，fork）</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">fork</span><span class="p">())</span> <span class="p">{</span> <span class="n">wait</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span> <span class="n">read</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">128</span><span class="p">);</span> <span class="k">return</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ol>

<h4 id="disabling-aslr-for-local-testing">Disabling ASLR for local testing</h4>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pwn.process<span class="o">(</span><span class="s2">"./vulnerable_proram"</span>, <span class="nv">aslr</span><span class="o">=</span>False<span class="o">)</span>
</code></pre></div></div>

<p>gdb will disable ASLR by default if has permissions to do so.</p>

<p>NOTE: for SUID binaries, remove the SUID bit before using gdb (chmod or cp).</p>

<p>可以启动一个 shell，其 (非 setuid) 子进程都将禁用 ASLR：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>setarch x86_64 <span class="nt">-R</span> /bin/bash
</code></pre></div></div>

<h3 id="dep">DEP:</h3>

<h4 id="rop">ROP</h4>

<p>从内存中已有的一组奇怪的指令中进行选择。使用 ret和堆栈上的地址链接指令（ropchains）。达到和连续的shellcode的一样的效果。</p>

<p>Return to libc :Discovered in 1997 by Solar Designer.</p>

<p>Code reuse in AMD64</p>

<p>The generalization of Return-to-libc is Return Oriented Programming.</p>

<h5 id="注意点">注意点：</h5>

<ol>
  <li>
    <p>syscalls are rare.</p>

    <ul>
      <li>In shellcode, you use syscall to invoke system calls. This instruction is quite rare in normal programs (even as a part of other instructions).You might have to call library functions, instead!</li>
      <li>Advice: Keep it Simple.</li>
    </ul>
  </li>
  <li>
    <p>know your environment. ex:heap address and stack address in register and stacks…</p>
  </li>
  <li>
    <p>finding the rop gadgets</p>

    <ul>
      <li>Many tools available <a href="https://github.com/zardus/ctf-tools">ctftools</a> has installers for 3!.</li>
      <li>For example, rp++:</li>
    </ul>

    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rp++ <span class="nt">--unique</span> <span class="nt">-r2</span> <span class="nt">-f</span> /bin/bash
   
<span class="c"># Can also try greater values than 2, but long gadgets become increasingly unstable (side-effects!).</span>
<span class="c"># From here, regular expressions are your friends.</span>
   
rp++ <span class="nt">--unique</span> <span class="nt">-r2</span> <span class="nt">-f</span> /bin/bash | <span class="nb">grep</span> <span class="nt">-P</span> <span class="s2">"(add|sub|mov) rax, r.."</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>Sometimes, your control of the stack is limited.  ex: Limited overflow size.  Inability to input NULL bytes. Often, we can still trigger one gadget!</p>

    <p>Consider system()…</p>

    <ul>
      <li>it has to set up a call to execve(“/bin/sh”, {“/bin/sh”, “-c”, command}, env);</li>
      <li>what if we jump partway through?</li>
    </ul>

    <p>This actually works! If you get lucky with register values and stack setup, you can often trigger /bin/sh by jumping partway into system(). This location is called the <strong>magic gadget</strong>.</p>

    <p>More useful for you: trigger execve(some_garbage); and create a some_garbage file that reads the flag.</p>
  </li>
  <li>
    <p>ASLR （跟之前讨论过的ASLR的方法类似，通过部分overwrite）</p>
  </li>
  <li>
    <p>Stack Canary</p>

    <p>泄漏或者绕过</p>
  </li>
  <li>
    <p>一些缓解rop的措施</p>

    <p>Anti-ROP approaches:</p>

    <p>删除 ROP gadgets（太繁重）：
G-Free：通过无小工具的二进制文件击败面向返回的编程
检测正在进行的 ROP（已部署，但可绕过）：
kBouncer：高效且透明的 ROP 缓解
ROPecker：一种通用且实用的防御 ROP 攻击的方法</p>
  </li>
  <li>
    <p>控制流完整性 Control Flow Integrity</p>

    <p>2009 年，Martin Abadi、Mihai Budiu、Ulfar Erlingsson 和 Jay Ligatti 在Control-Flow Integrity: Principles, Implementations, and Applications中提出了这一建议。
核心思想：每当发生可劫持的控制流传输时，确保其目标是它应该能够返回的东西！
这引发了一场军备竞赛。
反 CFI 技术：</p>

    <p><strong>B(lock)OP:</strong> ROP on a block (or multi-block) level by carefully compensating for side-effects.</p>

    <p><strong>J(ump)OP:</strong> instead of returns, use indirect jumps to control execution flow</p>

    <p><strong>C(all)OP:</strong> instead of returns, use indirect calls to control execution flow</p>

    <p><strong>S(ignreturn)ROP:</strong> instead of returns, use the sigreturn system call</p>

    <p><strong>D(ata)OP:</strong> instead of hijacking control flow, carefully overwrite the program’s data to puppet it</p>

    <p><strong>ex：Control Flow Integrity: Intel Edition!</strong></p>

    <ul>
      <li>英特尔（2020 年 9 月）发布了具有控制流执行技术 (CET) (Control-flow Enforcement Technology)的处理器。CET添加了endbr64 指令。在启用 CET 的 CPU 上，间接跳转（包括 ret、jmp rax、call rdx 等）必须以 endbr64 指令结束，否则程序将终止。这仍然可以通过一些高级 ROP 技术（面向块编程、SROP 等）绕过，但它将大大增加利用的复杂性。</li>
    </ul>
  </li>
  <li>
    <p>Hacking Blind</p>

    <p>Proposed by Andrea Bittau at the 2014 IEEE Symposium on Security &amp; Privacy.</p>

    <p>http://www.scs.stanford.edu/brop/bittau-brop.pdf</p>

    <p>逐字节破坏 ASLR 和金丝雀，我们可以半控制地重定向内存。重定向内存，直到我们有一个生存信号（即不会崩溃的地址）。使用生存信号查找非崩溃的 ROP 小工具。查找产生输出的功能。泄漏程序。破解它。</p>
  </li>
</ol>

<h4 id="存在jit的系统">存在JIT的系统</h4>

<p>在现代系统中，默认情况下，stack和heap是不可执行的。但是现代高级语言（JavaScript、Java、Lua、Python 等）都使用即时编译。代码是用 JavaScript 编写的。在运行时，必要的代码被编译为二进制代码，因为二进制代码执行速度非常快。当然，这意味着能够注入高级代码的攻击者可以影响生成的本机代码……</p>

<h5 id="jit编译">JIT编译：</h5>

<ul>
  <li>Just in Time compilers need to generate (and frequently re-generate) code that is executed.</li>
  <li>Pages must be writable for code generation.</li>
  <li>Pages must be executable for execution.</li>
  <li>Pages must be writable for code <em>re-generation</em>.</li>
</ul>

<p>The safe thing to do would be to:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">mmap(PROT_READ|PROT_WRITE)</code></li>
  <li><code class="language-plaintext highlighter-rouge">write the code</code></li>
  <li><code class="language-plaintext highlighter-rouge">mprotect(PROT_READ|PROT_EXEC)</code></li>
  <li><code class="language-plaintext highlighter-rouge">execute</code></li>
  <li><code class="language-plaintext highlighter-rouge">mprotect(PROT_READ|PROT_WRITE)</code></li>
  <li>update code</li>
  <li>etc…</li>
</ol>

<table>
  <tbody>
    <tr>
      <td>但是这种方式太慢了，所以PROT_WRITE</td>
      <td>PROT_EXEC的页面太常见了。</td>
    </tr>
  </tbody>
</table>

<p>If your binary uses a library that has a writable+executable page, that page lives in your memory space!</p>

<p>Consider the following JavaScript:
<code class="language-plaintext highlighter-rouge">var asdf = 0x050f3cb0c031;</code>
This might JIT to:
<code class="language-plaintext highlighter-rouge">mov rdx, 0x050f3cb0c031</code>
Which assembles to:
<code class="language-plaintext highlighter-rouge">48 ba 31 c0 be 3c 0f 05 00 00</code>
What if we jump to the 0x31 via another vulnerability?
<code class="language-plaintext highlighter-rouge">31 c0: xor eax, eax </code>
<code class="language-plaintext highlighter-rouge">be 3c: mov al, 0x3c</code> 
<code class="language-plaintext highlighter-rouge">0f 05: syscall</code></p>

<p>Shellcode execution (in this case, exit())!</p>

<p>JIT is used <em>everywhere</em>: browsers, Java, and most interpreted language runtimes (luajit, pypy, etc), so this vector is very relevant.</p>

<h5 id="jit-spraying">JIT spraying</h5>

<p>Shellcode injection technique: JIT spraying.</p>

<ul>
  <li>Make constants in the code that will be JITed:
	<code class="language-plaintext highlighter-rouge">var evil = "%90%90%90%90%90";</code></li>
  <li>The JIT engine will mprotect(PROT_WRITE), compile the code into memory, then mprotect(PROT_EXEC). Your constant is now present in executable memory.</li>
  <li>Use a vulnerability to redirect execution into the constant.</li>
</ul>

<h2 id="format-string-exploits">Format String Exploits</h2>

<h3 id="printf---turing-complete-mastery">printf - (turing) complete mastery</h3>

<p>When run in a loop, printf is <em>turing complete</em>!</p>

<p>https://github.com/HexHive/printbf</p>

<h3 id="printf---leaking-memory">printf - leaking memory</h3>

<p>Memory can be leaked by using:</p>

<p>%c: read a char off the stack</p>

<p>%d, %i, %x: read an int (4 bytes) off the stack</p>

<p>%x: read an int (4 bytes) in hex</p>

<p>%s: dereference a pointer and read out bytes until a null byte</p>

<h3 id="printf---controlling-how-much-you-leak">printf - controlling how much you leak</h3>

<p>Size parameters:</p>

<p>%x leaks 4 bytes</p>

<p>%hx leaks 2 bytes</p>

<p>%hhx leaks 1 byte</p>

<p>%lx leaks 8 bytes</p>

<h3 id="printf---controlling-what-you-leak">printf - controlling what you leak</h3>

<p>In their infinite wisdom, the glibc developers have given us $.</p>

<p>%7$x - print the <em>7th</em> parameter (on the stack)</p>

<h3 id="other-functions">other functions</h3>

<p>Format strings are sometimes:</p>

<ul>
  <li>dynamically generated</li>
  <li>used for internal logic, as opposed to i/o (i.e., sprintf, snprintf, sscanf)</li>
  <li>used for logging (fprintf)</li>
  <li>used for input (scanf)</li>
</ul>

<p>All of these are exploitable.</p>

<h3 id="printf---writing-memory">printf - writing memory</h3>

<p>%n requires a pointer to where we want to write. But:</p>

<ol>
  <li><strong>if our buffer is on the stack (and we can put a valid pointer into it), we can use that!</strong></li>
  <li>%7$n (and other offsets) let us use different pointers on the stack</li>
  <li>frame pointers point to each other!</li>
  <li>we can target ebp1 for %n, and modify ebp2, then target ebp2</li>
</ol>

<h3 id="problem-n-writes-4-bytes">Problem: %n writes 4 bytes.</h3>

<p>Solution:</p>

<ul>
  <li>%ln</li>
  <li>%hn</li>
  <li>%hhn</li>
</ul>

<h3 id="problem-how-do-we-control-what-to-write">Problem: how do we control <em>what</em> to write?</h3>

<p>Solution:</p>

<p>char buf[4];</p>

<p>printf(“%1145258561x%1$n”, buf);</p>

<h3 id="problem-limiting-output-amount">Problem: limiting output amount?</h3>

<p>Solution:</p>

<p>char buf[4];</p>

<p>printf(“%65x%1$hhn%c%2$hhn%c%3$hhn%c%4$hhn”, buf, buf+1, buf+2, buf+3);</p>

<h3 id="one-more-thing-10c11n">One more thing: <code class="language-plaintext highlighter-rouge">%*10$c%11$n</code></h3>

<p>specifies a <em>dynamic padding size</em>. This will:</p>

<ol>
  <li>get the 10th parameter</li>
  <li><em>use it as the padding size</em> of a single character</li>
  <li>print that many bytes</li>
  <li>write the number of bytes printed to the memory pointed to by the 11th parameter.</li>
</ol>

<p>This results in a copy.</p>

<h3 id="使用pwntools生成基于printf的exp">使用pwntools生成基于printf的exp</h3>

<p>fmtstr_payload() 和 leak_stack()</p>

<p>详细用法示例可以参考当时的writeup</p>

<h2 id="file-struct-exploits">File Struct Exploits</h2>

<p>攻击面总结：</p>

<ol>
  <li>修改结构体中的缓冲区指针，实现任意地址读写</li>
  <li>覆盖vtable达到控制执行流的目的</li>
</ol>

<p><a href="https://elixir.bootlin.com/linux/latest/source/include/linux/fs.h#L940">fs.h</a></p>

<p><a href="https://elixir.bootlin.com/glibc/glibc-2.31/source/libio/bits/types/struct_FILE.h#L49">FILE</a></p>

<h2 id="堆问题">堆问题</h2>

<p>堆结构比较复杂，分配器多种多样，这里只写了ptmalloc的机制，对堆进行攻击需要对堆的排布比较熟悉（难怪都叫“堆风水”）</p>

<h3 id="ptmalloc设计的cache种类">ptmalloc设计的cache种类:</h3>

<ol>
  <li>
    <p>64 singly-linked tcache bins for allocations of size 16 to 1032 (functionally “covers” fastbins and smallbins)</p>
  </li>
  <li>
    <p>10 singly-linked “fast” bins for allocations of size up to 160 bytes</p>
  </li>
  <li>
    <p>1 doubly-linked “unsorted” bin to quickly stash free()d chunks that don’t fit into tcache or</p>

    <p>fastbins</p>
  </li>
  <li>
    <p>64 doubly-linked “small” bins for allocations up to 512 bytes</p>
  </li>
  <li>
    <p>doubly-linked “large” bins (anything over 512 bytes) that contain different-sized chunks</p>
  </li>
</ol>

<p>双向链表的设计是为了方便合并：合并两个相邻的chunk，合并发生在free和malloc的时候</p>

<h3 id="malloc的简化过程">malloc的简化过程：</h3>

<ol>
  <li>检查tcache，</li>
  <li>fastbin</li>
  <li>检查请求大小，小内存直接通过small bin，</li>
  <li>清理 Fastbin</li>
  <li>检查/sort unsortedbins(chunk如果太小，会被移动到small bins或者large bins中，如果大于请求的大小则会分割一块出来，剩下的放回unsortbins中，然后返回，不会继续遍历chunks)</li>
  <li>large bin</li>
  <li>mmap或者从heap剩下的空间里分配</li>
</ol>

<p>free由于cache有很多种，所以比较复杂。</p>

<p>几种bin的放置顺序：</p>

<ol>
  <li>先检查M标志是否被设置，如果是的话，直接munmap掉</li>
  <li>检查是否可以放入tcache</li>
  <li>不能再检查fastbin是否满足</li>
  <li>不能放入fastbin，检查M标志是否被设置，如果是的话，直接munmap掉（不知道为啥检查两次）</li>
  <li>清理合并fastbins</li>
  <li>放到unsorted bin中，并后向合并</li>
</ol>

<h3 id="tcacheglibc-226引入">tcache(glibc-2.26引入)</h3>

<p>tcache:a <strong>caching</strong> layer for “small” allocations (&lt;1032 bytes on amd64)</p>

<p>有关结构题的定义：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* There is one of these for each thread, which contains the
   per-thread cache (hence "tcache_perthread_struct").  Keeping
   overall size low is mildly important.  Note that COUNTS and ENTRIES
   are redundant (we could have just counted the linked list each
   time), this is for performance reasons.  */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">tcache_perthread_struct</span>
<span class="p">{</span>
  <span class="kt">uint16_t</span> <span class="n">counts</span><span class="p">[</span><span class="n">TCACHE_MAX_BINS</span><span class="p">];</span>
  <span class="n">tcache_entry</span> <span class="o">*</span><span class="n">entries</span><span class="p">[</span><span class="n">TCACHE_MAX_BINS</span><span class="p">];</span>
<span class="p">}</span> <span class="n">tcache_perthread_struct</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">tcache_entry</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">tcache_entry</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
  <span class="cm">/* This field exists to detect double frees.  */</span>
  <span class="k">struct</span> <span class="n">tcache_perthread_struct</span> <span class="o">*</span><span class="n">key</span><span class="p">;</span>
<span class="p">}</span> <span class="n">tcache_entry</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">malloc_chunk</span> <span class="p">{</span>

  <span class="n">INTERNAL_SIZE_T</span>      <span class="n">mchunk_prev_size</span><span class="p">;</span>  <span class="cm">/* Size of previous chunk (if free).  */</span>
  <span class="n">INTERNAL_SIZE_T</span>      <span class="n">mchunk_size</span><span class="p">;</span>       <span class="cm">/* Size in bytes, including overhead. */</span>

  <span class="k">struct</span> <span class="n">malloc_chunk</span><span class="o">*</span> <span class="n">fd</span><span class="p">;</span>         <span class="cm">/* double links -- used only if free. */</span>
  <span class="k">struct</span> <span class="n">malloc_chunk</span><span class="o">*</span> <span class="n">bk</span><span class="p">;</span>

  <span class="cm">/* Only used for large blocks: pointer to next larger size.  */</span>
  <span class="k">struct</span> <span class="n">malloc_chunk</span><span class="o">*</span> <span class="n">fd_nextsize</span><span class="p">;</span> <span class="cm">/* double links -- used only if free. */</span>
  <span class="k">struct</span> <span class="n">malloc_chunk</span><span class="o">*</span> <span class="n">bk_nextsize</span><span class="p">;</span>
<span class="p">};</span>
<span class="cm">/* size field is or'ed with PREV_INUSE when previous adjacent chunk in use */</span>
<span class="cp">#define PREV_INUSE 0x1
</span>
<span class="cm">/* extract inuse bit of previous chunk */</span>
<span class="cp">#define prev_inuse(p)       ((p)-&gt;mchunk_size &amp; PREV_INUSE)
</span>

<span class="cm">/* size field is or'ed with IS_MMAPPED if the chunk was obtained with mmap() */</span>
<span class="cp">#define IS_MMAPPED 0x2
</span>
<span class="cm">/* check for mmap()'ed chunk */</span>
<span class="cp">#define chunk_is_mmapped(p) ((p)-&gt;mchunk_size &amp; IS_MMAPPED)
</span>

<span class="cm">/* size field is or'ed with NON_MAIN_ARENA if the chunk was obtained
   from a non-main arena.  This is only set immediately before handing
   the chunk to the user, if necessary.  */</span>
<span class="cp">#define NON_MAIN_ARENA 0x4
</span></code></pre></div></div>

<p>chunk的结构：</p>

<p>allocated chunk:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |             Size of previous chunk, if unallocated (P clear)  |
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |             Size of chunk, in bytes                     |A|M|P|
      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |             User data starts here...                          .
	    .                                                               .
	    .             (malloc_usable_size() bytes)                      .
	    .                                                               |
nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |             (size of chunk, but used for application data)    |
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |             Size of next chunk, in bytes                |A|0|1|
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

</code></pre></div></div>

<p>free chunk:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |             Size of previous chunk, if unallocated (P clear)  |
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    `head:' |             Size of chunk, in bytes                     |A|0|P|
      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |             Forward pointer to next chunk in list             |
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |             Back pointer to previous chunk in list            |
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |             Unused space (may be 0 bytes long)                .
	    .                                                               .
	    .                                                               |
nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    `foot:' |             Size of chunk, in bytes                           |
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |             Size of next chunk, in bytes                |A|0|0|
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

</code></pre></div></div>

<p>单链表结构</p>

<p>alloca过程：</p>

<ol>
  <li>
    <p>Select: 根据请求的size选择合适的bin，索引<code class="language-plaintext highlighter-rouge">idx = (requested_size - 1) / 16;</code></p>
  </li>
  <li>
    <p>Check: 检查是否有空闲的cache可用 <code class="language-plaintext highlighter-rouge">if our_tcache_perthread_struct.count[idx] &gt; 0;</code></p>
  </li>
  <li>
    <p>Reuse: 如果可用，分配链表头部的chunk</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>unsigned long *to_return = our_tcache_perthread_struct.entries[idx];
tcache_perthread_struct.entries[idx] = to_return[0];
tcache_perthread_struct.count[idx]--;
return to_return;
</code></pre></div>    </div>
  </li>
  <li>
    <p>Clear:  key清空</p>
  </li>
  <li>
    <p>Checking: 检查下一个链表指针是否合法</p>
  </li>
</ol>

<h4 id="防护">防护</h4>

<h5 id="key是在glibc-229引入主要是为了防止double-free的问题">Key是在glibc-2.29引入主要是为了防止double-free的问题。</h5>

<h5 id="safe-linking-glibc-232引入">Safe-linking （glibc-2.32引入）</h5>

<p>tcache中的next指针被xor处理保存(mangle)。</p>

<p>demangle后的值低4位必须是0。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define PROTECT_PTR(pos, ptr)
</span><span class="p">((</span><span class="n">__typeof</span> <span class="p">(</span><span class="n">ptr</span><span class="p">))</span> <span class="p">((((</span><span class="kt">size_t</span><span class="p">)</span> <span class="n">pos</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">)</span> <span class="o">^</span> <span class="p">((</span><span class="kt">size_t</span><span class="p">)</span> <span class="n">ptr</span><span class="p">)))</span>
<span class="cp">#define REVEAL_PTR(ptr) PROTECT_PTR (&amp;ptr, ptr)
</span></code></pre></div></div>

<h3 id="注意点-1">注意点</h3>

<p>printf，scanf将会使用malloc，</p>

<p>可以用setbuf禁用:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">setbuf</span> <span class="p">(</span><span class="n">stdout</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="n">setbuf</span><span class="p">(</span><span class="n">stdin</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="fastbins">Fastbins</h3>

<ol>
  <li>单链表并且也有safe-linking机制，与tcache相似</li>
  <li>链表没有长度限制，tcache限制有7个</li>
  <li>大小支持到88byte，tcach可以支持到1032</li>
  <li>P标志位会被永远设置，阻止合并</li>
  <li>double free检测只支持最顶部的chunk检测（由于它没有长度限制，都检测一遍那还了得，还干不干别的事了）</li>
</ol>

<h3 id="small-bins">Small bins</h3>

<ol>
  <li>双向链表</li>
  <li>大小支持到1024 bytes</li>
  <li>Fast access，但是支持合并</li>
</ol>

<h3 id="unsorted-bins">unsorted bins</h3>

<ol>
  <li>双向链表</li>
  <li>存放large bins和small bins，因此任何无法放进fastbins的都可以放这里</li>
  <li>malloc的时候这个unsorted bins会被检查，如果chunk不满足malloc，它就会被放进合适的small/large bins</li>
</ol>

<h3 id="large-bins">large bins</h3>

<ol>
  <li>双向链表</li>
  <li>bins包含 a range of size</li>
  <li>这意味着每个bin都被排好序，最大的在前</li>
  <li>bk_nextsize is used “jump up” in size category quickly，因为bins包含的是size的范围，这样如果区间没有大于请求的大小的chunk，就可以直接通过这个jump up到下一个区间的chunk里不需要再回bin中去遍历了。</li>
</ol>

<h3 id="exploitions">exploitions</h3>

<ul>
  <li>
    <p>Double Free</p>
  </li>
  <li>
    <p>Use After Free</p>
  </li>
  <li>
    <p>Corrupting Heap Metadata</p>
  </li>
  <li>
    <p>Overlapping Allocations</p>
  </li>
</ul>

<h2 id="linux内核">Linux内核</h2>

<p><a href="https://github.com/seacho/writeup/tree/main/pwncollege/kernelExp">writeup</a></p>

<h2 id="基于cpu缓存的攻击">基于CPU缓存的攻击</h2>

<p>详见<a href="https://github.com/seacho/writeup/blob/main/pwncollege/microarchitecture/meltdown.c">demo</a></p>
</section>
</article>

<div class="left-right-navigation">
	
	<a class="left" href="/2025/02/Linux-kernel-exploitation/">
		<i class="fa fa-chevron-left"></i>
		<div>Linux kernel exploitation</div>
	</a>
	
	
</div>


		</div>
		<footer class="site-footer">
	<div>
		&copy; 2025 p1ain0
		<span>&middot;</span>
		Code licensed under <a rel="license" href="https://github.com/bazad/bazad.github.io/blob/master/LICENSE">MIT</a>
		<span>&middot;</span>
		Content licensed under <a rel="license" href="https://creativecommons.org/licenses/by/4.0/" target="_blank">CC BY 4.0</a>
		<span>&middot;</span>
		<a href="/about-this-site">About this site</a>
	</div>
</footer>

		
	</body>
</html>
