* Introduction to RISC-V
Reduced Instruction Set Computer

** About RISC-V
RISC 处理器（精简指令集计算机的缩写）最初是在 20 世纪 80 年代设计的，是早期设计的演变。

实际上，RISC-V 一词可以根据上下文指代多种不同的东西：

指令集架构 (ISA)
ISA 的用户和开发者社区
RISC-V International，拥有和维护 ISA 知识产权的组织
基于 ISA 构建的硬件和 IP 产品
如您所见，这些事物中的每一个都围绕着 ISA 作为核心组件，但所有这些都是 RISC-V。一般来说，我们在对话中使用 RISC-V 来指代技术组件——ISA 及其各种规范——而其他上下文分别是 RISC-V 社区、RISC-V International 和 RISC-V 硬件。

*** RISC-V ISA and community
ISA 指的是指令集架构，是计算机的抽象模型 — 在本例中为精简指令集计算机 (RISC)。这组指令的规范是第五代 RISC 处理器，自 20 世纪 80 年代以来一直在开发中，因此我们称之为 RISC-V。

与私有公司或财团开发的技术不同，RISC-V 是由社区开发的，社区是由一群为这些规范的开发做出贡献的个人和组织组成的。社区成员来自各行各业 — 行业专业人士、学生、培训师以及对开放技术感兴趣并愿意了解更多信息的任何人。

虽然所有成员都有各自的参与理由，但他们都对开发公开可用的指令集架构规范及其周围的生态系统有着共同的兴趣。这个生态系统由各种各样的元素组成：

物理硬件：处理器、开发板、片上系统 (SoC)、模块系统 (SoM) 和其他物理系统。
"soft" IP 处理器内核，可加载到模拟器、现场可编程门阵列 (FPGA) 中或在硅片中实现。
整个软件堆栈，从引导加载程序和固件到完整的操作系统和应用程序。
教育材料，包括课件、课程、课程计划、在线课程（如本课程）、教程、播客、实验室作业，甚至书籍。
服务包括验证、定制电路板设计等。
所有这些社区成果都在 RISC-V Exchange 上得到认可，RISC-V Exchange 是 RISC-V 网站上的一个有组织的部分，从可用的硬件和软件、服务、学习材料和讨论点方面描述了生态系统。

该网站还列出了有关社区的更多信息，包括成员工作组的链接以及公共邮件列表、维基百科上的组织信息，当然还有规范本身——已完成、已批准的版本和正在开发的最新规范。

那么，为什么我们将其称为社区而不是市场呢？真正的原因是，我们认为社区是迄今为止处理像从头开始构建新架构这样复杂的工作的最佳方式，使用经过验证的开源开发方法。 RISC-V 的核心是一个由高度积极的人组成的社区，他们专注于相同的目标，并利用许多人共同努力的力量来承担重担。

RISC-V 的故事始于加州大学伯克利分校并行计算实验室。首先，我们讨论开源和开放标准的重要性，因为它们直接适用于 RISC-V ISA 的开发过程和开放许可。

技术不会孤立地存在，除非我们谈论的是像手电筒这样非常简单的未连接设备——即使在这种情况下，我们也依赖国际标准将电池连接到灯泡。随着我们的技术世界变得越来越复杂和联系越来越紧密，全球标准确保社会能够实现从发明者到消费者的互操作性的深远好处。

标准推动了基础平台层面的创新，从机器螺钉上的标准螺纹到微处理器上连接硅片的螺纹。工程领域自愿标准的制定可以追溯到一个多世纪以前。从 1980 年代末到 1990 年代，蒂姆·伯纳斯-李 (Tim Berners-Lee) 领导了一场革命，以标准化我们在互联网上使用的协议 (URL、HTML、HTTP、W3C)，这无疑是现代历史上技术效用的最大进步。有无数例子支撑着我们每天所依赖的技术。

通过全球协作和共识，以及开源开发和交付软件和硬件设计，软件和硬件标准化的进步加速了前所未有的全球技术进步。RISC-V 向开放社区发布，既是为了标准化，也是为了通过开放协作不断改进，这是 RISC-V International 的核心。如果没有协作和对 RISC-V ISA 和开放扩展的开放访问，社区就会面临分裂、分叉和建立多个标准的风险。

作为一种指令集架构，RISC-V 本身并不像软件那样“开源”，因为 ISA 不是由源代码组成的。然而，它是一个开放规范，它是根据知识共享许可发布的。RISC-V 中的其他工件，如软件和合规性测试，使用适当的许可证（例如 BSD 和 MIT），保留了 RISC-V 可供所有人使用的宽松的原始意图。

*** History of RISC and about ISAs
RISC 代表精简指令集计算机，这是 20 世纪 80 年代早期提出的一种基于简单性的计算机架构，与当时被称为复杂指令集计算机或 CISC 的微处理器不同。RISC 架构诞生于学术环境，因此其设计力求简单和高效，提出了一系列与 CISC 理念截然不同的功能，而 CISC 理念当时是受商业利益驱动的。RISC 在许多方面与 CISC 相反。通常，CISC CPU 具有一些寄存器和大量指令，其中大多数指令可以访问内存，而 RISC CPU 具有大量寄存器和非常适中的指令集，内存访问仅限于一些加载和存储指令。

现在，复杂指令集和精简指令集之间的区别在于数字：CISC 指令集通常支持大量指令，许多指令执行特定任务的复杂计算，而 RISC 指令集具有适量的简单通用指令。举个例子：英特尔的 80386（第一款 32 位微处理器）于 1985 年推出，支持超过 150 条指令，而 RISC-V 基本整数 ISA 于 2010 年发布，只有 40 条指令！

RISC 的缩写是由加州大学伯克利分校的 David Patterson 教授于 1980 年左右创造的，他与斯坦福大学的 John Hennessy 教授合作出版了著名的著作《计算机组织与设计》和《计算机架构：定量方法》。由于他们在 RISC 架构方面的工作，他们于 2017 年获得了 ACM A. M. 图灵奖。

在许多方面，RISC 的历史与 MIPS 处理器的历史息息相关。这两种处理器架构都以不同的方式取得了巨大的商业成功，尽管 RISC 架构更有可能通过一些非常流行的设计获得认可，包括 Sun Microsystems 的 SPARC 系列、DEC 的 Alpha 系列、英特尔的 i860 和 i960 处理器，以及如今许多硅片制造商数十亿台设备中无处不在的 ARM 处理器。RISC-V 是该指令集架构的最新版本。

许多RISC、MIPS 和其他设计都不同程度地“开放”。2005 年，Sun Microsystems 开放了 SPARC 架构，在 GNU 公共许可证 (GPL) 下创建了 OpenSPARC 项目。OpenRISC 项目通过 OpenCores 社区在较宽松的 GNU 公共许可证 (LGPL) 下提供 32 位和 64 位内核，该许可证比 GPL 的限制稍微少一些。Wave Computing 拥有的 MIPS 架构是在 2019 年结束的试点计划中根据“开放使用”许可证提供的。即使是 ARM，以前只向付费许可证持有者展示其架构，现在也部分开放了其架构以供合作伙伴进行更改。所有这些努力都是为了在合作伙伴和利益相关者的需求和愿望与市场现实、知识产权方面的国际法以及行业不断走向开源、开放规范和开放标准的历史势头之间取得平衡。

要点是，开放指令集架构既是一项非常有价值的努力，也是一项非常艰巨的任务。它需要众多利益相关者之间的合作、免受专利流氓和其他诉讼的侵害，以及为任何以结果为生的人提供明确的所有权路径。RISC-V 之所以取得巨大成功，是因为它致力于完全开放的架构、所有成员提供和同意的保护以及对社区的充分承诺。

*** Name of RISC-V
RISC-V 的名字是怎么来的？RISC 部分相当明显，但为什么是数字 5，为什么用罗马数字表示？

答案就在 ISA 规范本身的介绍中的脚注中：

RISC-V 这个名字被选中来代表加州大学伯克利分校的第五个主要 RISC ISA 设计（RISC-I [15]、RISC-II [8]、SOAR [21] 和 SPUR [11] 是前四个）。我们还使用罗马数字“V”来表示“变体”和“向量”，因为支持一系列架构研究，包括各种数据并行加速器，是 ISA 设计的明确目标。

*** Introduction to RISC-V International

因此，RISC-V 确实是一个社区。事实上，它是一个横跨 40 多个国家和数千人的全球社区。这个社区的核心是它的家园和指导力量——RISC-V 国际协会。

RISC-V 国际是一家瑞士非营利组织，成立的目的是组织围绕 ISA 以及其他工件（包括软件、非 ISA 规范、测试和合规框架等）的开发活动。RISC-V 由其成员组织并为其成员服务，其中包括 200 多个大大小小的组织以及数百名独立参与的个人成员，除了公司或大学。董事会包括来自每个会员级别的投票代表，因此 RISC-V 是一个真正平等的、以社区为基础的组织。

RISC-V 国际提供全球组织所需的所有管理活动——高管管理、推广和营销、会员支持、运营支持、技术项目管理和创意服务。它还为 RISC-V 知识产权提供法律支持，包括规范以及 RISC-V 商标和图像。

RISC-V International 雇用了一小部分员工来协助和指导社区组织起来，并与 Linux 基金会签订了合同，提供管理服务，包括人力资源、IT 和工具支持、财务支持等。Linux 基金会在运营开源基金会和项目方面拥有多年的经验，这直接有利于 RISC-V 社区实现其使命。

RISC-V International 不生产硬件。相反，它为所有成员组织提供了基于 RISC-V ISA 基础支持创建新技术的基础。作为一个开放规范项目，RISC-V 主要以规范的形式生成文档，例如指令集架构、测试和调试规范、跟踪规范和其他相关工件。这些都是通过数千人的协作过程产生的，并经过严格的反馈和监督。 RISC-V International 成立的目的是引导这一进程，使用标准组织和开源流程的最佳实践来制定规范，并为成员和更广泛的社区提供价值。

*** Evolution of RISC-V International
RISC-V 基金会成立于 2015 年，旨在基于 RISC-V ISA 构建一个开放、协作的软件和硬件创新者社区。该基金会是一家由其成员控制的非营利性公司，指导开发以推动 RISC-V ISA 的初步采用。

2018-2019 年期间，RISC-V 社区反思了地缘政治格局，并听取了世界各地的担忧，即对 RISC-V 的投资必须伴随着 IP 访问连续性，以确保长期战略投资。

在瑞士注册成立可以平息人们对开放协作模式受到政治干扰的担忧。作为一个非营利、会员制的组织，RISC-V International 不对产品或服务保持任何商业利益。美国对 RISC-V 没有任何出口限制。此举并没有规避任何现有限制，而是缓解了未来的不确定性。

2020 年 3 月，RISC-V 国际协会在瑞士注册成立。与此同时，它转向了一种新的、更具包容性的会员结构。RISC-V International 的成员不仅可以访问 RISC-V ISA 规范、扩展和相关硬件和软件，而且有资格参与这些组件的开发。

RISC-V International 贡献和生产的 IP 受行业和全球标准许可的保护，任何公司都可以利用这些许可，无论其管辖范围如何。这种许可是一种常见的开源方法，可以促进不受任何地理法规约束的合作。开源 IP 不受出口管制。

我们鼓励组织、个人和爱好者加入我们的生态系统，通过开放标准和开源协作共同开启处理器创新的新时代。



** Describe the philosophy of RISC-V.


** List the goals of RISC-V International as a community-driven organization.
[会员列表](https://riscv.landscape2.io/?view-mode=grid&group=members)
RISC-V 是一个非营利性的会员制组织，由其成员通过董事会、技术指导委员会和许多其他工作委员会的代表治理来推动。

会员资格分为不同级别，会员可获得大量福利。最重要的是，会员流程为所有会员提供知识产权规划，并为 RISC-V ISA 本身提供出处和 IP 安全，这是 RISC-V International 的首要任务。所有成员都能够通过各种工作组和委员会充分参与技术开发过程以及项目管理。会员还可以参加许多年度活动和研讨会，并始终站在 RISC-V 开发的前沿。所有福利都在会员页面 (riscv.org/membership) 上列出。

那么，为什么 RISC-V 坚持会员制，而不是像 Linux 内核和许多其他开源软件项目那样向公众开放贡献和参与呢？

这样做的主要原因是刚才提到的 IP 保护。 RISC-V 会员协议和章程提供了坚实的保护，但其范围仅限于实际签署协议的会员。

虽然出于这个原因，积极参与仅限于会员，但 RISC-V 确实使整个技术流程对非会员透明（以只读方式），并提供丰富的学习机会以及一组公共讨论列表，经验丰富的 RISC-V 开发人员经常在其中做出贡献。

个人、学术机构和非营利组织可以免费成为 RISC-V 会员。营利性公司有三个会员级别，需缴纳年费，以支持对 RISC-V 的持续集体支持、促进和倡导，以及以下计划，以促进我们的 RISC-V 社区和成员的技术发展、学术包容性、市场采用和行业知名度。

会员成为高级会员是为了在 RISC-V 本身的治理中占有一席之地。高级 TSC 成员在管理技术流程的技术指导委员会中占有一席之地，而高级会员则在董事会和 TSC 中占有一席之地。

战略成员占 RISC-V 成员的最大比例，包括来自数十个行业的公司以及希望在财务上支持 RISC-V 的许多学术机构。战略成员根据其组织规模缴纳会费，有四个等级可供选择。战略成员每年选举三名董事会代表。

社区组织包括学术和非营利组织，其中许多组织还参加学术与培训特别兴趣小组，以交流想法和教育材料。社区组织不缴纳会费，尽管其中许多组织选择赞助 RISC-V 活动。社区组织每年为其团体选举一名董事会代表。

所有组织成员（高级、战略和社区组织）都可以使用 RISC-V 商标，其中包括 RISC-V 名称和徽标。

社区个人是 RISC-V 社区中最活跃的成员之一。所有技术和非技术工作组以及特殊兴趣小组都有活跃的个人。社区个人不缴纳会费，他们每年选举一名代表进入其团体的董事会。个人无权使用 RISC-V 商标，但其中许多人能够说服其雇主或他们所属的其他组织加入 RISC-V 组织。

*** RISC-V International Governance

RISC-V International 由其董事会管理。董事会由选举产生的董事组成，代表所有级别的会员，以确保在各个层面发出战略声音。此外，技术指导委员会 (TSC) 为组织的技术计划提供领导，包括制定长期战略、组建战术委员会和工作组以及批准技术交付成果以供批准或发布。

RISC-V International 还通过各种结构支持和推动临时和常设小组追求特定的行业、地理和战略利益。RISC-V International 的目标是指导和促进最广泛、最有效的合作，以造福其成员社区。


** Describe the organization around the RISC-V community.

1,341 / 5,000
社区发展是 RISC-V International 的核心——幕后没有一家公司，如果没有活跃的架构师和开发人员社区，就不会有 RISC-V。

规范开发团队——我们称之为“技术”社区——由 RISC-V International 成员组成，包括个人和组织。虽然每个成员都以自己的水平参与，但我们欢迎每个人在开发过程中发表意见。工作组和委员会由成员组织担任主席，但如果他们获得社区和技术指导委员会 (TSC) 的支持，足够热情和熟练的个人成员也可以帮助领导工作组。

欢迎所有成员通过邮件列表、会议和研讨会、网络研讨会和会议以及许多其他方式参与技术小组并做出贡献。技术工作组是公开可见的，因此非成员也可以关注讨论和进展。

此外，还有三个公共论坛，任何人都可以参与：

RISC-V 公共邮件列表，特别是 ISA-Dev 和 SW-Dev，可以追溯到 RISC-V 的早期

Exchange 论坛，为 RISC-V Exchange 上出现的项目提供集中讨论点

RISC-V Slack 频道用于实时聊天


** Understand how member organizations work together to develop an open source community.

2018 年 11 月，RISC-V 基金会宣布与 Linux 基金会建立联合合作。作为此次合作的一部分，Linux 基金会为 RISC-V International 提供运营、技术和战略支持，包括会员管理、会计、培训计划、基础设施工具、社区拓展、营销、法律和其他开源服务和专业知识。

无论是在开源软件、开放规范、开放标准还是任何其他类型的共享资源开发中，沟通都是基于社区的开发中最关键的部分。RISC-V 采用了数十年开源和学术经验中总结出的最佳实践。

虽然我们不会在这里介绍每一个沟通点，因为它们有时会发生变化和发展，但我们将介绍最重要的沟通点类型以及如何访问它们。

邮件列表：RISC-V 邮件列表由主持的、仅限会员参与的讨论组成，这些讨论与 RISC-V ISA、其他规范、测试框架和软件的开发有关。邮件列表是异步通信的宝贵工具，因为它们以可搜索的形式保存了带有日期戳的整个对话。

RISC-V 中的大多数技术小组（委员会、任务组和 SIG）都是公开可见的——积极参与仅限于成员，但任何人都可以阅读档案。RISC-V 中的管理和执行小组仅对 RISC-V 成员可见。
会议：邮件列表很棒，但会议通常可以大大提高沟通效率。大多数 RISC-V 工作组定期使用 Zoom 开会，并记录会议纪要，以免遗漏任何内容。
Slack：除了邮件列表和会议之外，许多 RISC-V 开发人员还使用同步在线通信，尤其是在活动期间。RISC-V 提供了一个 Slack 空间，其中包含有关各种主题的多个频道。这些频道上的活动不会保留，但这些频道是进行实时讨论的好方法，无需开会或打电话。
GitHub：大多数交付成果的工作都是使用 GitHub 完成的，它提供了一种非常适合技术开发的工作模型。GitHub 提供版本控制、软件和文档的持续集成和构建、问题跟踪以及记录良好的审批链。
RISC-V Wiki：与大多数开源项目一样，RISC-V 有一个包含大量信息的 wiki。我们 wiki 中的所有信息均向公众开放，但某些链接可能会指向仅对 RISC-V 成员开放的区域。
公共讨论组：还有一组不需要会员资格的公共讨论列表。您可以使用 RISC-V International 网站技术页面上的链接加入这些讨论和其他讨论。
公共会议、研讨会和当地活动：RISC-V International 每年举办许多活动，最终在 12 月举行我们的年度 RISC-V 峰会。此外，RISC-V 赞助并参与许多行业活动，RISC-V 分支机构也在世界各地举办活动。特别是，当地活动是了解 RISC-V 和结识特定领域人士的绝佳机会。活动在 RISC-V 网站上进行跟踪，并经常在营销活动委员会电话会议上进行讨论。
技术组织根据一组政策开展工作，这些政策经常更新以包括最佳实践。这些政策构成了 RISC-V 内部开发流程的基础，并使 2,000 多名开发人员能够共同努力。



[RISC-V Exchange](https://riscv.org/exchange/) 是一种特殊资源，它提供了一个窗口，让人们了解世界各地 RISC-V 社区的人们所完成的工作，包括教育材料、物理硬件、IP 核和大量软件。随着硬件和软件的不断创建，我们网站的这一部分也在不断增长。

Exchange 包含：

可用主板：基于 RISC-V 的单板计算机 (SBC)，包括开源硬件和专有设计。这些范围从简单的微控制器板到复杂的片上系统 (SoC) 设计。
可用核心和 SoC：这些硬件设计可能是开源的或专有的，可能是免费或可购买的。
可用软件：软件以二进制形式和源代码形式提供。许可证涵盖从宽松的开源到限制性的专有许可证。
可用服务：许多组织提供与 RISC-V 产品开发相关的服务，包括设计、验证、软件工具等。
可用的学习内容：书籍、在线课程、课程、学术材料以及与学习 RISC-V 相关的任何其他内容。

** Know how to contribute and make a difference within the RISC-V community.

为 RISC-V 做出贡献的方式与指令集架构生态系统中的组件一样多。

以下是您可以为 RISC-V 社区做出贡献的一些方式：

通过学习资源构建 RISC-V 知识。
成为 RISC-V 大使技术专家。
在 RISC-V Careers 上发布 RISC-V 技术职位空缺。
成为导师并指导 RISC-V 导师项目。
帮助维护技术规范。
编写和分享您自己的 RISC-V 项目。
有关您可以做出贡献的方式的详细列表，请务必阅读 RISC-V 会员福利和欢迎演示文稿(https://docs.google.com/presentation/d/1Q8gMcVwzqdqym3ugl_Q-LW0KMUApO-v8mWVdjqQE-MI/edit?usp=sharing)。

**技术贡献**

要了解在技术层面上为 RISC-V 做出贡献的过程，请阅读 RISC-V 技术 Wiki 中的开发人员入门指南。

要为规范或技术领域做出贡献，您可以查找 Groups.IO 中最相关的群组，加入该群组，关注邮件列表中的讨论，参加会议，并自愿提供帮助。

要提议新的群组、规范或主题，请发送电子邮件至 help@riscv.org，以获取有关从何处开始的指导。

**提出新指令**

RISC-V 旨在允许任何人向基本 ISA 及其任何扩展添加新指令。您可以在自己的实现上自由执行此操作，但您也可以为官方 ISA 规范做出贡献。对于后者，您必须成为 RISC-V 社区的活跃成员，负责维护您打算贡献的文档。这些社区在 RISC-V 技术 Wiki 中指定。

**识别和解决 GitHub 中的问题**

RISC-V 指令集架构 (ISA) 和相关规范由 RISC-V International 技术工作组内的 RISC-V International 贡献成员开发、批准和维护。规范的工作在 GitHub 上进行，并且可以使用 GitHub 问题机制为规范提供输入。


** ISA

在本章中，我们将介绍 RISC-V 的核心——指令集架构 (ISA)。我们将揭开 RISC-V 指令格式的世界：从 R 型到 J 型，我们将探索这些定义指令结构的不同格式。您将对 RISC-V 架构中数据的处理方式有一个基本的了解。

更深入地讲，我们将探索 RISC-V 的模块化特性，以了解其基本 ISA 以及旨在使 RISC-V 满足当今整个应用程序范围的计算需求的众多 ISA 扩展选项。

如果不探索 RISC-V 寄存器文件，我们的旅程就不会完整。这些寄存器充当架构的实验对象，存储数据并在程序执行期间见证其操作。我们将解释不同寄存器的用途，阐明它们在汇编语言中的作用。

此外，在 ISA 中，您将发现支撑 RISC-V 的核心原则。从固定指令长度到加载/存储架构，这些原则体现了简单性、效率和兼容性，使 RISC-V 成为一项突破性技术。

让我们揭开 RISC-V 指令集架构世界的神秘面纱。
Recognize the fundamental design principles and basic technical features of the RISC-V instruction set.

Recognize the structure of the different RISC-V instruction types, and the functions of the instructions within each type.

Describe the concept of modularity applied to an instruction set and how RISC-V in particular achieves it.

Identify some common RISC-V extensions and what functionality they add to the basic instruction set.

Discuss privilege modes and the memory model.

RISC-V ISA 的定义尽可能避免了实现细节。它应该被理解为各种实现的软件可见接口，而不是特定硬件工件的设计。然而，为了简化 ISA，多个设计决策受到硬件实现的影响，例如将乘法扩展与基本整数 ISA 分开。

RISC-V 手册分为两卷：第一卷涵盖基本非特权指令的设计，包括可选的非特权 ISA 扩展。非特权指令是通常可在所有特权架构中的所有特权模式下使用的指令，尽管行为可能因特权模式和特权架构而异。第二卷提供了第一个特权架构的设计。

*** RISC-V: A Modular ISA
RISC-V 是 1980 年启动的研究项目的第五代，是一种成熟的架构，旨在从他人过去失败的地方取得成功，并从错误中吸取教训。因此，RISC-V 被设计为模块化 ISA，而不是 ARM Cortex 系列等商用处理器中的传统增量 ISA。

这种模块化意味着 RISC-V 实现由强制性基本 ISA 和许多 ISA 扩展组成，以便可以根据应用程序的需求定制定制 CPU。任何扩展都可以用于特定实现，也可以省略。

相反，增量架构要求 ISA 包含其扩展的 ISA 中包含的所有 ISA。例如，ARM Cortex-M4 指令集包含 Cortex-M3 指令集中的所有指令，反过来，也包含 Cortex-M0+ 指令集中的所有指令。 ARM Cortex-M4 处理器不可能只包含来自 M4 和 M0+ 指令集的指令，而跳过中间的 M3 指令集的指令。

目前许多嵌入式微控制器的流行 RISC-V 核心都实现了 RV32IMAC ISA。让我们讨论一下这个命名法的含义。

自定义 RISC-V ISA 的命名约定由字母 RV（代表 RISC-V）后跟位宽，然后是一系列表示基本 ISA 及其扩展的 1 个字母的标识符组成。

考虑到这一点，RV32IMAC 表示：

RV32I：具有基本整数 ISA 的 32 位 CPU。这包括基本操作绝对必要的指令。

M：整数乘法和除法扩展。
A：原子指令扩展。
C：压缩指令扩展。此扩展为现有 RV321 指令的一个特殊子集（以 32 位编码）提供了另一种 16 位编码。
在下图中，我们以图形方式表示了非特权 RV32IMAC 指令集。请注意，该指令集显示了 RISC-V 的模块化（而非增量）特性。强制性基本 ISA 与一组扩展相结合。显示 RISC-V 模块化特性的 RV32IMAC 指令集

[!img](https://courses.edx.org/asset-v1:LinuxFoundationX+LFD110x+1T2024+type@asset+block/Ch2.RV321MAC.V2.png)


RV32IMAC ISA 的指令集

另一个流行的 ISA 是 RV32IMAFD，通常缩写为 RV32G。字母 G 不代表 ISA 扩展，而是代表通用。

要了解有关 RISC-V ISA 的更多信息，请阅读 David Patterson 和 Andrew Waterman 合著的《RISC-V 阅读器》一书。英文版非常便宜，西班牙语、葡萄牙语、中文和韩语译本可免费下载。

*** 定义指令集架构 (ISA)

指令集架构 (ISA) 是计算机的抽象模型。它也被称为架构或计算机架构。ISA 的实现，例如中央处理单元 (CPU)，称为实现。您可能听说过的一些 ISA 包括 x86、ARM、MIPS、PowerPC 或 SPARC。所有这些 ISA 都需要许可证才能实现它们。另一方面，RISC-V ISA 是根据开源许可证提供的，使用无需付费。

RISC-V ISA 有何不同

RISC-V 与其他 ISA 之间最显着的区别是 RISC-V 是由一个完全免费加入的成员组织开发的，并以宽松的开源许可证授权其 ISA。这意味着任何人都可以为规范做出贡献，并且没有任何一家公司或公司集团可以推动标准的方向。技术指导委员会 (TSC) 为我们的技术计划提供领导，并批准技术交付成果以供批准或发布。

协作开发模型

RISC-V 规范以技术指导委员会 (TSC) 批准的任务组的形式开始。任务组获得批准的章程后，他们开始在 GitHub 上公开工作，以 AsciiDoc 格式编写文档。GitHub 上的这些存储库只能接收来自 RISC-V 国际成员的拉取请求，但工作是公开透明的。对于选择记录会议纪要的团体，任务组会议的会议纪要也会公开发布。公众可以自由地向 GitHub 存储库提交问题，以便对任何规范提供早期反馈。

非 ISA 规范和标准（例如处理器跟踪、架构测试、软件覆盖）以类似的方式开发。RISC-V 规范存在于 GitHub 上，与数十个软件项目一起存放。已批准规范的列表及其 GitHub 存储库链接可在 https://riscv.org/technical/specifications/ 中找到。

*** RISC-V Extensions Lifecycle

RISC-V 的每个模块化规范都经过一个设计过程，设计的成熟度由其状态表示，状态可能是开放、冻结或已批准。

RISC-V International 指定了一个提出 ISA 扩展的程序，原则上任何人都可以遵循。主要步骤总结如下：

由其支持者和/或整个社区开发的扩展被称为“开放”状态。
当扩展的所有主要功能都已开发到除了极小的更新之外不可能进行任何实质性修改的程度时，扩展被称为“冻结”状态。
冻结的扩展需要经过一段时间的公开审查以进一步完善，并最终通过投票批准，之后扩展被称为“已批准”状态。
要了解 RISC-V 规范的生命周期，您可以阅读 RISC-V 生命周期指南。

每个 RISC-V 扩展在批准的过程中都要经历几个阶段。在本节中，我们将简要回顾每个被称为“里程碑”的阶段。RISC-V 生命周期指南对这些里程碑的定义如下。


*** RISC-V ISA 分为两个部分：

第 1 卷，非特权规范
第 2 卷，特权规范
要理解为什么将规范分为两个不同的部分，我们必须首先了解一些计算机架构和安全性。从历史上看，处理器使用分层保护域（通常称为特权环）来保护数据和代码免受恶意行为者的攻击。为了便于说明，下图显示了英特尔的 x86 处理器的特权环及其常见用途。
最高特权的代码在“Ring 0”中运行，可以访问整个系统。处理器将根据特权级别决定授予执行代码哪些特权。例如，通过物理地址访问内存可能被限制在“Ring 0”中，因此其他环必须引用虚拟地址空间。通常，处理器一次只能在一种特权模式下运行，并且有特殊指令可以在模式之间移动。所有这些细节可能因系统而异，但它们必须遵循给定架构的规范文档中规定的规则。

RISC-V 有三个特权级别：用户模式（U 模式）、管理模式（S 模式）和机器模式（M 模式）。可以将它们分别视为“Ring 2”、“Ring 1”和“Ring 0”。其他模式（如虚拟机管理程序模式（H 模式））可作为这 3 种基本模式的变体。

与上图非常相似，U 模式用于用户进程，S 模式用于内核和/或设备驱动程序，M 模式用于引导加载程序和/或固件。每个特权级别都可以访问特定的控制和状态寄存器 (CSR)，这些寄存器是报告系统状态或控制其行为的特殊寄存器。较高特权级别可以访问较低特权级别的 CSR。

简而言之，非特权规范详细说明了与机器模式 (M-Mode) 或监控模式 (S-Mode) 无关的项目。非特权规范包括基本整数 (I) ISA 以及对该基础的扩展，如浮点 (F)、双精度 (D)、压缩指令 (C) 等等。

基本指令集描述了指令格式、基本整数指令、加载和存储指令以及 ISA 的其他基本细节。我们将基本 ISA 分为几种变体：

RV32I - 32 位整数。

RV32E - RV32I 的一个版本，具有较少的寄存器，适用于嵌入式应用。

RV64I - 64 位整数

RV128I - 128 位整数

所有这些基本 ISA 都会减少或扩展 RV32I 基本指令集。例如，RV64I 将整数寄存器和支持的用户地址空间扩展至 64 位。这意味着 LOAD 和 STORE 指令的工作方式与 RV32I 略有不同，非特权规范包含解释这些差异的章节。

*** The RV32I Base Integer ISA

RV32I 基本整数 ISA 仅包含 40 条指令，可实现使用 32 位整数实现基本功能所必需的操作（其 64 位版本为 RV64I）。此 ISA 以 32 位编码，包含以下指令：

Addition
Subtraction
Bitwise logical operations
Load and store
Jumps
Branches

基本整数 ISA 还指定了 32 个 CPU 寄存器（均为 32 位宽），以及程序计数器。唯一的特殊寄存器是 x0，它始终读取 0，就像许多以前的 RISC ISA 中实现的那样。

虽然所有寄存器都可用于通用目的，但应用程序二进制接口 (ABI) 根据其调用约定为每个寄存器指定了一个用途。这意味着一些寄存器需要保存临时或已保存的数据、指针、返回地址等。

*** Control and Status Registers (CSRs)

控制和状态寄存器（简称 CSR）是一组单独的寄存器，具有单独的 12 位地址空间，其数量限制为 4096。它们通常包含各种 CPU 信息，如计时器、计数器、标志、制造商信息和​​其他数据。

CSR 是用于控制和监控处理器操作的特殊寄存器。它们充当软件与硬件交互以调整设置、管理异常和获取有关处理器状态的信息的机制。了解 CSR 对任何 RISC-V 程序员来说都是必不可少的，因为它们允许精确控制处理器的行为并实现高效的系统编程。

Zicsr 扩展包含用于操作 CSR 的指令，例如 CSRRW（CSR 读写）、CSRRS（CSR 读取和设置）和 CSRRC（CSR 读取和清除）。这些指令允许软件读取和修改控制和状态寄存器中的值。CSR 指令在非特权规范文档的第 2.8 章中介绍。

RISC-V 架构中有几个重要的控制和状态寄存器 (CSR)，每个寄存器都具有特定的功能。以下是一些最重要的 CSR：

mstatus（机器状态寄存器）：这个 CSR 可以说是最关键的，因为它控制和监控机器的操作模式和特权级别。它包含用于控制中断启用/禁用状态、设置特权级别（M 模式、S 模式、U 模式）和影响处理器行为的各种标志的字段。它是特权级别转换和中断管理的基础。
mepc（机器异常程序计数器）：存储在机器模式下导致异常或中断的指令的程序计数器值。它确定程序在处理异常后应在何处恢复执行。
mtvec（机器陷阱向量基址）：指定机器模式的陷阱处理程序的基址，确定发生异常时处理器应跳转到的位置。
mcause（机器原因寄存器）：此 CSR 提供​​有关最近异常或中断原因的信息。它区分异常和中断，并提供指示具体原因的代码，例如页面错误或软件中断。
misa（机器 ISA 寄存器）：指定处理器支持的指令集扩展，允许软件确定 RISC-V 处理器的功能。它还对基本 ISA（RV32、RV64 或 RV128）的位宽进行编码。
这些 CSR 是 RISC-V 处理器运行的基础，可实现特权模式​​控制、异常处理，并提供有关处理器功能和最近事件的信息。还有许多其他 CSR 发挥着重要作用，这五个是基本处理器操作和软件开发中最关键的。

*** ISA Extensions

非特权规范还包含对这些基本 ISA 扩展的描述。同样，任何不需要 M 模式即可运行的扩展都可以在非特权规范中描述。

基本 ISA 的每个扩展都由一个任务组开发和维护：

加密任务组致力于加密扩展，可以将许多复杂的加密算法转移到硬件中，从而提高可靠性和速度。

B 扩展任务组致力于位操作扩展，可以加速许多常见的数学任务。

矢量 (V) 扩展任务组致力于矢量指令，这是许多图形处理计算的核心。
一旦获得批准，这些扩展就会添加到非特权规范中。接下来，我们将介绍一些最流行的 RISC-V ISA 扩展。

*** The M Extension, for Multiplication
RV32M 扩展实现了 8 条指令来对整数执行乘法和除法（RV64M 在这 8 条指令的基础上添加了 5 条指令）。

非特权规范的第 7 章描述了应如何完成整数乘法和除法。它描述了每条乘法指令的行为方式、哪些寄存器用于乘数和被乘数以及结果将存储在何处。它对除法也做了同样的事情，因为从功能上讲，人们可以将除法简单地视为乘法的逆运算。
*** The F and D Extensions, for 'float' and 'double'

F 代表浮点

F 扩展增加了对单精度浮点算术运算的支持。单精度浮点数通常使用 32 位表示，符合 IEEE 754 标准。

此扩展引入了单精度浮点寄存器（f0 到 f31）和一组单精度浮点指令，用于执行加法、减法、乘法、除法以及整数和单精度浮点值之间的转换等运算。

F 扩展还包括用于处理特殊值（如 NaN（非数字）和无穷大）以及用于比较和舍入单精度值的指令。

D 代表双精度

D 扩展扩展了 RISC-V 的浮点功能，包括双精度浮点算术运算。双精度数使用 64 位表示，也遵循 IEEE 754 双精度算术标准。

借助 D 扩展，双精度浮点寄存器 f0 至 f31 现在为 64 位宽，并且支持双精度算术运算指令、整数和双精度值之间的转换以及处理特殊值。

双精度算术对于需要比单精度算术更高精度的科学和工程应用尤为重要。

同样，许多嵌入式应用程序不需要浮点逻辑，因此这些扩展不是基本 ISA 的一部分。

*** The C Extension, for Compressed Instructions

压缩指令集扩展是 RISC-V ISA 的一个巧妙补充，它为现有指令的一个特殊子集提供了另一种 16 位编码，从而减少了静态和动态代码大小。

在分析了现代优化编译器生成的无数行代码后，RISC-V 的创建者确定了最流行的指令，并创建了这些流行指令的 34 个 16 位版本，放弃了其完整 32 位版本的部分功能（无论如何，这些功能在 RV32I 基本 ISA 中仍然可用）。

通常，程序中 50%–60% 的 RISC-V 指令可以用 RVC 指令替换，从而减少 25%–30% 的代码大小。C 扩展与所有其他标准指令扩展兼容。这些 16 位指令可以自由地与 32 位指令混合。这意味着任何指令都可以从任何 16 位边界开始。因此，在任何系统中添加 C 扩展后，任何指令都不会引发指令地址未对齐异常。

这种压缩是可能的，因为对于这些特殊指令：

某些寄存器比其他寄存器更受欢迎（根据 ABI）。
通常会覆盖一个操作数。
有一些首选立即值。
这允许将有限数量的寄存器的指令编码为操作数，仅指定 2 个寄存器而不是 3 个，使用较小的立即值，所有这些都是 16 位。

通过压缩最常用的指令，您更有可能显著压缩程序。

在下图（您之前已经看过）中，将绿色块（RV32I）与橙色块（RV32C）进行比较。 假设 RV32I 指令为 32 位宽，而 RV32C 为 16 位宽。
[](https://courses.edx.org/asset-v1:LinuxFoundationX+LFD110x+1T2024+type@asset+block/Ch2.RV321MAC.V2.png)


那么，C 扩展中的指令是伪指令，对吗？

错！

伪指令是添加到汇编语言中的特殊指令，可使编程更简单。伪指令可直接转换为机器代码，并受汇编程序和编译器工具链的支持。

C 扩展为现有基本 ISA 指令的特定版本提供硬件支持。

因此，一个区别是伪指令是逻辑加法（软件），而 C 扩展中的指令代表逻辑和物理加法（软件和硬件）。

*** More Extensions

RISC-V 的开放性允许我们不会涉及的其他扩展的丰富扩展。这里我们有一些示例：

A 扩展，用于原子内存操作

​​Q 扩展，用于四精度浮点运算，引入 128 位宽浮点寄存器

B 扩展，用于位操作

S 扩展，用于管理程序操作

H 扩展，用于虚拟机管理程序操作

L 扩展，用于十进制浮点运算

P 扩展，用于 Packed-SIMD 指令

V 扩展，用于矢量操作

Zicsr 扩展，用于操作 CSR 寄存器

Zifencei 扩展，用于指令内存同步
再次重申，此列表并不详尽。

几乎所有上述扩展都已获得批准，只有 L 和 P 扩展仍在讨论中，因此是开放的。

*** Unsupported Instructions

您可能想知道：

当 RISC-V 处理器执行包含其未实现的指令的程序时会发生什么？

例如：

假设 RV32IAC 处理器获取乘法指令以供执行。如果处理器未实现 M 扩展，它应该如何处理该指令？

好吧，编译器会被告知目标 CPU 中包含的扩展，以便它们可以生成最佳代码。如果代码包含物理 CPU 中缺少的扩展中的指令，则该指令的解码将触发非法指令异常。在 CPU 上运行的软件必须处理此异常并采取适当的措施，例如模拟指令或提供替代实现（可能来自标准库）。

因此，下次您在反汇编视图中看到汇编代码时，请注意目标 CPU 可能不支持的 RISC-V 汇编指令。您甚至可能希望检查这些指令的执行情况，以更好地了解正在发生的事情。


*** Instruction Encoding

RV32I ISA 指定了以下元素：

1 个 32 位宽的程序计数器寄存器

32 个 32 位宽的寄存器，命名为 x0 至 x31

40 个唯一的 32 位宽的非特权指令，采用六种不同的格式（R、I、S、B、U、J），但有一些重复的字段：
指令的 7 个最低有效位中的主操作码，用于标识指令。

源寄存器（rs1 始终位于位 15 至 19，rs2 位于位 20 至 24）。

目标寄存器（rd 位于位 7 至 11）字段。

函数字段或次要操作码，根据其位宽命名为 funct7 或 funct3。 Funct7 占用 R 类型指令的最后 7 位，而 funct3 始终占用第 12 至 14 位。
立即数字段，始终位于指令的末尾（左侧），并且根据指令类型采用不同的编码。
24 个额外的独特 32 位宽特权指令，有两种格式（R 和 I）。
在这些元素中，我们现在感兴趣的是指令的编码。下表显示了这一点：
[](https://courses.edx.org/asset-v1:LinuxFoundationX+LFD110x+1T2024+type@asset+block/Ch2.GenStructInstr.png)

RISC-V 的一个关键原则在该表中脱颖而出，那就是固定指令长度：

所有指令都以 32 位编码。没有例外。

这些编码在 RISC-V 架构中用于对不同类型的指令进行分类和描述。以下是每种指令编码的简要说明：

R 型指令用于涉及两个源寄存器和一个目标寄存器的操作。它们通常包括算术和逻辑运算，例如加法、减法、按位运算和比较。
I 型指令用于涉及立即值（常数）和源寄存器的操作。常见的 I 型指令包括加载操作以及具有立即值的算术运算（例如，addi 表示“添加立即数”）。
S 型指令是 I 型指令的一个子集，专门用于将数据存储到内存中。它们涉及源寄存器、立即数偏移量和基址寄存器，以指定要存储数据的内存位置。
B 型指令用于条件分支操作。它们比较两个寄存器，并根据结果确定是否执行分支指令。常见的 B 型指令包括 beq（相等则分支）和 bne（不相等则分支）。
U 型指令用于将寄存器的高位设置为常数值，通常用于初始化指针或地址。U 型指令包括 lui（加载高位立即数）和 auipc（将高位立即数添加到 PC）。
J 型指令用于无条件跳转操作。跳转指令将控制权转移到指定的目标地址，就像用于子程序调用的 jal（跳转和链接）指令一样。
这些指令编码是 RISC-V ISA 设计的一部分，提供了一种结构化的方式来分类和执行各种类型的指令。它们有助于使 RISC-V 架构高效并适用于广泛的应用。

*** Immediates and Addresses

除了操作码和寄存器之外，除 R 类型之外的任何指令编码都可能包含立即数，即直接在指令中编码的一段数据，而不是在内存或寄存器中。此数据可以表示常量（例如用于算术运算），也可以表示为内存地址或偏移量。

对立即数的不同处理是定义指令类型的确切特征，但它们都倾向于在类似的位置对立即数进行编码，以简化硬件立即数解码器的实现。所有立即数都解码为 32 位宽的值，但编码因指令而异。

*** Instructions in Assembly Language

指令助记符在 RISC-V 汇编语言中用于以更易于理解的形式表示特定指令。助记符是一串短字母，代表特定指令。

例如，在指令“add x1, x2, x3”中，“add”是代表 add 指令的助记符。从功能上讲，该指令表示“将 x2 的内容与 x3 的内容相加，并将结果存储在 x1 中”。

当汇编程序在源代码中遇到助记符时，它将使用该助记符将指令转换为指令的相应机器代码表示，以及操作数的编码。

例如，指令“add x1, x2, x3”被汇编程序转换为机器代码指令 0x003100B3。这个长十六进制数可以扩展为二进制，如下所示：

0000 0000 0011 0001 0000 0000 1011 0011

反过来，它可以被拆分为具有以下字段的 R 型指令：


(https://courses.edx.org/asset-v1:LinuxFoundationX+LFD110x+1T2024+type@asset+block/Ch2.Encodingx1x2x3.png)

如上所示，编码指令中位字段的含义如下：

funct7：0000000
rs2：00011，表示 x3。
rs1：00010，表示 x2。
funct3：000
rd：00001，表示 x1。
opcode：0110011，表示添加。
请记住，助记符既可用于指令，也可用于伪指令，汇编程序会将其转换为机器指令。

*** The RISC-V Instruction Set Reference Documents


现在正是您复习 RISC-V 指令集中（不是那么多）指令的好时机，特别是因为您对指令编码有一些了解。

正如我们现在已经确定的那样，指令集分布在 RISC-V 基本 ISA 和扩展中。因此，如果您需要详细复习一些指令，最好随身携带《RISC-V 指令集手册第一卷：非特权 ISA》。

但是，本文档非常详尽和具体，因此快速参考文档等更简单的替代方案可能对您来说更方便。我们推荐以下内容：

RISC-V 参考卡，作者 James Zhu。浏览这份简短的文档以熟悉 RV32I 和许多扩展中的指令。
RISC-V 参考卡包含在前面提到的书籍《RISC-V 阅读器》（作者 David Patterson 和 Andrew Waterman）（或其中的专用附录 A：RISC-V 指令列表）中。您可能想要获得这本书的副本，但参考卡可以免费下载。
请花点时间获取其中一张参考卡，然后再转到下一页。

有哪些按位逻辑运算可用？
AND
OR
XOR
有哪些条件分支可用？
Branch if equal
Branch if not equal
Branch if less than (signed and unsigned)
Branch if greater or equal (signed and unsigned)
哪些指令使用立即数？
除寄存器操作和环境调用外的所有指令。

是否缺少任何传统指令？是的，相当多！
Bitwise not
Branch if less or equal
Branch if greater than
Load immediate
No Operation (nop)
Unconditional jump
Subroutine call
Subtract immediate
Register Move/Copy

*** A Few Peculiar RISC-V Design Decisions

RISC-V 有一些相当奇特的设计决策，可能会引起人们的兴趣。您可能已经注意到以下一些奇怪的设计决策，并且可能想知道 RISC-V 的设计人员在提出这些决策时是怎么想的：

没有标志/条件代码寄存器。RISC-V 没有专用的条件代码寄存器，就像在许多其他架构中看到的那样。相反，它依靠分支指令直接使用通用寄存器的内容来评估条件。
寄存器 x0 硬连线为 0。在 RISC-V 中，寄存器 x0 硬连线为始终包含值 0 并且无法写入。这种设计选择简化了硬件，并且无需为使用常数 0 执行操作的指令分配单独的操作码。
无法在单个指令中指定 32 位立即数。相反，RISC-V 使用 2 条指令序列来指定完整的 32 位立即数。例如，lui 用于设置寄存器的高位，而 addi 可用于设置低位，如下所示：lui x1, 0x12345 设置 x1 的高位，然后 addi x1, x1, 0x678 设置低位，从而在 x1 中得到 32 位立即数 0x12345678。
与 32 位立即数使用单个指令相比，这种方法简化了指令解码和执行。
另一个原因是所有指令都以相同的长度编码，因此必须使用立即数获取第二个字不太像 RISC。
基本 RISC-V ISA 中没有专用的乘法或除法指令。相反，乘法和除法是使用常规算术和逻辑指令实现的，这可能会影响性能。然而，这种决定有利于低端嵌入式微控制器，它们甚至可能不需要乘法或除法。毕竟，对于用于运行可能需要乘法或除法的应用程序的处理器，RVM 扩展始终可以包含在内。
缺少许多基本指令。这些包括无条件跳转和分支、无操作、寄存器移动、二进制补码和按位非。事实证明，这些操作被认为是多余的，因为它们是 ISA 中现有指令的特殊情况。请记住：RISC 的关键原则之一是小型指令集。

但是等等！缺少某些指令并不意味着它们将实现的操作也缺失。由于这些操作可以由现有指令执行，因此 ISA 中定义了一组伪指令（因此由 RISC-V 汇编器支持），它们可以实现这些缺失的操作。以下是几个示例：
可以使用跳转和链接指令执行条件跳转，该指令将返回地址保存到寄存器 x0。请记住，写入此寄存器没有效果，因此跳转和链接指令最终会执行无条件跳转。
除了专用的“nop”指令外，您还可以使用简单的 addi x0, x0, 0 来执行无操作。此指令将 x0（为 0）的内容添加到立即数 0，并将结果存储在无法写入的寄存器 x0 中。这实际上没有完成任何操作，只是我们对 nop 的期望。
可以使用 XOR 指令和全 1 立即值来实现按位非。
除了“移动寄存器”指令外，还可以通过将源寄存器的内容与立即数 0 相加，并将结果存储在目标寄存器中来移动数据。
要计算寄存器的二进制补码，您只需从零中减去寄存器的内容即可。
所有这些操作的伪指令都可以在汇编语言中使用，就像它们是实际指令一样，因为在某种程度上，它们确实是实际指令。
没有堆栈指针。RISC-V 本身没有指定预定义的堆栈指针寄存器。虽然大多数架构（如 x86、MIPS 和 ARM）都包含专用堆栈指针寄存器，但在 RISC-V 中，选择使用哪个寄存器作为堆栈指针是由 ABI（应用程序二进制接口）决定的。这种灵活性允许不同的 ABI 为堆栈指针选择不同的寄存器，这在各种实现场景中都是有利的。

从技术上讲，除 x0 之外的任何寄存器都可以用作堆栈指针。
没有推送或弹出指令。RISC-V 不包含大多数架构中常见的用于管理堆栈的专用推送和弹出指令。堆栈操作通常是使用加载和存储指令的组合以及加法、减法和堆栈指针（由 ABI 定义）来实现的。
没有子程序调用或返回指令。这与上面的功能非常相似：子程序调用和返回指令可用作伪指令，由跳转和链接指令执行。
这些设计决策反映了 RISC-V 提供最小、可扩展基础架构的理念


*** Introduction to the Privileged Specification

到目前为止介绍的非特权指令集架构不足以运行现代执行环境。顾名思义，特权规范包含以机器模式 (M 模式) 或管理员模式 (S 模式) 运行的 RISC-V ISA 的描述。这些模式具有提升的权限，因此在与基本 ISA 和标准扩展完全不同的文档中描述。此规范还包含运行 Linux 等丰富操作系统所需的附加功能。

事实上，RISC-V 特权规范旨在支持实现如下所示的典型软件堆栈的虚拟化系统：

(https://courses.edx.org/asset-v1:LinuxFoundationX+LFD110x+1T2024+type@asset+block/Ch2.VirtMachMon.png)

该图显示了虚拟机监视器配置，其中单个虚拟机管理程序支持多个多程序操作系统。每个操作系统通过管理程序二进制接口 (SBI) 与虚拟机管理程序通信，后者提供管理程序执行环境 (SEE)。虚拟机管理程序使用虚拟机管理程序二进制接口 (HBI) 与虚拟机管理程序执行环境 (HEE) 通信，以将虚拟机管理程序与硬件平台的细节隔离开来。

这是当今计算系统所期望的复杂程度，RISC-V 必须能够提供所需的功能。

*** Machine-Level (M-Mode) ISA, Version 1.12

本章介绍机器模式 (M 模式) 中可用的机器级功能。M 模式用于对硬件平台进行低级访问，是重置时进入的第一个模式，此时处理器完成初始化并准备执行代码。M 模式还可用于实现难以或成本高昂而无法直接在硬件中实现的功能。一个很好的例子是在低级软件 (固件) 中实现的看门狗定时器，它可帮助系统从故障中恢复。我们将介绍规范中描述的 M 模式的三个重要功能：不可屏蔽中断、物理内存属性和物理内存保护。

不可屏蔽中断

不可屏蔽中断 (NMI) 仅用于硬件错误情况。触发时，它们会立即跳转到在 M 模式下运行的 NMI 处理程序，无论该硬件线程如何设置其中断启用位。换句话说，该中断将得到服务，而无法在配置中阻止该服务。每个 NMI 都有一个与之关联的“mcause”寄存器。这允许实现决定如何处理这些中断，并允许它们定义许多可能的原因。NMI 不会重置处理器状态，从而可以诊断、报告和可能遏制硬件错误。

物理内存属性 (PMA)

系统的物理内存映射包括地址范围，如内存区域、内存映射控制寄存器和地址空间中的空洞。一些内存区域可能不支持读取、写入或执行；一些可能不支持子字或子块访问；一些可能不支持原子操作；一些可能不支持缓存一致性或可能具有不同的内存模型。在 RISC-V 系统中，机器物理地址空间每个区域的这些属性和功能称为物理内存属性 (PMA)。

一些内存区域的 PMA 在芯片设计时固定 — 例如，对于片上 ROM。其他是在电路板设计时固定的，例如，取决于哪些其他芯片连接到片外总线。某些设备可能在运行时可配置，以支持不同的用途，这意味着不同的 PMA — 例如，片上暂存器 RAM 可能由一个终端应用程序中的一个内核私下缓存，或者在另一个终端应用程序中作为共享的非缓存内存访问。大多数系统都要求在知道物理地址后，在执行管道的稍后阶段在硬件中动态检查至少一些 PMA，因为某些操作不会在所有物理内存地址上都受支持，而某些操作需要知道可配置 PMA 属性的当前设置。

对于 RISC-V，我们将 PMA 的规范和检查分离到一个单独的硬件结构中，即“PMA 检查器”。在许多情况下，每个物理地址区域的属性在系统设计时都是已知的，并且可以硬连线到 PMA 检查器中。如果属性是运行时可配置的，则可以提供特定于平台的内存映射控制寄存器，以适合平台上每个区域的粒度指定这些属性（例如，对于可以灵活地在可缓存和不可缓存用途之间划分的片上静态随机存取存储器 (SRAM)）。

PMA 的细节很容易占据本课程的整整一章。我们不会介绍内存排序 PMA、幂等性 PMA、一致性 PMA 或可缓存性 PMA。特权规范第 3.5 节详细介绍了 PMA 的细节。高级用户可能需要查看此部分。

物理内存保护 (PMP)

大多数现代处理器的共同特征是执行安全远程计算或“可信执行环境”的某种方式。该技术的示例包括英特尔软件保护扩展 (SGX)、AMD 安全加密虚拟化 (SEV) 和 Arm TrustZone。虽然 RISC-V ISA 不提供可信执行环境的端到端解决方案，但物理内存保护 (PMP) 功能是构建此类系统的坚实基础。

RISC-V PMP 限制了在 hart（硬件线程）上运行的软件可访问的物理地址。可选的 PMP 单元提供每个 hart 机器模式控制寄存器，以允许为每个物理内存区域指定物理内存访问权限（读取、写入、执行）。PMP 值与我们在上一节中介绍的 PMA 检查并行检查。PMP 访问控制设置的粒度是平台特定的，并且在平台内可能因物理内存区域而异，但标准 PMP 编码支持最小为 4 个字节的区域。某些区域的权限可以硬连线 - 例如，某些区域可能只在机器模式下可见，但在任何较低权限层中都看不到。

*** Supervisor-Level (S-Mode) ISA, Version 1.12

本章介绍了 RISC-V 主管级架构，该架构包含一个通用核心，可用于各种主管级地址转换和保护方案。主管模式在与底层物理硬件（如物理内存和设备中断）的交互方面受到刻意限制，以支持干净的虚拟化。本着这种精神，某些主管级设施（包括对计时器和处理器间中断的请求）由特定于实现的机制提供。在某些系统中，主管执行环境 (SEE) 以主管二进制接口 (SBI) 指定的方式提供这些设施。其他系统通过其他实现定义的机制直接提供这些设施。

RISC-V 支持基于页面的 32 位、39 位和 48 位虚拟内存寻址。主管 (S 模式) 内存管理隔离指令 (SFENCE.VMA) 用于将对内存中内存管理数据结构的更新与当前执行同步。执行此指令可确保当前 RISC-V hart（硬件线程）已可见的任何先前存储都排在该 hart 对内存管理数据结构的所有后续隐式引用之前。

虚拟内存是一个需要几个月的研究生教育才能掌握的概念，超出了本课程的范围。对于本课程来说，您只要了解 RISC-V 支持多种宽度的基于页面的虚拟内存，并且有一个特殊的 S 模式指令用于同步硬件线程之间的更新就足够了。

*** Terminal Interface Assembly Code

#+BEGIN_SRC asm
# Introduction to RISC-V
# Terminal Interface, by Eduardo Corpeño 

###################################################
# Description
#
# This code asks the user's name in the console 
# and responds with a message using that name.
###################################################

# Data Section
.data
prompt:   .string   "Hey, what's your name?\n" 
response: .string   "\nIt's good to meet you, " 
name:     .string   "                       "

# Code Section
.text

###################################################
# Main entry point.
# The program starts here, at address 0x00000000
###################################################

main:
    # Initializations
    la t0, name # t0 points to the name string

    # print_string(prompt) - Environment call 4
    la a1, prompt
    li a0, 4
    ecall

    # Call read_str subroutine
    jal read_str

    # print_string(response) - Environment call 4
    la a1, response
    li a0, 4
    ecall

    # print_string(name) - Environment call 4
    la a1, name
    li a0, 4
    ecall

    # print_char(a0) - Environment call 11
    li a1, '!'
    li a0, 11
    ecall

    li a1, '\n'
    ecall
    ecall

    # Exit - Environment call 10
    li a0, 10
    ecall


###################################################
# read_str subroutine
# Read input string from the console.
# This input is a line of text terminated with
# the enter keystroke.
###################################################

read_str:
    # Initializations
    li a5, 1 # a5 holds comparison value for branching

    # Enable console input - Environment call 0x130
    li a0, 0x130 
    ecall

read_char:
    # Read a character from console input - Environment call 0x131 
    li a0, 0x131 
    ecall

    # Read the result of the environment call in a0
    beq a0, a5, read_char   # If still waiting for input, keep polling
    beq a0, zero, finish    # If buffer is empty, go to finish

    # Handle incoming character
    sb   a1, 0(t0)      # Append input character to name string 
    addi t0, t0, 1      # Increment the name string pointer

    # Iterate to get the next character
    j read_char

finish:
    # Subroutine epilogue
    sb zero, 0(t0)  # Append null-terminator to name string
    jr ra           # Return to caller


#+END_SRC


