---
title: "Linux kernel exploitation"
date: 2025-02-06
layout: post
categories: 
- PWN
tags: 
- PWN
---

关于linux的内核攻防的一些基础知识记录

<!--more-->


## Linux kernel exploitation

漏洞模式与用户态相似主要记录下内核的一些关键基础设施和漏洞利用的手法。


## 攻击面介绍

内核攻击来源于以下几个方面：

1.  network: remotely-trigged exploits (packets of death, etc). Rare!
2.  userpace: vulnerabilities in syscall and ioctl handlers (i.e., launched from inside a sandbox!), privilege escalation, rootkits, get more access to attack other parts of the system (i.e., trusted execution environments)
3.  From devices: launch kernel exploits from attached devices such as USB hardware[LINK](<https://www.pjrc.com/teensy/>)


## 内核调试环境

```shell
  qemu-system-x86_64 \
    -kernel ./bzImage \
    -initrd ./rootfs.img \
    -serial stdio \
    -append "console=ttyS0 root=/dev/ram rdinit=/sbin/init apic=debug nokaslr" -s -S

or
  qemu-system-x86_64 \
  -kernel ./bzImage \
  -initrd ./rootfs.img \
  -append "root=/dev/ram rdinit=/sbin/init apic=debug nokaslr" -s

```

使用qemu来模拟内核运行，使用gdb或者lldb来调试。

[Debugging:](<https://www.kernel.org/doc/Documentation/dev-tools/gdb-kernel-debugging.rst>)

[Feature-rich kernel experimentation environment:](<https://github.com/cirosantilli/linux-kernel-module-cheat>)

还有一些好用的gdb插件 gef,pt-dump fizmap


## 利用方式


### 权限逃逸

最经典的利用方式
kernel为每一个process维护着一个 `struct task_struct` 结构体，结构体中关于权限相关的成员变量，

```C
  /* Process credentials: */
  /* Objective and real subjective task credentials (COW): */
  const struct cred __rcu *real_cred;
  /* Effective (overridable) subjective task credentials (COW): */
  const struct cred __rcu *cred;


  struct cred {
        atomic_long_t	usage;
        kuid_t		uid;		/* real UID of the task */
        kgid_t		gid;		/* real GID of the task */
        kuid_t		suid;		/* saved UID of the task */
        kgid_t		sgid;		/* saved GID of the task */
        kuid_t		euid;		/* effective UID of the task */
        kgid_t		egid;		/* effective GID of the task */
        kuid_t		fsuid;		/* UID for VFS ops */
        kgid_t		fsgid;		/* GID for VFS ops */
        unsigned	securebits;	/* SUID-less security management */
        kernel_cap_t	cap_inheritable; /* caps our children can inherit */
        kernel_cap_t	cap_permitted;	/* caps we're permitted */
        kernel_cap_t	cap_effective;	/* caps we can actually use */
        kernel_cap_t	cap_bset;	/* capability bounding set */
        kernel_cap_t	cap_ambient;	/* Ambient capability set */
#ifdef CONFIG_KEYS
        unsigned char	jit_keyring;	/* default keyring to attach requested
                                         * keys to */
        struct key	*session_keyring; /* keyring inherited over fork */
        struct key	*process_keyring; /* keyring private to this process */
        struct key	*thread_keyring; /* keyring private to this thread */
        struct key	*request_key_auth; /* assumed request_key authority */
#endif
#ifdef CONFIG_SECURITY
        void		*security;	/* LSM security */
#endif
        struct user_struct *user;	/* real user ID subscription */
        struct user_namespace *user_ns; /* user_ns the caps and keyrings are relative to. */
        struct ucounts *ucounts;
        struct group_info *group_info;	/* supplementary groups for euid/fsgid */
        /* RCU deletion */
        union {
                int non_rcu;			/* Can we skip RCU deletion? */
                struct rcu_head	rcu;		/* RCU deletion hook */
        };
} __randomize_layout;
```

权限逃逸的方式就是更改这个cred,内核中有 `commit_creds(struct cred *)` 现成的函数可以利用，cred结构体很复杂，但是可以通过 `struct cred * prepare_kernel_cred(struct task_struct *reference_task_struct)` 来构造
如果我们给他传递一个NULL的参数，这个函数会返回给我们一个root权限的cred。即 `commit_creds(prepare_kernel_cred(0))` ;


### 沙箱逃逸

正常来讲，如果seccomp沙箱被正确配置了，即使通过漏洞被攻击了，可能做不了任何有用的事。但是它如果可以与内核模块交互，如果内核模块存在可被利用的漏洞，便可以达成逃逸效果。
例如：Powerful! Over 30 Chrome sandbox escapes in 2019 alone: [link](<https://github.com/allpaca/chrome-sbx-db>)

还是这个经典的 `struct task_struct` 结构体，有一个成员变量 `thread_info` ;

```C
struct thread_info {
  unsigned long flags; /* low level flags */
  u32 status; /* thread synchronous flags */
};
```

flags是一个bit field, 其中有一个bit， `TIF_SECCOMP` (新版本改成 `SYSCALL_WORK_BIT_SECCOMP` )。
[在linux的syscall的入口处](<https://elixir.bootlin.com/linux/v6.13.1/source/arch/x86/entry/vsyscall/vsyscall_64.c#L207>)

```C
/*
 * Handle seccomp.  regs->ip must be the original value.
 * See seccomp_send_sigsys and Documentation/userspace-api/seccomp_filter.rst.
 *
 * We could optimize the seccomp disabled case, but performance
 * here doesn't matter.
 */
regs->orig_ax = syscall_nr;
regs->ax = -ENOSYS;
tmp = secure_computing();
if ((!tmp && regs->orig_ax != syscall_nr) || regs->ip != address) {
        warn_bad_vsyscall(KERN_DEBUG, regs,
                          "seccomp tried to change syscall nr or ip");
        force_exit_sig(SIGSYS);
        return true;
}
```

[seccomp](<https://elixir.bootlin.com/linux/v6.13.1/source/include/linux/seccomp.h#L27>)

[thread\_info](<https://elixir.bootlin.com/linux/v6.13.1/source/include/linux/thread_info.h#L159>)

```C
static inline int secure_computing(void)
{
        if (unlikely(test_syscall_work(SECCOMP)))
                return  __secure_computing(NULL);
        return 0;
}

#define test_syscall_work(fl) \
      test_bit(SYSCALL_WORK_BIT_##fl, &current_thread_info()->syscall_work)

```

所以为了达到逃逸效果，我们只需要做 current\_task\_struct->thread\_info.flags &= ~(1 << TIF\_SECCOMP) 把这位清空就好了。

现在的问题是，如何寻找current\_task。地址保存在gs寄存器中。


### 缓解机制

与用户空间相似的缓解措施：

Stack canaries
bypass: leak the canary

kASLR bases the kernel at a random location at boot.
bypass: leak the kernel base address!
更疯狂的想法：函数粒度的ASLR。[More info](<https://lwn.net/Articles/824307>)

Heap/stack regions are not executable by default.
bypass: ROP

SMEP(Supervisor mode execution protection): 当进程处于内核模式时，此功能将页表中的所有用户空间页面标记为不可执行。在内核中，通过设置CR4寄存器中的第20 bit 来启用此功能。在启动时，可以通过在 `-cpu` 参数后面添加 `+smep` 来启用它，禁用它就通过 `-append` 参数后添加 `nosmep` 。

SMAP(Supervisor Mode Access Prevention): 此功能将页表中的所有用户空间页面标记为不可访问。通过设置CR4寄存器中的第21 bit 来启用此功能。在启动时可以功过在 `-cpu` 参数后面添加 `+smap` 来启用它，禁用它就通过在 `-append` 参数后添加 `nosmap` 。
但是在某些情况下，内核需要访问用户空间的数据怎么办？ `copy_from_user`  会帮助访问内存空间数据。
[MORE INFO](<https://wiki.osdev.org/Supervisor_Memory_Protection>)

KPTI(Kernel page-table isolation): 内核会完全分离用户空间和内核空间PageTable，而不是仅使用一组包含用户空间和内核空间地址的页表。一组页表与以前一样同时包含内核空间和用户空间地址，但它仅在系统以内核模式运行时使用。用于用户模式的PageTable包含用户空间的和一组最小的内核空间地址。启用： `kpti=1` 。禁用： `-append` 后边添加 `nopti`

内核中有 `run_cmd(char *cmd)` 函数: 只需以 root 身份像system()一样在用户空间中运行命令。


### kernel heap

堆机制与用户空间不同，

1.  glib中有太多的metadata，占用空间太多；
2.  随着时间的推移，内存碎片化会越来越严重。

内核使用[slab allocators](<https://people.eecs.berkeley.edu/~kubitron/courses/cs194-24-S13/hand-outs/bonwick_slab.pdf>)。slab在很多OS中都被广泛采用。
Linux有三种不同的slab特定实现：

-   <del>SLOB - Simple List of Blocks (deprecated)</del> （实现简单，通常用于嵌入式等场景）
-   <del>SLAB - (deprecated)</del>
-   SLUB - Unqueued slab allocator (默认使用的版本)

Linux默认采用SLUB，SLUB是一种改进版的SLAB。体现在：

1.  在设计上更加简化，减少了锁争用和复杂性。SLUB 使用了一种称为“per-cpu”缓存的技术，减少了全局锁的使用，从而降低了锁争用。

2.  SLUB 会在适当的时候合并相邻的空闲块，以减少碎片。

3.  SLUB 减少了元数据的复杂性，使得分配和释放操作更加高效。

4.  并且SLUB 提供了一些有用的调试和诊断工具，如 slabinfo 和 kmemleak，帮助开发者检测内存泄漏和其他问题。

1.  slab分配器简介：

    cache: 首先根据类型和大小，创建一个 **cache**  ，caches 包含 \*slabs\*，比如使用 `kmem_cache_create` 函数来创建一个新的cache（即 `struct kmem_cache` 类型）时，我们会指定类型和大小。使用 `kmem_cache_destroy` 函数销毁cache。
    
    slab: slab allocator 每次向 buddy system 请求得来的单张 / 多张内存页，称为slab，在内核中对应 slab 结构体，但是本质上是复用 page 结构体，
    
    slob: slabs由一系列的slob组成，其中slot是，是slabs中的内存区域，大小由cache管理，所以如果有一个256字节的缓存，那么slab上的slot的大小将是256字节
    
    object: slots包含object，如果slot是256大小的内存区域，那么当kmalloc的时候返回指针就是这些可用的slot之一的指针，一旦该slot被使用，我们就会说那个slot包含一个object。
    
    基本概念就已经讲清楚了。
    
    内核中有着大量的数据结构都是通过slub分配器分配，它们申请（create）并维护自己的kmem\_cache，所有的kmem\_cache又都被串在一个名为slab\_caches的双向链表上。kmem\_cache包含许多slab，每个 slab 是>=1个连续的page， 内部包含若干个相同大小的object（大小在kmem\_cache\_create的时候就指定，这样就不需要额外的内存来保存像glibc中的metadata）。这些object可以被alloc 或free。slab可以处于部分满、完全满或空闲状态。使用 `kmem_cache_alloc` 函数从缓存中分配一个object，使用 `kmem_cache_free` 函数将对象释放回slab。
    
    [相关数据结构](<https://elixir.bootlin.com/linux/v6.7.9/source/include/linux/slub_def.h#L98>)
    
    ```C
    struct kmem_cache {
    #ifndef CONFIG_SLUB_TINY
            struct kmem_cache_cpu __percpu *cpu_slab;
    #endif
      //...
    
            struct kmem_cache_node *node[MAX_NUMNODES];
    };
    ```
    
    我们讲的cache与kmem\_cache相同，它的slab都是使用 `kmem_cache_cpu` 和 `kmem_cache_node` 两个结构组织和维护的。
    
    ```nil
             +---------------------+
              |     kmem_cache     |
             +---------------------+
                     /       \
                    /         \
    +---------------------+     +----------------------+
    |   kmem_cache_cpu    |     |   kmem_cache_node    |
    |   +--------------+  |     |  +-----------------+ |
    |   |   freelist   |  |     |  |   nr_partial    | |
    |   +--------------+  |     |  +-----------------+ |
    +---------------------+     +----------------------+
                |                         |
                |                         |
                v                         v
           +----------+             +----------+
           |   slab   |             |   slab   |
           +----------+             +----------+
                |                         |
                |                         |
                v                         v
      +-------------------------------------------+
      |               Backing Memory              |
      |              [allocated slot ]            |
      |              [open slot ]                 |
      +-------------------------------------------+
    
    
    ```
    
    kmem\_cache\_cpu结构体用于存储每个 CPU 的本地缓存信息，即正在使用的slab信息。它的主要目的是通过减少对全局锁的竞争来提高分配和释放操作的性能。每个 CPU 都有自己的 kmem\_cache\_cpu 实例，这样可以在本地快速分配和释放对象，减少锁争用。
    
    ```C
    struct kmem_cache_cpu {
        void **freelist;        /* Pointer to next available object */ //指向当前 CPU 上空闲对象的链表头。
        struct page *page;      /* The slab from which we are allocating */ //指向当前使用的 slab 页面。
        struct page *partial;   /* Partially allocated slab */ //指向部分满的 slab 链表，这些 slab 还有未分配的对象。
        // ...
    };
    
    struct kmem_cache_node {
        spinlock_t list_lock;   /* Protects the partial and full lists */ //保护 partial 和 full 列表的自旋锁。
        struct list_head partial; /* List of partially allocated slabs */ //指向部分满的 slab 链表，这些 slab 还有未分配的对象。
        struct list_head full;  /* List of fully allocated slabs */  //指向完全满的 slab 链表，这些 slab 已经没有可用的对象。
        unsigned long nr_partial; /* Number of partial slabs */  //部分满 slab 的数量。
        // ...
    };
    
    
    ```
    
    kmem\_cache\_node包含当前CPU未使用的slab信息。kmem\_cache\_cpu有点类似glibc中的tcache，保存了该 CPU 私有的空闲对象（freelist），让分配/释放可以在本地 CPU 上快速完成。每个CPU的每一个cache都有一个激活的"working slab
    
    当 CPU 上的 freelist 不足或过多时，会与所属 NUMA 节点的 kmem\_cache\_node 进行交互（例如当需要一个新的slab时，partial slabs可以被交换进CPU的cache中，partials slabs会被追踪在kmem\_cache\_node中的nr\_partial链表里）
    
    full slabs 是不会被tracked的（除非在特定编译的内核中）
    full allocated的是不会被tracked的，内核甚至不关心它在哪，但是一旦被free，他就变成partial allocated的slab
    
    object如何在这些slot的slab上分配，这些slot是如何相互关联的？
    
    Slab Memory - Slots:
    slab Memory 可以被视为固定大小的slots组成的连续内存区域，这些插槽要么是空闲的，可用于allocation，要么包含该大小的某个objection，没有元数据的浪费，当我们free一个objection时，会被加入到kmem\_cache\_cpu的freelist的链表头部。这个freelist是一个单链表
    
    ```C
    +---------------------+          +-------------------+       +-------------------+                     
    |   kmem_cache_cpu    |          |                   |       |                   |
    |   +--------------+  |          |                   |       |                   |
    |   |   freelist   |--+--------->|   +-----------+   |       |   +-----------+   |
    |   +--------------+  |          |   |   next    |---+------>|   |   null    |   |
    +---------------------+          +---+-----------+---+       +---+-----------+---+
    
    ```
    
    free slots的next porter在slot的中间，比如：0x100byte的object将会存放next指针在偏移0x80的位置。
    
    私有cache：
    
    自己使用kmem\_cache\_create单独创建的一块cache。
    
    通用内核cache：
    
    使用kmalloc分配内存， `void *kmalloc(size_t size, gfp_t flags)` 会根据大小，选择一个合适的通用cache。cache会有一个命名约定，ex: kmalloc-8k, 8k是slot的大小。
    
    不受信任的allocation（比如包含用户空间数据的）可以使用一个GFP\_KERMEL\_ACCOUNT flag创建，那就不会转到kmalloc-8k，而是会使用kmalloc-cg-8k的cache。
    
    `cat /proc/slabinfo` 可以查看内核的slab情况

2.  内核的堆保护措施：

    1.  Freelist Randomization 
        默认情况下，新的slabs是按固定的顺序返回的slots。攻击者就很容易知道内存中已分配的objects的彼此之间的关系。
        
        通过一个宏控制这项功能的开关（编译前设置）[ `CONFIG_SLAB_FREELIST_RANDOMIZATION` ](<https://elixir.bootlin.com/linux/v6.7.9/source/mm/slub.c#L1889>) 首先生成随机索引序列来实现的，保存在 [ `kmem_cache.random_seq` ] (<https://elixir.bootlin.com/linux/v6.7.9/source/include/linux/slub_def.h#L142>)这个决定freelist的初始化序列。对于新的slab的freelist（本质是一个单链表）中的slots是随机打乱顺序的，这样就大大增加了攻击的难度，必须通过其他的漏洞获取一些信息。这样返回的objects就不再是按内存顺序可以预测的。后续free后的slots会被push到这个链表的头部。
    
    2.  Hardened Freelist
        与safe-linking的概念相似，把保存在slots中的下一个slot的指针xor加密。
        也是通过[ `CONFIG_SLAB_FREELIST_HARDENED` ](<https://elixir.bootlin.com/linux/v6.7.9/source/mm/slub.c#L374>)宏控制开关。
        细节是将下一个指针的值与一个随机值和当前地址的倒序值xor `decoded = (void *)(ptr.v ^ s->random ^ swab(ptr_addr));` 。
        
        特殊的情况，如果这个slot再列表中的最末端，它的next\_point会是NULL，这个时候它保存的值就是 `swab(&ptr) ^ NULL ^ rand`
        
        1.  Hardened Usercopy
            [CONFIG\_HARDENED\_USERCOPY](<https://elixir.bootlin.com/linux/v6.7.9/source/include/linux/slub_def.h#L149>)这个开关打开后cache会多维护两个变量:
            
            ```C
            #ifdef CONFIG_HARDENED_USERCOPY
                    unsigned int useroffset;	/* Usercopy region offset */
                    unsigned int usersize;		/* Usercopy region size */
            #endif
            
            ```
    
    当使用 `copy_to_user` 和 `copy_from_user` 两个函数的时候，会调用 `kmem_cache_create_usercopy` 和 `__check_heap_object` 检查传输的内存字节是不是在合法范围内。
    
    1.  KASLR
        
        与用户空间的ASLR相似，每次boot的时候随机化，要利用的话，只能先leak。
    
    1.  Kernel oops
        
        如果内核发生非致命的错误，会导致oops。
    
    错误细节包含寄存器信息，通过dmesg可以看到这会导致泄漏内核地址。
    
    内核也可以被配置成panic on oops：
    这种情况泄漏就比较困难，一些panic检查是针对特定进程的，也许可以使用多进程绕过。

3.  explition

    一些gdb调试内核的插件：gef，pt-dump
    `pt` 命令可以查看内存信息，
    `pt -has address` 可以查看指定的地址的内存信息
    
    通用 Heap Vulnerabilities:
    
    越界访问
    UAF: 泄漏/破坏freelist的元数据，创建任意读写，重叠分配
    
    利用方式：
    Heap Spraying
    内核Heap不太可预测，因为heap在所有内核操作之间共享。这使得将objects放在一起变得困难。解决方案是Heap Spray，能提高攻击的成功几率。
    
    对于kmalloc的通用cache，还有两个比较值的一提的利用方式：
    
    主要参考这篇文章[here](
    <https://google.github.io/security-research/pocs/linux/cve-2021-22555/writeup.html>)
    主要介绍了两个有价值的结构体：
    
    -   msg\_msg
    -   pipe\_buffer
    
    通过在用户空间使用这两个结构体在内核中灵活的申请特定大小的堆内存。
    
    有个有意思的全局变量：[modprobe\_path](<https://elixir.bootlin.com/linux/v6.7.9/source/kernel/module/kmod.c#L64>) 把这个全局变量覆盖后，使用命令行执行一个奇怪的文件就可以自动用sudo权限执行这个命令。
    
    还有一些函数比如：prepare\_kernel\_cred()、 commit\_creds()、run\_cmd()、swapgs\_restore\_regs\_and\_return\_to\_usermode()
    
    其他的一些资源：
    [Beginning Kernel Exploitation:](<https://lkmidas.github.io/posts/20210123-linux-kernel-pwn-part-1/>)
    [Kernel ROP (necessary):](<https://lkmidas.github.io/posts/20210128-linux-kernel-pwn-part-2/>)
    [RetSpill Exploitation Technique Paper:](<https://adamdoupe.com/publications/retspill-ccs2023.pdf>)
    [RetSpill Exploitation Technique Demo:](<https://github.com/sefcom/RetSpill>)
    [CVE-2021-22555 (important):](<https://google.github.io/security-research/pocs/linux/cve-2021-22555/writeup.html>)

4.  简单记录下pwn.college的challenge解题思路

    这里有8个题目，由易到难，由浅入深理解关于内核堆内存的分配过程。
    
    (1) 原程序在模块加载时就把flag读进bss段中，然后调用 `kmem_cache_create` 创建块缓存，并且在proc目录下创建交互的文件。
    
    `kheap_open` 当文件打开的时候会调用该函数，函数内部使用 `kmem_cache_alloc` 从cache中分配一块内存，并将内存清0后，开头8bytes放置 `do_print` 函数的地址。
    
    `kheap_ioctl` 当调用ioctl的时候内核会调用该函数，用户可控的有两个参数，cmd和arg，其中cmd代表执行的操作，arg是一个16字节的结构体指针，ubuf代表数据指针，size代表数据大小。
    
    ```C
    typedef struct _kheap_req_t // sizeof=0x10
    {                                       // XREF: kheap_ioctl/r
        void *ubuf;                         // XREF: kheap_ioctl+78/r
                                            // kheap_ioctl+FA/r
        size_t size;                        // XREF: kheap_ioctl+73/r
                                            // kheap_ioctl:loc_135/r
    }kheap_req_t;
    ```
    
    cmd      对应着不同的操作，根据反编译代码，0x5704对应的操作是malloc一块新内存，然后把flag的内容copy进去。0x5700对应操作是把open时分配的内存复制到用户空间中，但这里复制的大小是用户空间传递进去的，所以这里存在越界读，可以把flag的内容读取到用户空间。
    
    (2) 这个程序大致跟challenge-1一样，但是从用户空间中拷贝到内核空间中的数据是没有检查大小的，所以存在缓冲区溢出的漏洞，每一块的开头8字节是函数地址可以被覆盖。调用修改权限的 `commit_creds` 函数，由于块分配是随机的(Freelist Randomization)，因此可以多分配几个提高覆盖成功的几率。
    
    (3) 第三个challenge开启了KASLR，所以这就需要先泄漏内核地址。然后计算偏移填入缓冲区，使用缓冲区溢出覆盖堆上的指针。
    
    (4) challenge-4，这个题目就没有堆上的函数指针可以利用了，但是存在UAF，因此我们可以通过覆盖一个free的堆块的元数据，控制链表结构，然后我们可以获得任意地址写的漏洞。这里我们可以通过覆盖全局变量modpath来执行任意命令，这题也是开启了kaslr，首先也要泄漏内核地址。
       攻击流程：先通过open打开两个文件描述符，这样我们就有两个分配的堆块，然后释放一个，再读取该块。就可以获取堆上的地址。然后构造数据将计算后的modpath的地址加入链表。然后通过两次open获取分配的内存块即是modpath的内存，然后覆盖起其中的内容。
    
    (5) 与challenge-4相同，唯一不同的是内核开启了 `HARDENED` free堆块上的内容被加密存放，但这个通过泄漏的值，可以被计算。大致与glibc的利用方式相似。
    
    (6) 从这个challenge就开始转到通用的cache中了，不再使用单独的私有cache。这就意味着不可控的因素又变多了。这个题目比较简单用来熟悉msg\_msg的简单使用，由于题目中的是把flag读取进堆内存的，通过控制msg的大小来控制内核堆内存的分配，让它落在跟kheap相同的cache，然后利用UAF改写消息结构体中的内容越界读取flag内容。
    
    (7) 通过上一个题目的利用方式我们可以泄漏内核中的堆地址，然后通过控制msg\_msg结构体的msgseg的值来泄漏内核中任意地址的内容。然后结合UAF控制free堆链表的指针，达到任意写的目的，覆盖modprobe\_path的地址。
    
    (8) 这个利用过程与challenge-7差不多。
